var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key2 of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key2) && key2 !== except)
        __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// .svelte-kit/output/server/chunks/true.js
var DEV;
var init_true = __esm({
  ".svelte-kit/output/server/chunks/true.js"() {
    DEV = true;
  }
});

// .svelte-kit/output/server/chunks/ssr.js
function noop() {
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function validate_store(store, name) {
  if (store != null && typeof store.subscribe !== "function") {
    throw new Error(`'${name}' is not a store with a 'subscribe' method`);
  }
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function set_current_component(component24) {
  current_component = component24;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component24 = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component24.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component24, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key2, context) {
  get_current_component().$$.context.set(key2, context);
  return context;
}
function getContext(key2) {
  return get_current_component().$$.context.get(key2);
}
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function escape(value, is_attr = false) {
  const str = String(value);
  const pattern2 = is_attr ? ATTR_REGEX : CONTENT_REGEX;
  pattern2.lastIndex = 0;
  let escaped2 = "";
  let last = 0;
  while (pattern2.test(str)) {
    const i = pattern2.lastIndex - 1;
    const ch = str[i];
    escaped2 += str.substring(last, i) + (ch === "&" ? "&amp;" : ch === '"' ? "&quot;" : "&lt;");
    last = i + 1;
  }
  return escaped2 + str.substring(last);
}
function each(items, fn) {
  items = ensure_array_like(items);
  let str = "";
  for (let i = 0; i < items.length; i += 1) {
    str += fn(items[i], i);
  }
  return str;
}
function validate_component(component24, name) {
  if (!component24 || !component24.$$render) {
    if (name === "svelte:component")
      name += " this={...}";
    throw new Error(
      `<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules. Otherwise you may need to fix a <${name}>.`
    );
  }
  return component24;
}
function create_ssr_component(fn) {
  function $$render(result, props, bindings, slots, context) {
    const parent_component = current_component;
    const $$ = {
      on_destroy,
      context: new Map(context || (parent_component ? parent_component.$$.context : [])),
      // these will be immediately discarded
      on_mount: [],
      before_update: [],
      after_update: [],
      callbacks: blank_object()
    };
    set_current_component({ $$ });
    const html = fn(result, props, bindings, slots);
    set_current_component(parent_component);
    return html;
  }
  return {
    render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
      on_destroy = [];
      const result = { title: "", head: "", css: /* @__PURE__ */ new Set() };
      const html = $$render(result, props, {}, $$slots, context);
      run_all(on_destroy);
      return {
        html,
        css: {
          code: Array.from(result.css).map((css2) => css2.code).join("\n"),
          map: null
          // TODO
        },
        head: result.title + result.head
      };
    },
    $$render
  };
}
function add_attribute(name, value, boolean4) {
  if (value == null || boolean4 && !value)
    return "";
  const assignment = boolean4 && value === true ? "" : `="${escape(value, true)}"`;
  return ` ${name}${assignment}`;
}
var current_component, ATTR_REGEX, CONTENT_REGEX, missing_component, on_destroy;
var init_ssr = __esm({
  ".svelte-kit/output/server/chunks/ssr.js"() {
    ATTR_REGEX = /[&"<]/g;
    CONTENT_REGEX = /[&<]/g;
    missing_component = {
      $$render: () => ""
    };
  }
});

// .svelte-kit/output/server/chunks/index.js
function error(status, body) {
  if (isNaN(status) || status < 400 || status > 599) {
    throw new Error(`HTTP error status codes must be between 400 and 599 \u2014 ${status} is invalid`);
  }
  return new HttpError(status, body);
}
function redirect(status, location) {
  if (isNaN(status) || status < 300 || status > 308) {
    throw new Error("Invalid status code");
  }
  return new Redirect(status, location.toString());
}
function json(data, init2) {
  const body = JSON.stringify(data);
  const headers = new Headers(init2?.headers);
  if (!headers.has("content-length")) {
    headers.set("content-length", encoder.encode(body).byteLength.toString());
  }
  if (!headers.has("content-type")) {
    headers.set("content-type", "application/json");
  }
  return new Response(body, {
    ...init2,
    headers
  });
}
function text(body, init2) {
  const headers = new Headers(init2?.headers);
  if (!headers.has("content-length")) {
    const encoded = encoder.encode(body);
    headers.set("content-length", encoded.byteLength.toString());
    return new Response(encoded, {
      ...init2,
      headers
    });
  }
  return new Response(body, {
    ...init2,
    headers
  });
}
function fail(status, data) {
  return new ActionFailure(status, data);
}
var HttpError, Redirect, NotFound, ActionFailure, encoder;
var init_chunks = __esm({
  ".svelte-kit/output/server/chunks/index.js"() {
    HttpError = class {
      /**
       * @param {number} status
       * @param {{message: string} extends App.Error ? (App.Error | string | undefined) : App.Error} body
       */
      constructor(status, body) {
        this.status = status;
        if (typeof body === "string") {
          this.body = { message: body };
        } else if (body) {
          this.body = body;
        } else {
          this.body = { message: `Error: ${status}` };
        }
      }
      toString() {
        return JSON.stringify(this.body);
      }
    };
    Redirect = class {
      /**
       * @param {300 | 301 | 302 | 303 | 304 | 305 | 306 | 307 | 308} status
       * @param {string} location
       */
      constructor(status, location) {
        this.status = status;
        this.location = location;
      }
    };
    NotFound = class extends Error {
      /**
       * @param {string} pathname
       */
      constructor(pathname) {
        super();
        this.status = 404;
        this.message = `Not found: ${pathname}`;
      }
    };
    ActionFailure = class {
      /**
       * @param {number} status
       * @param {T} [data]
       */
      constructor(status, data) {
        this.status = status;
        this.data = data;
      }
    };
    encoder = new TextEncoder();
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
  }
});

// node_modules/bcryptjs/index.js
function randomBytes(len) {
  try {
    return crypto.getRandomValues(new Uint8Array(len));
  } catch {
  }
  try {
    return import_crypto.default.randomBytes(len);
  } catch {
  }
  if (!randomFallback) {
    throw Error(
      "Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative"
    );
  }
  return randomFallback(len);
}
function setRandomFallback(random) {
  randomFallback = random;
}
function genSaltSync(rounds, seed_length) {
  rounds = rounds || GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof rounds !== "number")
    throw Error(
      "Illegal arguments: " + typeof rounds + ", " + typeof seed_length
    );
  if (rounds < 4)
    rounds = 4;
  else if (rounds > 31)
    rounds = 31;
  var salt = [];
  salt.push("$2b$");
  if (rounds < 10)
    salt.push("0");
  salt.push(rounds.toString());
  salt.push("$");
  salt.push(base64_encode(randomBytes(BCRYPT_SALT_LEN), BCRYPT_SALT_LEN));
  return salt.join("");
}
function genSalt(rounds, seed_length, callback) {
  if (typeof seed_length === "function")
    callback = seed_length, seed_length = void 0;
  if (typeof rounds === "function")
    callback = rounds, rounds = void 0;
  if (typeof rounds === "undefined")
    rounds = GENSALT_DEFAULT_LOG2_ROUNDS;
  else if (typeof rounds !== "number")
    throw Error("illegal arguments: " + typeof rounds);
  function _async(callback2) {
    nextTick(function() {
      try {
        callback2(null, genSaltSync(rounds));
      } catch (err) {
        callback2(err);
      }
    });
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve2, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(res);
      });
    });
}
function hashSync(password, salt) {
  if (typeof salt === "undefined")
    salt = GENSALT_DEFAULT_LOG2_ROUNDS;
  if (typeof salt === "number")
    salt = genSaltSync(salt);
  if (typeof password !== "string" || typeof salt !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof salt);
  return _hash(password, salt);
}
function hash(password, salt, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password === "string" && typeof salt === "number")
      genSalt(salt, function(err, salt2) {
        _hash(password, salt2, callback2, progressCallback);
      });
    else if (typeof password === "string" && typeof salt === "string")
      _hash(password, salt, callback2, progressCallback);
    else
      nextTick(
        callback2.bind(
          this,
          Error("Illegal arguments: " + typeof password + ", " + typeof salt)
        )
      );
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve2, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(res);
      });
    });
}
function safeStringCompare(known, unknown2) {
  var diff = known.length ^ unknown2.length;
  for (var i = 0; i < known.length; ++i) {
    diff |= known.charCodeAt(i) ^ unknown2.charCodeAt(i);
  }
  return diff === 0;
}
function compareSync(password, hash4) {
  if (typeof password !== "string" || typeof hash4 !== "string")
    throw Error("Illegal arguments: " + typeof password + ", " + typeof hash4);
  if (hash4.length !== 60)
    return false;
  return safeStringCompare(
    hashSync(password, hash4.substring(0, hash4.length - 31)),
    hash4
  );
}
function compare(password, hashValue, callback, progressCallback) {
  function _async(callback2) {
    if (typeof password !== "string" || typeof hashValue !== "string") {
      nextTick(
        callback2.bind(
          this,
          Error(
            "Illegal arguments: " + typeof password + ", " + typeof hashValue
          )
        )
      );
      return;
    }
    if (hashValue.length !== 60) {
      nextTick(callback2.bind(this, null, false));
      return;
    }
    hash(
      password,
      hashValue.substring(0, 29),
      function(err, comp) {
        if (err)
          callback2(err);
        else
          callback2(null, safeStringCompare(comp, hashValue));
      },
      progressCallback
    );
  }
  if (callback) {
    if (typeof callback !== "function")
      throw Error("Illegal callback: " + typeof callback);
    _async(callback);
  } else
    return new Promise(function(resolve2, reject) {
      _async(function(err, res) {
        if (err) {
          reject(err);
          return;
        }
        resolve2(res);
      });
    });
}
function getRounds(hash4) {
  if (typeof hash4 !== "string")
    throw Error("Illegal arguments: " + typeof hash4);
  return parseInt(hash4.split("$")[2], 10);
}
function getSalt(hash4) {
  if (typeof hash4 !== "string")
    throw Error("Illegal arguments: " + typeof hash4);
  if (hash4.length !== 60)
    throw Error("Illegal hash length: " + hash4.length + " != 60");
  return hash4.substring(0, 29);
}
function truncates(password) {
  if (typeof password !== "string")
    throw Error("Illegal arguments: " + typeof password);
  return utf8Length(password) > 72;
}
function utf8Length(string4) {
  var len = 0, c2 = 0;
  for (var i = 0; i < string4.length; ++i) {
    c2 = string4.charCodeAt(i);
    if (c2 < 128)
      len += 1;
    else if (c2 < 2048)
      len += 2;
    else if ((c2 & 64512) === 55296 && (string4.charCodeAt(i + 1) & 64512) === 56320) {
      ++i;
      len += 4;
    } else
      len += 3;
  }
  return len;
}
function utf8Array(string4) {
  var offset = 0, c1, c2;
  var buffer = new Array(utf8Length(string4));
  for (var i = 0, k = string4.length; i < k; ++i) {
    c1 = string4.charCodeAt(i);
    if (c1 < 128) {
      buffer[offset++] = c1;
    } else if (c1 < 2048) {
      buffer[offset++] = c1 >> 6 | 192;
      buffer[offset++] = c1 & 63 | 128;
    } else if ((c1 & 64512) === 55296 && ((c2 = string4.charCodeAt(i + 1)) & 64512) === 56320) {
      c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
      ++i;
      buffer[offset++] = c1 >> 18 | 240;
      buffer[offset++] = c1 >> 12 & 63 | 128;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    } else {
      buffer[offset++] = c1 >> 12 | 224;
      buffer[offset++] = c1 >> 6 & 63 | 128;
      buffer[offset++] = c1 & 63 | 128;
    }
  }
  return buffer;
}
function base64_encode(b, len) {
  var off = 0, rs = [], c1, c2;
  if (len <= 0 || len > b.length)
    throw Error("Illegal len: " + len);
  while (off < len) {
    c1 = b[off++] & 255;
    rs.push(BASE64_CODE[c1 >> 2 & 63]);
    c1 = (c1 & 3) << 4;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 4 & 15;
    rs.push(BASE64_CODE[c1 & 63]);
    c1 = (c2 & 15) << 2;
    if (off >= len) {
      rs.push(BASE64_CODE[c1 & 63]);
      break;
    }
    c2 = b[off++] & 255;
    c1 |= c2 >> 6 & 3;
    rs.push(BASE64_CODE[c1 & 63]);
    rs.push(BASE64_CODE[c2 & 63]);
  }
  return rs.join("");
}
function base64_decode(s3, len) {
  var off = 0, slen = s3.length, olen = 0, rs = [], c1, c2, c3, c4, o2, code;
  if (len <= 0)
    throw Error("Illegal len: " + len);
  while (off < slen - 1 && olen < len) {
    code = s3.charCodeAt(off++);
    c1 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    code = s3.charCodeAt(off++);
    c2 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c1 == -1 || c2 == -1)
      break;
    o2 = c1 << 2 >>> 0;
    o2 |= (c2 & 48) >> 4;
    rs.push(String.fromCharCode(o2));
    if (++olen >= len || off >= slen)
      break;
    code = s3.charCodeAt(off++);
    c3 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    if (c3 == -1)
      break;
    o2 = (c2 & 15) << 4 >>> 0;
    o2 |= (c3 & 60) >> 2;
    rs.push(String.fromCharCode(o2));
    if (++olen >= len || off >= slen)
      break;
    code = s3.charCodeAt(off++);
    c4 = code < BASE64_INDEX.length ? BASE64_INDEX[code] : -1;
    o2 = (c3 & 3) << 6 >>> 0;
    o2 |= c4;
    rs.push(String.fromCharCode(o2));
    ++olen;
  }
  var res = [];
  for (off = 0; off < olen; off++)
    res.push(rs[off].charCodeAt(0));
  return res;
}
function _encipher(lr, off, P, S) {
  var n2, l = lr[off], r3 = lr[off + 1];
  l ^= P[0];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[1];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[2];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[3];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[4];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[5];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[6];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[7];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[8];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[9];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[10];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[11];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[12];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[13];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[14];
  n2 = S[l >>> 24];
  n2 += S[256 | l >> 16 & 255];
  n2 ^= S[512 | l >> 8 & 255];
  n2 += S[768 | l & 255];
  r3 ^= n2 ^ P[15];
  n2 = S[r3 >>> 24];
  n2 += S[256 | r3 >> 16 & 255];
  n2 ^= S[512 | r3 >> 8 & 255];
  n2 += S[768 | r3 & 255];
  l ^= n2 ^ P[16];
  lr[off] = r3 ^ P[BLOWFISH_NUM_ROUNDS + 1];
  lr[off + 1] = l;
  return lr;
}
function _streamtoword(data, offp) {
  for (var i = 0, word = 0; i < 4; ++i)
    word = word << 8 | data[offp] & 255, offp = (offp + 1) % data.length;
  return { key: word, offp };
}
function _key(key2, P, S) {
  var offset = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0; i < plen; i++)
    sw = _streamtoword(key2, offset), offset = sw.offp, P[i] = P[i] ^ sw.key;
  for (i = 0; i < plen; i += 2)
    lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0; i < slen; i += 2)
    lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _ekskey(data, key2, P, S) {
  var offp = 0, lr = [0, 0], plen = P.length, slen = S.length, sw;
  for (var i = 0; i < plen; i++)
    sw = _streamtoword(key2, offp), offp = sw.offp, P[i] = P[i] ^ sw.key;
  offp = 0;
  for (i = 0; i < plen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), P[i] = lr[0], P[i + 1] = lr[1];
  for (i = 0; i < slen; i += 2)
    sw = _streamtoword(data, offp), offp = sw.offp, lr[0] ^= sw.key, sw = _streamtoword(data, offp), offp = sw.offp, lr[1] ^= sw.key, lr = _encipher(lr, 0, P, S), S[i] = lr[0], S[i + 1] = lr[1];
}
function _crypt(b, salt, rounds, callback, progressCallback) {
  var cdata = C_ORIG.slice(), clen = cdata.length, err;
  if (rounds < 4 || rounds > 31) {
    err = Error("Illegal number of rounds (4-31): " + rounds);
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.length !== BCRYPT_SALT_LEN) {
    err = Error(
      "Illegal salt length: " + salt.length + " != " + BCRYPT_SALT_LEN
    );
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  rounds = 1 << rounds >>> 0;
  var P, S, i = 0, j;
  if (typeof Int32Array === "function") {
    P = new Int32Array(P_ORIG);
    S = new Int32Array(S_ORIG);
  } else {
    P = P_ORIG.slice();
    S = S_ORIG.slice();
  }
  _ekskey(salt, b, P, S);
  function next() {
    if (progressCallback)
      progressCallback(i / rounds);
    if (i < rounds) {
      var start = Date.now();
      for (; i < rounds; ) {
        i = i + 1;
        _key(b, P, S);
        _key(salt, P, S);
        if (Date.now() - start > MAX_EXECUTION_TIME)
          break;
      }
    } else {
      for (i = 0; i < 64; i++)
        for (j = 0; j < clen >> 1; j++)
          _encipher(cdata, j << 1, P, S);
      var ret = [];
      for (i = 0; i < clen; i++)
        ret.push((cdata[i] >> 24 & 255) >>> 0), ret.push((cdata[i] >> 16 & 255) >>> 0), ret.push((cdata[i] >> 8 & 255) >>> 0), ret.push((cdata[i] & 255) >>> 0);
      if (callback) {
        callback(null, ret);
        return;
      } else
        return ret;
    }
    if (callback)
      nextTick(next);
  }
  if (typeof callback !== "undefined") {
    next();
  } else {
    var res;
    while (true)
      if (typeof (res = next()) !== "undefined")
        return res || [];
  }
}
function _hash(password, salt, callback, progressCallback) {
  var err;
  if (typeof password !== "string" || typeof salt !== "string") {
    err = Error("Invalid string / salt: Not a string");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var minor, offset;
  if (salt.charAt(0) !== "$" || salt.charAt(1) !== "2") {
    err = Error("Invalid salt version: " + salt.substring(0, 2));
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  if (salt.charAt(2) === "$")
    minor = String.fromCharCode(0), offset = 3;
  else {
    minor = salt.charAt(2);
    if (minor !== "a" && minor !== "b" && minor !== "y" || salt.charAt(3) !== "$") {
      err = Error("Invalid salt revision: " + salt.substring(2, 4));
      if (callback) {
        nextTick(callback.bind(this, err));
        return;
      } else
        throw err;
    }
    offset = 4;
  }
  if (salt.charAt(offset + 2) > "$") {
    err = Error("Missing salt rounds");
    if (callback) {
      nextTick(callback.bind(this, err));
      return;
    } else
      throw err;
  }
  var r1 = parseInt(salt.substring(offset, offset + 1), 10) * 10, r22 = parseInt(salt.substring(offset + 1, offset + 2), 10), rounds = r1 + r22, real_salt = salt.substring(offset + 3, offset + 25);
  password += minor >= "a" ? "\0" : "";
  var passwordb = utf8Array(password), saltb = base64_decode(real_salt, BCRYPT_SALT_LEN);
  function finish(bytes) {
    var res = [];
    res.push("$2");
    if (minor >= "a")
      res.push(minor);
    res.push("$");
    if (rounds < 10)
      res.push("0");
    res.push(rounds.toString());
    res.push("$");
    res.push(base64_encode(saltb, saltb.length));
    res.push(base64_encode(bytes, C_ORIG.length * 4 - 1));
    return res.join("");
  }
  if (typeof callback == "undefined")
    return finish(_crypt(passwordb, saltb, rounds));
  else {
    _crypt(
      passwordb,
      saltb,
      rounds,
      function(err2, bytes) {
        if (err2)
          callback(err2, null);
        else
          callback(null, finish(bytes));
      },
      progressCallback
    );
  }
}
function encodeBase64(bytes, length) {
  return base64_encode(bytes, length);
}
function decodeBase64(string4, length) {
  return base64_decode(string4, length);
}
var import_crypto, randomFallback, nextTick, BASE64_CODE, BASE64_INDEX, BCRYPT_SALT_LEN, GENSALT_DEFAULT_LOG2_ROUNDS, BLOWFISH_NUM_ROUNDS, MAX_EXECUTION_TIME, P_ORIG, S_ORIG, C_ORIG, bcryptjs_default;
var init_bcryptjs = __esm({
  "node_modules/bcryptjs/index.js"() {
    import_crypto = __toESM(require_crypto(), 1);
    randomFallback = null;
    nextTick = typeof setImmediate === "function" ? setImmediate : typeof scheduler === "object" && typeof scheduler.postTask === "function" ? scheduler.postTask.bind(scheduler) : setTimeout;
    BASE64_CODE = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split("");
    BASE64_INDEX = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ];
    BCRYPT_SALT_LEN = 16;
    GENSALT_DEFAULT_LOG2_ROUNDS = 10;
    BLOWFISH_NUM_ROUNDS = 16;
    MAX_EXECUTION_TIME = 100;
    P_ORIG = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ];
    S_ORIG = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      290971e4,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409e3,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ];
    C_ORIG = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    bcryptjs_default = {
      setRandomFallback,
      genSaltSync,
      genSalt,
      hashSync,
      hash,
      compareSync,
      compare,
      getRounds,
      getSalt,
      truncates,
      encodeBase64,
      decodeBase64
    };
  }
});

// node_modules/@prisma/client/scripts/default-index.js
var require_default_index = __commonJS({
  "node_modules/@prisma/client/scripts/default-index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
    var default_index_exports = {};
    __export2(default_index_exports, {
      Prisma: () => Prisma,
      PrismaClient: () => PrismaClient,
      default: () => default_index_default
    });
    module.exports = __toCommonJS(default_index_exports);
    var prisma = {
      enginesVersion: "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba"
    };
    var version2 = "7.1.0";
    var clientVersion = version2;
    var PrismaClient = class {
      constructor() {
        throw new Error('@prisma/client did not initialize yet. Please run "prisma generate" and try to import it again.');
      }
    };
    function defineExtension(ext) {
      if (typeof ext === "function") {
        return ext;
      }
      return (client) => client.$extends(ext);
    }
    function getExtensionContext(that) {
      return that;
    }
    var Prisma = {
      defineExtension,
      getExtensionContext,
      prismaVersion: { client: clientVersion, engine: prisma.enginesVersion }
    };
    var default_index_default = { Prisma };
  }
});

// node_modules/@prisma/extension-accelerate/dist/esm/semver.js
function compareSemVer(a, b) {
  const [major1 = 0, minor1 = 0, patch1 = 0] = a.split(".").map(Number);
  const [major2 = 0, minor2 = 0, patch2 = 0] = b.split(".").map(Number);
  const major = major2 - major1;
  const minor = minor2 - minor1;
  const patch = patch2 - patch1;
  return major || minor || patch;
}
var init_semver = __esm({
  "node_modules/@prisma/extension-accelerate/dist/esm/semver.js"() {
  }
});

// node_modules/@prisma/extension-accelerate/dist/esm/user-agent.js
function getUserAgent() {
  const prismaVersion = import_default_index.default.Prisma.prismaVersion;
  const parts = [
    getRuntimeSegment(),
    `PrismaEngine/${prismaVersion.engine}`,
    `PrismaClient/${prismaVersion.client}`
  ];
  return parts.join(" ");
}
function getRuntimeSegment() {
  if (typeof navigator !== "undefined") {
    return navigator.userAgent;
  } else if (typeof process !== "undefined" && typeof process.versions !== "undefined") {
    return `Node/${process.versions.node} (${process.platform}; ${process.arch})`;
  } else if ("EdgeRuntime" in globalThis) {
    return `Vercel-Edge-Runtime`;
  } else {
    return `UnknownRuntime`;
  }
}
var import_default_index;
var init_user_agent = __esm({
  "node_modules/@prisma/extension-accelerate/dist/esm/user-agent.js"() {
    import_default_index = __toESM(require_default_index(), 1);
  }
});

// node_modules/@prisma/extension-accelerate/dist/esm/extension.js
function makeWithCacheHeaders(fetcher) {
  const userAgent = getUserAgent();
  let machineHint = void 0;
  return async (params) => {
    const { args } = params;
    const { cacheStrategy, __accelerateInfo = false, ...rest } = args;
    let info = null;
    const { __internalParams, query } = params;
    __internalParams.customDataProxyFetch = () => {
      return async (url2, options2) => {
        const cacheControl = new Array();
        if (typeof cacheStrategy?.ttl === "number") {
          cacheControl.push(`max-age=${cacheStrategy.ttl}`);
        }
        if (typeof cacheStrategy?.swr === "number") {
          cacheControl.push(`stale-while-revalidate=${cacheStrategy.swr}`);
        }
        const cacheTags = cacheStrategy?.tags?.join(",") ?? "";
        options2.headers = {
          ...options2.headers,
          "cache-control": cacheControl.length > 0 ? cacheControl.join(",") : `no-cache`,
          "user-agent": userAgent,
          ...cacheTags.length > 0 ? { "accelerate-cache-tags": cacheTags } : {}
        };
        if (machineHint) {
          options2.headers["accelerate-query-engine-jwt"] = machineHint;
        }
        try {
          const response = await fetcher(url2, options2);
          info = {
            cacheStatus: response.headers.get("accelerate-cache-status"),
            lastModified: new Date(response.headers.get("last-modified") ?? ""),
            region: response.headers.get("cf-ray")?.split("-")[1] ?? "unspecified",
            requestId: response.headers.get("cf-ray") ?? "unspecified",
            signature: response.headers.get("accelerate-signature") ?? "unspecified"
          };
          machineHint = response.headers.get("accelerate-query-engine-jwt") ?? void 0;
          return response;
        } catch (e3) {
          throw new Error(FETCH_FAILURE_MESSAGE);
        }
      };
    };
    if (__accelerateInfo) {
      const data = await query(rest, __internalParams);
      return { data, info };
    } else {
      return query(rest, __internalParams);
    }
  };
}
function makeAccelerateExtension(fetcher) {
  const enableCtxParent = compareSemVer("5.1.0", import_default_index2.default.Prisma.prismaVersion.client) >= 0;
  return import_default_index2.default.Prisma.defineExtension((client) => {
    const withCacheHeaders = makeWithCacheHeaders(fetcher);
    const apiKeyPromise = client._engine.start().then(() => client._engine.apiKey?.());
    async function invalidate(input) {
      const apiKey = await apiKeyPromise;
      if (!apiKey) {
        return { requestId: "unspecified" };
      }
      let response;
      try {
        response = await fetcher(`https://accelerate.prisma-data.net/invalidate`, {
          method: "POST",
          headers: {
            authorization: `Bearer ${apiKey}`,
            "content-type": "application/json"
          },
          body: JSON.stringify(input)
        });
      } catch (e3) {
        throw new Error(FETCH_FAILURE_MESSAGE);
      }
      if (!response?.ok) {
        const body = await response.text();
        throw new Error(`Failed to invalidate Accelerate cache. Response was ${response.status} ${response.statusText}. ${body}`);
      }
      void response.body?.cancel();
      return {
        requestId: response.headers.get("cf-ray") ?? "unspecified"
      };
    }
    const xclient = client.$extends({
      name: EXTENSION_NAME,
      query: {
        $allModels: {
          // also apply withCacheHeaders to mutations for machine hint benefit
          $allOperations: withCacheHeaders
        }
      }
    });
    return xclient.$extends({
      name: EXTENSION_NAME,
      client: {
        $accelerate: {
          /**
           * Initiates an invalidation request for the specified cache tag values.
           *
           * A tag may only contain alphanumeric characters and underscores.
           * Each tag may contain a maximum of 64 characters.
           * A maximum of 5 tags may be invalidated per call.
           */
          invalidate: (input) => invalidate(input),
          /**
           * Initiates an invalidation request of all cache entries for this
           * environment.
           */
          invalidateAll: () => invalidate({ tags: "all" })
        }
      },
      model: {
        $allModels: {
          // TODO: these functions are repetitive. Is there a type we can use to generic this?
          // TODO: can we define these in a map that ensures query and model overrides stay in sync/
          aggregate(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.aggregate(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.aggregate({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          },
          count(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.count(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.count({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          },
          findFirst(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.findFirst(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.findFirst({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          },
          findFirstOrThrow(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.findFirstOrThrow(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.findFirstOrThrow({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          },
          findMany(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.findMany(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.findMany({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          },
          findUnique(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.findUnique(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.findUnique({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          },
          findUniqueOrThrow(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.findUniqueOrThrow(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.findUniqueOrThrow({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          },
          groupBy(args) {
            const ctx = import_default_index2.default.Prisma.getExtensionContext(this);
            const model = enableCtxParent ? ctx.$parent[ctx.$name] : xclient[ctx.name];
            const prismaPromise = model.groupBy(args);
            return Object.assign(prismaPromise, {
              withAccelerateInfo() {
                return model.groupBy({
                  ...args,
                  __accelerateInfo: true
                });
              }
            });
          }
        }
      }
    });
  });
}
var import_default_index2, EXTENSION_NAME, FETCH_FAILURE_MESSAGE;
var init_extension = __esm({
  "node_modules/@prisma/extension-accelerate/dist/esm/extension.js"() {
    import_default_index2 = __toESM(require_default_index(), 1);
    init_semver();
    init_user_agent();
    EXTENSION_NAME = "@prisma/extension-accelerate";
    FETCH_FAILURE_MESSAGE = "Unable to connect to the Accelerate API. This may be due to a network or DNS issue. Please check your connection and the Accelerate connection string. For details, visit https://www.prisma.io/docs/accelerate/troubleshoot.";
  }
});

// node_modules/@prisma/extension-accelerate/dist/esm/entry.fetch.js
var entry_fetch_exports = {};
__export(entry_fetch_exports, {
  FETCH_FAILURE_MESSAGE: () => FETCH_FAILURE_MESSAGE,
  makeAccelerateExtension: () => makeAccelerateExtension,
  withAccelerate: () => withAccelerate
});
function withAccelerate() {
  return makeAccelerateExtension(globalThis.fetch);
}
var init_entry_fetch = __esm({
  "node_modules/@prisma/extension-accelerate/dist/esm/entry.fetch.js"() {
    init_extension();
    init_extension();
  }
});

// node_modules/@prisma/client-runtime-utils/dist/index.js
var require_dist = __commonJS({
  "node_modules/@prisma/client-runtime-utils/dist/index.js"(exports, module) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key2 of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key2) && key2 !== except)
            __defProp2(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc2(from, key2)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var index_exports = {};
    __export2(index_exports, {
      AnyNull: () => AnyNull2,
      AnyNullClass: () => AnyNullClass,
      DbNull: () => DbNull2,
      DbNullClass: () => DbNullClass,
      Decimal: () => Decimal2,
      JsonNull: () => JsonNull2,
      JsonNullClass: () => JsonNullClass,
      NullTypes: () => NullTypes2,
      ObjectEnumValue: () => ObjectEnumValue2,
      PrismaClientInitializationError: () => PrismaClientInitializationError2,
      PrismaClientKnownRequestError: () => PrismaClientKnownRequestError2,
      PrismaClientRustError: () => PrismaClientRustError,
      PrismaClientRustPanicError: () => PrismaClientRustPanicError2,
      PrismaClientUnknownRequestError: () => PrismaClientUnknownRequestError2,
      PrismaClientValidationError: () => PrismaClientValidationError2,
      Sql: () => Sql2,
      empty: () => empty2,
      hasBatchIndex: () => hasBatchIndex,
      isAnyNull: () => isAnyNull2,
      isDbNull: () => isDbNull2,
      isJsonNull: () => isJsonNull2,
      join: () => join2,
      raw: () => raw2,
      sql: () => sql
    });
    module.exports = __toCommonJS(index_exports);
    function hasBatchIndex(value) {
      return typeof value["batchRequestIdx"] === "number";
    }
    function setClassName(classObject, name) {
      Object.defineProperty(classObject, "name", {
        value: name,
        configurable: true
      });
    }
    var PrismaClientInitializationError2 = class _PrismaClientInitializationError extends Error {
      clientVersion;
      errorCode;
      retryable;
      constructor(message, clientVersion, errorCode) {
        super(message);
        this.name = "PrismaClientInitializationError";
        this.clientVersion = clientVersion;
        this.errorCode = errorCode;
        Error.captureStackTrace(_PrismaClientInitializationError);
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientInitializationError";
      }
    };
    setClassName(PrismaClientInitializationError2, "PrismaClientInitializationError");
    var PrismaClientKnownRequestError2 = class extends Error {
      code;
      meta;
      clientVersion;
      batchRequestIdx;
      constructor(message, { code, clientVersion, meta: meta3, batchRequestIdx }) {
        super(message);
        this.name = "PrismaClientKnownRequestError";
        this.code = code;
        this.clientVersion = clientVersion;
        this.meta = meta3;
        Object.defineProperty(this, "batchRequestIdx", {
          value: batchRequestIdx,
          enumerable: false,
          writable: true
        });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientKnownRequestError";
      }
    };
    setClassName(PrismaClientKnownRequestError2, "PrismaClientKnownRequestError");
    function getBacktrace(log3) {
      if (log3.fields?.message) {
        let str = log3.fields?.message;
        if (log3.fields?.file) {
          str += ` in ${log3.fields.file}`;
          if (log3.fields?.line) {
            str += `:${log3.fields.line}`;
          }
          if (log3.fields?.column) {
            str += `:${log3.fields.column}`;
          }
        }
        if (log3.fields?.reason) {
          str += `
${log3.fields?.reason}`;
        }
        return str;
      }
      return "Unknown error";
    }
    function isPanic(err) {
      return err.fields?.message === "PANIC";
    }
    var PrismaClientRustError = class extends Error {
      clientVersion;
      _isPanic;
      constructor({ clientVersion, error: error47 }) {
        const backtrace = getBacktrace(error47);
        super(backtrace ?? "Unknown error");
        this._isPanic = isPanic(error47);
        this.clientVersion = clientVersion;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustError";
      }
      isPanic() {
        return this._isPanic;
      }
    };
    setClassName(PrismaClientRustError, "PrismaClientRustError");
    var PrismaClientRustPanicError2 = class extends Error {
      clientVersion;
      constructor(message, clientVersion) {
        super(message);
        this.name = "PrismaClientRustPanicError";
        this.clientVersion = clientVersion;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientRustPanicError";
      }
    };
    setClassName(PrismaClientRustPanicError2, "PrismaClientRustPanicError");
    var PrismaClientUnknownRequestError2 = class extends Error {
      clientVersion;
      batchRequestIdx;
      constructor(message, { clientVersion, batchRequestIdx }) {
        super(message);
        this.name = "PrismaClientUnknownRequestError";
        this.clientVersion = clientVersion;
        Object.defineProperty(this, "batchRequestIdx", {
          value: batchRequestIdx,
          writable: true,
          enumerable: false
        });
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientUnknownRequestError";
      }
    };
    setClassName(PrismaClientUnknownRequestError2, "PrismaClientUnknownRequestError");
    var PrismaClientValidationError2 = class extends Error {
      name = "PrismaClientValidationError";
      clientVersion;
      constructor(message, { clientVersion }) {
        super(message);
        this.clientVersion = clientVersion;
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientValidationError";
      }
    };
    setClassName(PrismaClientValidationError2, "PrismaClientValidationError");
    var secret = Symbol();
    var representations = /* @__PURE__ */ new WeakMap();
    var ObjectEnumValue2 = class {
      constructor(arg) {
        if (arg === secret) {
          representations.set(this, `Prisma.${this._getName()}`);
        } else {
          representations.set(this, `new Prisma.${this._getNamespace()}.${this._getName()}()`);
        }
      }
      _getName() {
        return this.constructor.name;
      }
      toString() {
        return representations.get(this);
      }
    };
    function setClassName2(classObject, name) {
      Object.defineProperty(classObject, "name", {
        value: name,
        configurable: true
      });
    }
    var NullTypesEnumValue = class extends ObjectEnumValue2 {
      _getNamespace() {
        return "NullTypes";
      }
    };
    var DbNullClass = class extends NullTypesEnumValue {
      // Phantom private property to prevent structural type equality
      // eslint-disable-next-line no-unused-private-class-members
      #_brand_DbNull;
    };
    setClassName2(DbNullClass, "DbNull");
    var JsonNullClass = class extends NullTypesEnumValue {
      // Phantom private property to prevent structural type equality
      // eslint-disable-next-line no-unused-private-class-members
      #_brand_JsonNull;
    };
    setClassName2(JsonNullClass, "JsonNull");
    var AnyNullClass = class extends NullTypesEnumValue {
      // Phantom private property to prevent structural type equality
      // eslint-disable-next-line no-unused-private-class-members
      #_brand_AnyNull;
    };
    setClassName2(AnyNullClass, "AnyNull");
    var NullTypes2 = {
      DbNull: DbNullClass,
      JsonNull: JsonNullClass,
      AnyNull: AnyNullClass
    };
    var DbNull2 = new DbNullClass(secret);
    var JsonNull2 = new JsonNullClass(secret);
    var AnyNull2 = new AnyNullClass(secret);
    function isDbNull2(value) {
      return value === DbNull2;
    }
    function isJsonNull2(value) {
      return value === JsonNull2;
    }
    function isAnyNull2(value) {
      return value === AnyNull2;
    }
    var EXP_LIMIT = 9e15;
    var MAX_DIGITS = 1e9;
    var NUMERALS = "0123456789abcdef";
    var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
    var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
    var DEFAULTS = {
      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed at run-time using the `Decimal.config` method.
      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,
      // 1 to MAX_DIGITS
      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,
      // 0 to 8
      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,
      // 0 to 9
      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,
      // 0 to -EXP_LIMIT
      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos: 21,
      // 0 to EXP_LIMIT
      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,
      // -1 to -EXP_LIMIT
      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,
      // 1 to EXP_LIMIT
      // Whether to use cryptographically-secure random number generation, if available.
      crypto: false
      // true/false
    };
    var inexact;
    var quadrant;
    var external = true;
    var decimalError = "[DecimalError] ";
    var invalidArgument = decimalError + "Invalid argument: ";
    var precisionLimitExceeded = decimalError + "Precision limit exceeded";
    var cryptoUnavailable = decimalError + "crypto unavailable";
    var tag = "[object Decimal]";
    var mathfloor = Math.floor;
    var mathpow = Math.pow;
    var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
    var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
    var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
    var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
    var BASE = 1e7;
    var LOG_BASE = 7;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var LN10_PRECISION = LN10.length - 1;
    var PI_PRECISION = PI.length - 1;
    var P = { toStringTag: tag };
    P.absoluteValue = P.abs = function() {
      var x = new this.constructor(this);
      if (x.s < 0)
        x.s = 1;
      return finalise(x);
    };
    P.ceil = function() {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };
    P.clampedTo = P.clamp = function(min2, max2) {
      var k, x = this, Ctor = x.constructor;
      min2 = new Ctor(min2);
      max2 = new Ctor(max2);
      if (!min2.s || !max2.s)
        return new Ctor(NaN);
      if (min2.gt(max2))
        throw Error(invalidArgument + max2);
      k = x.cmp(min2);
      return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
    };
    P.comparedTo = P.cmp = function(y) {
      var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }
      if (!xd[0] || !yd[0])
        return xd[0] ? xs : yd[0] ? -ys : 0;
      if (xs !== ys)
        return xs;
      if (x.e !== y.e)
        return x.e > y.e ^ xs < 0 ? 1 : -1;
      xdL = xd.length;
      ydL = yd.length;
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i])
          return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };
    P.cosine = P.cos = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.d)
        return new Ctor(NaN);
      if (!x.d[0])
        return new Ctor(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };
    P.cubeRoot = P.cbrt = function() {
      var e3, m, n2, r3, rep, s3, sd, t2, t3, t3plusx, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      external = false;
      s3 = x.s * mathpow(x.s * x, 1 / 3);
      if (!s3 || Math.abs(s3) == 1 / 0) {
        n2 = digitsToString(x.d);
        e3 = x.e;
        if (s3 = (e3 - n2.length + 1) % 3)
          n2 += s3 == 1 || s3 == -2 ? "0" : "00";
        s3 = mathpow(n2, 1 / 3);
        e3 = mathfloor((e3 + 1) / 3) - (e3 % 3 == (e3 < 0 ? -1 : 2));
        if (s3 == 1 / 0) {
          n2 = "5e" + e3;
        } else {
          n2 = s3.toExponential();
          n2 = n2.slice(0, n2.indexOf("e") + 1) + e3;
        }
        r3 = new Ctor(n2);
        r3.s = x.s;
      } else {
        r3 = new Ctor(s3.toString());
      }
      sd = (e3 = Ctor.precision) + 3;
      for (; ; ) {
        t2 = r3;
        t3 = t2.times(t2).times(t2);
        t3plusx = t3.plus(x);
        r3 = divide(t3plusx.plus(x).times(t2), t3plusx.plus(t3), sd + 2, 1);
        if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r3.d)).slice(0, sd)) {
          n2 = n2.slice(sd - 3, sd + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              finalise(t2, e3 + 1, 0);
              if (t2.times(t2).times(t2).eq(x)) {
                r3 = t2;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              finalise(r3, e3 + 1, 1);
              m = !r3.times(r3).times(r3).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r3, e3, Ctor.rounding, m);
    };
    P.decimalPlaces = P.dp = function() {
      var w, d = this.d, n2 = NaN;
      if (d) {
        w = d.length - 1;
        n2 = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
        w = d[w];
        if (w)
          for (; w % 10 == 0; w /= 10)
            n2--;
        if (n2 < 0)
          n2 = 0;
      }
      return n2;
    };
    P.dividedBy = P.div = function(y) {
      return divide(this, new this.constructor(y));
    };
    P.dividedToIntegerBy = P.divToInt = function(y) {
      var x = this, Ctor = x.constructor;
      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };
    P.equals = P.eq = function(y) {
      return this.cmp(y) === 0;
    };
    P.floor = function() {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };
    P.greaterThan = P.gt = function(y) {
      return this.cmp(y) > 0;
    };
    P.greaterThanOrEqualTo = P.gte = function(y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };
    P.hyperbolicCosine = P.cosh = function() {
      var k, n2, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
      if (!x.isFinite())
        return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero())
        return one;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        n2 = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n2 = "2.3283064365386962890625e-10";
      }
      x = taylorSeries(Ctor, 1, x.times(n2), new Ctor(1), true);
      var cosh2_x, i = k, d8 = new Ctor(8);
      for (; i--; ) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }
      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.hyperbolicSine = P.sinh = function() {
      var k, pr, rm, len, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;
      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);
        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(x, pr, rm, true);
    };
    P.hyperbolicTangent = P.tanh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(x.s);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;
      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };
    P.inverseCosine = P.acos = function() {
      var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
      if (k !== -1) {
        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
      }
      if (x.isZero())
        return getPi(Ctor, pr + 4, rm).times(0.5);
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(2);
    };
    P.inverseHyperbolicCosine = P.acosh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (x.lte(1))
        return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).minus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicSine = P.asinh = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite() || x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;
      x = x.times(x).plus(1).sqrt().plus(x);
      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.ln();
    };
    P.inverseHyperbolicTangent = P.atanh = function() {
      var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.e >= 0)
        return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();
      if (Math.max(xsd, pr) < 2 * -x.e - 1)
        return finalise(new Ctor(x), pr, rm, true);
      Ctor.precision = wpr = xsd - x.e;
      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
      Ctor.precision = pr + 4;
      Ctor.rounding = 1;
      x = x.ln();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(0.5);
    };
    P.inverseSine = P.asin = function() {
      var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
      if (x.isZero())
        return new Ctor(x);
      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (k !== -1) {
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }
        return new Ctor(NaN);
      }
      Ctor.precision = pr + 6;
      Ctor.rounding = 1;
      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return x.times(2);
    };
    P.inverseTangent = P.atan = function() {
      var i, j, k, n2, px, t2, r3, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
      if (!x.isFinite()) {
        if (!x.s)
          return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r3 = getPi(Ctor, pr + 4, rm).times(0.5);
          r3.s = x.s;
          return r3;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r3 = getPi(Ctor, pr + 4, rm).times(0.25);
        r3.s = x.s;
        return r3;
      }
      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;
      k = Math.min(28, wpr / LOG_BASE + 2 | 0);
      for (i = k; i; --i)
        x = x.div(x.times(x).plus(1).sqrt().plus(1));
      external = false;
      j = Math.ceil(wpr / LOG_BASE);
      n2 = 1;
      x2 = x.times(x);
      r3 = new Ctor(x);
      px = x;
      for (; i !== -1; ) {
        px = px.times(x2);
        t2 = r3.minus(px.div(n2 += 2));
        px = px.times(x2);
        r3 = t2.plus(px.div(n2 += 2));
        if (r3.d[j] !== void 0)
          for (i = j; r3.d[i] === t2.d[i] && i--; )
            ;
      }
      if (k)
        r3 = r3.times(2 << k - 1);
      external = true;
      return finalise(r3, Ctor.precision = pr, Ctor.rounding = rm, true);
    };
    P.isFinite = function() {
      return !!this.d;
    };
    P.isInteger = P.isInt = function() {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };
    P.isNaN = function() {
      return !this.s;
    };
    P.isNegative = P.isNeg = function() {
      return this.s < 0;
    };
    P.isPositive = P.isPos = function() {
      return this.s > 0;
    };
    P.isZero = function() {
      return !!this.d && this.d[0] === 0;
    };
    P.lessThan = P.lt = function(y) {
      return this.cmp(y) < 0;
    };
    P.lessThanOrEqualTo = P.lte = function(y) {
      return this.cmp(y) < 1;
    };
    P.logarithm = P.log = function(base2) {
      var isBase10, d, denominator, k, inf, num, sd, r3, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
      if (base2 == null) {
        base2 = new Ctor(10);
        isBase10 = true;
      } else {
        base2 = new Ctor(base2);
        d = base2.d;
        if (base2.s < 0 || !d || !d[0] || base2.eq(1))
          return new Ctor(NaN);
        isBase10 = base2.eq(10);
      }
      d = arg.d;
      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
      }
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0; )
            k /= 10;
          inf = k !== 1;
        }
      }
      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
      r3 = divide(num, denominator, sd, 1);
      if (checkRoundingDigits(r3.d, k = pr, rm)) {
        do {
          sd += 10;
          num = naturalLogarithm(arg, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base2, sd);
          r3 = divide(num, denominator, sd, 1);
          if (!inf) {
            if (+digitsToString(r3.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r3 = finalise(r3, pr + 1, 0);
            }
            break;
          }
        } while (checkRoundingDigits(r3.d, k += 10, rm));
      }
      external = true;
      return finalise(r3, pr, rm);
    };
    P.minus = P.sub = function(y) {
      var d, e3, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s)
          y = new Ctor(NaN);
        else if (x.d)
          y.s = -y.s;
        else
          y = new Ctor(y.d || x.s !== y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (yd[0])
          y.s = -y.s;
        else if (xd[0])
          y = new Ctor(x);
        else
          return new Ctor(rm === 3 ? -0 : 0);
        return external ? finalise(y, pr, rm) : y;
      }
      e3 = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);
      xd = xd.slice();
      k = xe - e3;
      if (k) {
        xLTy = k < 0;
        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e3 = xe;
          len = xd.length;
        }
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
        if (k > i) {
          k = i;
          d.length = 1;
        }
        d.reverse();
        for (i = k; i--; )
          d.push(0);
        d.reverse();
      } else {
        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy)
          len = i;
        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }
        k = 0;
      }
      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }
      len = xd.length;
      for (i = yd.length - len; i > 0; --i)
        xd[len++] = 0;
      for (i = yd.length; i > k; ) {
        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0; )
            xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }
        xd[i] -= yd[i];
      }
      for (; xd[--len] === 0; )
        xd.pop();
      for (; xd[0] === 0; xd.shift())
        --e3;
      if (!xd[0])
        return new Ctor(rm === 3 ? -0 : 0);
      y.d = xd;
      y.e = getBase10Exponent(xd, e3);
      return external ? finalise(y, pr, rm) : y;
    };
    P.modulo = P.mod = function(y) {
      var q, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.s || y.d && !y.d[0])
        return new Ctor(NaN);
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }
      external = false;
      if (Ctor.modulo == 9) {
        q = divide(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide(x, y, 0, Ctor.modulo, 1);
      }
      q = q.times(y);
      external = true;
      return x.minus(q);
    };
    P.naturalExponential = P.exp = function() {
      return naturalExponential(this);
    };
    P.naturalLogarithm = P.ln = function() {
      return naturalLogarithm(this);
    };
    P.negated = P.neg = function() {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };
    P.plus = P.add = function(y) {
      var carry, d, e3, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
      y = new Ctor(y);
      if (!x.d || !y.d) {
        if (!x.s || !y.s)
          y = new Ctor(NaN);
        else if (!x.d)
          y = new Ctor(y.d || x.s === y.s ? x : NaN);
        return y;
      }
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }
      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (!xd[0] || !yd[0]) {
        if (!yd[0])
          y = new Ctor(x);
        return external ? finalise(y, pr, rm) : y;
      }
      k = mathfloor(x.e / LOG_BASE);
      e3 = mathfloor(y.e / LOG_BASE);
      xd = xd.slice();
      i = k - e3;
      if (i) {
        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e3 = k;
          len = xd.length;
        }
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;
        if (i > len) {
          i = len;
          d.length = 1;
        }
        d.reverse();
        for (; i--; )
          d.push(0);
        d.reverse();
      }
      len = xd.length;
      i = yd.length;
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }
      for (carry = 0; i; ) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }
      if (carry) {
        xd.unshift(carry);
        ++e3;
      }
      for (len = xd.length; xd[--len] == 0; )
        xd.pop();
      y.d = xd;
      y.e = getBase10Exponent(xd, e3);
      return external ? finalise(y, pr, rm) : y;
    };
    P.precision = P.sd = function(z) {
      var k, x = this;
      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
        throw Error(invalidArgument + z);
      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k)
          k = x.e + 1;
      } else {
        k = NaN;
      }
      return k;
    };
    P.round = function() {
      var x = this, Ctor = x.constructor;
      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };
    P.sine = P.sin = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;
      x = sine(Ctor, toLessThanHalfPi(Ctor, x));
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };
    P.squareRoot = P.sqrt = function() {
      var m, n2, sd, r3, rep, t2, x = this, d = x.d, e3 = x.e, s3 = x.s, Ctor = x.constructor;
      if (s3 !== 1 || !d || !d[0]) {
        return new Ctor(!s3 || s3 < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }
      external = false;
      s3 = Math.sqrt(+x);
      if (s3 == 0 || s3 == 1 / 0) {
        n2 = digitsToString(d);
        if ((n2.length + e3) % 2 == 0)
          n2 += "0";
        s3 = Math.sqrt(n2);
        e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
        if (s3 == 1 / 0) {
          n2 = "5e" + e3;
        } else {
          n2 = s3.toExponential();
          n2 = n2.slice(0, n2.indexOf("e") + 1) + e3;
        }
        r3 = new Ctor(n2);
      } else {
        r3 = new Ctor(s3.toString());
      }
      sd = (e3 = Ctor.precision) + 3;
      for (; ; ) {
        t2 = r3;
        r3 = t2.plus(divide(x, t2, sd + 2, 1)).times(0.5);
        if (digitsToString(t2.d).slice(0, sd) === (n2 = digitsToString(r3.d)).slice(0, sd)) {
          n2 = n2.slice(sd - 3, sd + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              finalise(t2, e3 + 1, 0);
              if (t2.times(t2).eq(x)) {
                r3 = t2;
                break;
              }
            }
            sd += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              finalise(r3, e3 + 1, 1);
              m = !r3.times(r3).eq(x);
            }
            break;
          }
        }
      }
      external = true;
      return finalise(r3, e3, Ctor.rounding, m);
    };
    P.tangent = P.tan = function() {
      var pr, rm, x = this, Ctor = x.constructor;
      if (!x.isFinite())
        return new Ctor(NaN);
      if (x.isZero())
        return new Ctor(x);
      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;
      x = x.sin();
      x.s = 1;
      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
      Ctor.precision = pr;
      Ctor.rounding = rm;
      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };
    P.times = P.mul = function(y) {
      var carry, e3, i, k, r3, rL, t2, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
      y.s *= x.s;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
      }
      e3 = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;
      if (xdL < ydL) {
        r3 = xd;
        xd = yd;
        yd = r3;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }
      r3 = [];
      rL = xdL + ydL;
      for (i = rL; i--; )
        r3.push(0);
      for (i = ydL; --i >= 0; ) {
        carry = 0;
        for (k = xdL + i; k > i; ) {
          t2 = r3[k] + yd[i] * xd[k - i - 1] + carry;
          r3[k--] = t2 % BASE | 0;
          carry = t2 / BASE | 0;
        }
        r3[k] = (r3[k] + carry) % BASE | 0;
      }
      for (; !r3[--rL]; )
        r3.pop();
      if (carry)
        ++e3;
      else
        r3.shift();
      y.d = r3;
      y.e = getBase10Exponent(r3, e3);
      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };
    P.toBinary = function(sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };
    P.toDecimalPlaces = P.toDP = function(dp, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (dp === void 0)
        return x;
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      return finalise(x, dp + x.e + 1, rm);
    };
    P.toExponential = function(dp, rm) {
      var str, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFixed = function(dp, rm) {
      var str, y, x = this, Ctor = x.constructor;
      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toFraction = function(maxD) {
      var d, d0, d1, d2, e3, k, n2, n0, n1, pr, q, r3, x = this, xd = x.d, Ctor = x.constructor;
      if (!xd)
        return new Ctor(x);
      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);
      d = new Ctor(d1);
      e3 = d.e = getPrecision(xd) - x.e - 1;
      k = e3 % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
      if (maxD == null) {
        maxD = e3 > 0 ? d : n1;
      } else {
        n2 = new Ctor(maxD);
        if (!n2.isInt() || n2.lt(n1))
          throw Error(invalidArgument + n2);
        maxD = n2.gt(d) ? e3 > 0 ? d : n1 : n2;
      }
      external = false;
      n2 = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e3 = xd.length * LOG_BASE * 2;
      for (; ; ) {
        q = divide(n2, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1)
          break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n2.minus(q.times(d2));
        n2 = d2;
      }
      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;
      r3 = divide(n1, d1, e3, 1).minus(x).abs().cmp(divide(n0, d0, e3, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
      Ctor.precision = pr;
      external = true;
      return r3;
    };
    P.toHexadecimal = P.toHex = function(sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };
    P.toNearest = function(y, rm) {
      var x = this, Ctor = x.constructor;
      x = new Ctor(x);
      if (y == null) {
        if (!x.d)
          return x;
        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }
        if (!x.d)
          return y.s ? x : y;
        if (!y.d) {
          if (y.s)
            y.s = x.s;
          return y;
        }
      }
      if (y.d[0]) {
        external = false;
        x = divide(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);
      } else {
        y.s = x.s;
        x = y;
      }
      return x;
    };
    P.toNumber = function() {
      return +this;
    };
    P.toOctal = function(sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };
    P.toPower = P.pow = function(y) {
      var e3, k, pr, r3, rm, s3, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
      if (!x.d || !y.d || !x.d[0] || !y.d[0])
        return new Ctor(mathpow(+x, yn));
      x = new Ctor(x);
      if (x.eq(1))
        return x;
      pr = Ctor.precision;
      rm = Ctor.rounding;
      if (y.eq(1))
        return finalise(x, pr, rm);
      e3 = mathfloor(y.e / LOG_BASE);
      if (e3 >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r3 = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r3) : finalise(r3, pr, rm);
      }
      s3 = x.s;
      if (s3 < 0) {
        if (e3 < y.d.length - 1)
          return new Ctor(NaN);
        if ((y.d[e3] & 1) == 0)
          s3 = 1;
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s3;
          return x;
        }
      }
      k = mathpow(+x, yn);
      e3 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
      if (e3 > Ctor.maxE + 1 || e3 < Ctor.minE - 1)
        return new Ctor(e3 > 0 ? s3 / 0 : 0);
      external = false;
      Ctor.rounding = x.s = 1;
      k = Math.min(12, (e3 + "").length);
      r3 = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
      if (r3.d) {
        r3 = finalise(r3, pr + 5, 1);
        if (checkRoundingDigits(r3.d, pr, rm)) {
          e3 = pr + 10;
          r3 = finalise(naturalExponential(y.times(naturalLogarithm(x, e3 + k)), e3), e3 + 5, 1);
          if (+digitsToString(r3.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r3 = finalise(r3, pr + 1, 0);
          }
        }
      }
      r3.s = s3;
      external = true;
      Ctor.rounding = rm;
      return finalise(r3, pr, rm);
    };
    P.toPrecision = function(sd, rm) {
      var str, x = this, Ctor = x.constructor;
      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.toSignificantDigits = P.toSD = function(sd, rm) {
      var x = this, Ctor = x.constructor;
      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
      }
      return finalise(new Ctor(x), sd, rm);
    };
    P.toString = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() && !x.isZero() ? "-" + str : str;
    };
    P.truncated = P.trunc = function() {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };
    P.valueOf = P.toJSON = function() {
      var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      return x.isNeg() ? "-" + str : str;
    };
    function digitsToString(d) {
      var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
      if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + "";
          k = LOG_BASE - ws.length;
          if (k)
            str += getZeroString(k);
          str += ws;
        }
        w = d[i];
        ws = w + "";
        k = LOG_BASE - ws.length;
        if (k)
          str += getZeroString(k);
      } else if (w === 0) {
        return "0";
      }
      for (; w % 10 === 0; )
        w /= 10;
      return str + w;
    }
    function checkInt32(i, min2, max2) {
      if (i !== ~~i || i < min2 || i > max2) {
        throw Error(invalidArgument + i);
      }
    }
    function checkRoundingDigits(d, i, rm, repeating) {
      var di, k, r3, rd;
      for (k = d[0]; k >= 10; k /= 10)
        --i;
      if (--i < 0) {
        i += LOG_BASE;
        di = 0;
      } else {
        di = Math.ceil((i + 1) / LOG_BASE);
        i %= LOG_BASE;
      }
      k = mathpow(10, LOG_BASE - i);
      rd = d[di] % k | 0;
      if (repeating == null) {
        if (i < 3) {
          if (i == 0)
            rd = rd / 100 | 0;
          else if (i == 1)
            rd = rd / 10 | 0;
          r3 = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
        } else {
          r3 = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
        }
      } else {
        if (i < 4) {
          if (i == 0)
            rd = rd / 1e3 | 0;
          else if (i == 1)
            rd = rd / 100 | 0;
          else if (i == 2)
            rd = rd / 10 | 0;
          r3 = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
        } else {
          r3 = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
        }
      }
      return r3;
    }
    function convertBase(str, baseIn, baseOut) {
      var j, arr = [0], arrL, i = 0, strL = str.length;
      for (; i < strL; ) {
        for (arrL = arr.length; arrL--; )
          arr[arrL] *= baseIn;
        arr[0] += NUMERALS.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] === void 0)
              arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    function cosine(Ctor, x) {
      var k, len, y;
      if (x.isZero())
        return x;
      len = x.d.length;
      if (len < 32) {
        k = Math.ceil(len / 3);
        y = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        y = "2.3283064365386962890625e-10";
      }
      Ctor.precision += k;
      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
      for (var i = k; i--; ) {
        var cos2x = x.times(x);
        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
      }
      Ctor.precision -= k;
      return x;
    }
    var divide = /* @__PURE__ */ function() {
      function multiplyInteger(x, k, base2) {
        var temp, carry = 0, i = x.length;
        for (x = x.slice(); i--; ) {
          temp = x[i] * k + carry;
          x[i] = temp % base2 | 0;
          carry = temp / base2 | 0;
        }
        if (carry)
          x.unshift(carry);
        return x;
      }
      function compare2(a, b, aL, bL) {
        var i, r3;
        if (aL != bL) {
          r3 = aL > bL ? 1 : -1;
        } else {
          for (i = r3 = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r3 = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }
        return r3;
      }
      function subtract(a, b, aL, base2) {
        var i = 0;
        for (; aL--; ) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base2 + a[aL] - b[aL];
        }
        for (; !a[0] && a.length > 1; )
          a.shift();
      }
      return function(x, y, pr, rm, dp, base2) {
        var cmp, e3, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t2, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(
            // Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
              // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
              xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
            )
          );
        }
        if (base2) {
          logBase = 1;
          e3 = x.e - y.e;
        } else {
          base2 = BASE;
          logBase = LOG_BASE;
          e3 = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }
        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign2);
        qd = q.d = [];
        for (i = 0; yd[i] == (xd[i] || 0); i++)
          ;
        if (yd[i] > (xd[i] || 0))
          e3--;
        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }
        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {
          sd = sd / logBase + 2 | 0;
          i = 0;
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;
            for (; (i < xL || k) && sd--; i++) {
              t2 = k * base2 + (xd[i] || 0);
              qd[i] = t2 / yd | 0;
              k = t2 % yd | 0;
            }
            more = k || i < xL;
          } else {
            k = base2 / (yd[0] + 1) | 0;
            if (k > 1) {
              yd = multiplyInteger(yd, k, base2);
              xd = multiplyInteger(xd, k, base2);
              yL = yd.length;
              xL = xd.length;
            }
            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; )
              rem[remL++] = 0;
            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];
            if (yd[1] >= base2 / 2)
              ++yd0;
            do {
              k = 0;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base2 + (rem[1] || 0);
                k = rem0 / yd0 | 0;
                if (k > 1) {
                  if (k >= base2)
                    k = base2 - 1;
                  prod = multiplyInteger(yd, k, base2);
                  prodL = prod.length;
                  remL = rem.length;
                  cmp = compare2(prod, rem, prodL, remL);
                  if (cmp == 1) {
                    k--;
                    subtract(prod, yL < prodL ? yz : yd, prodL, base2);
                  }
                } else {
                  if (k == 0)
                    cmp = k = 1;
                  prod = yd.slice();
                }
                prodL = prod.length;
                if (prodL < remL)
                  prod.unshift(0);
                subtract(rem, prod, remL, base2);
                if (cmp == -1) {
                  remL = rem.length;
                  cmp = compare2(yd, rem, yL, remL);
                  if (cmp < 1) {
                    k++;
                    subtract(rem, yL < remL ? yz : yd, remL, base2);
                  }
                }
                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }
              qd[i++] = k;
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] !== void 0) && sd--);
            more = rem[0] !== void 0;
          }
          if (!qd[0])
            qd.shift();
        }
        if (logBase == 1) {
          q.e = e3;
          inexact = more;
        } else {
          for (i = 1, k = qd[0]; k >= 10; k /= 10)
            i++;
          q.e = i + e3 * logBase - 1;
          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }
        return q;
      };
    }();
    function finalise(x, sd, rm, isTruncated) {
      var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
      out:
        if (sd != null) {
          xd = x.d;
          if (!xd)
            return x;
          for (digits = 1, k = xd[0]; k >= 10; k /= 10)
            digits++;
          i = sd - digits;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {
                for (; k++ <= xdi; )
                  xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];
              for (digits = 1; k >= 10; k /= 10)
                digits++;
              i %= LOG_BASE;
              j = i - LOG_BASE + digits;
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }
          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {
              sd -= x.e + 1;
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              xd[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }
          if (roundUp) {
            for (; ; ) {
              if (xdi == 0) {
                for (i = 1, j = xd[0]; j >= 10; j /= 10)
                  i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10)
                  k++;
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE)
                    xd[0] = 1;
                }
                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE)
                  break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }
          for (i = xd.length; xd[--i] === 0; )
            xd.pop();
        }
      if (external) {
        if (x.e > Ctor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < Ctor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
      return x;
    }
    function finiteToString(x, isExp, sd) {
      if (!x.isFinite())
        return nonFiniteToString(x);
      var k, e3 = x.e, str = digitsToString(x.d), len = str.length;
      if (isExp) {
        if (sd && (k = sd - len) > 0) {
          str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
          str = str.charAt(0) + "." + str.slice(1);
        }
        str = str + (x.e < 0 ? "e" : "e+") + x.e;
      } else if (e3 < 0) {
        str = "0." + getZeroString(-e3 - 1) + str;
        if (sd && (k = sd - len) > 0)
          str += getZeroString(k);
      } else if (e3 >= len) {
        str += getZeroString(e3 + 1 - len);
        if (sd && (k = sd - e3 - 1) > 0)
          str = str + "." + getZeroString(k);
      } else {
        if ((k = e3 + 1) < len)
          str = str.slice(0, k) + "." + str.slice(k);
        if (sd && (k = sd - len) > 0) {
          if (e3 + 1 === len)
            str += ".";
          str += getZeroString(k);
        }
      }
      return str;
    }
    function getBase10Exponent(digits, e3) {
      var w = digits[0];
      for (e3 *= LOG_BASE; w >= 10; w /= 10)
        e3++;
      return e3;
    }
    function getLn10(Ctor, sd, pr) {
      if (sd > LN10_PRECISION) {
        external = true;
        if (pr)
          Ctor.precision = pr;
        throw Error(precisionLimitExceeded);
      }
      return finalise(new Ctor(LN10), sd, 1, true);
    }
    function getPi(Ctor, sd, rm) {
      if (sd > PI_PRECISION)
        throw Error(precisionLimitExceeded);
      return finalise(new Ctor(PI), sd, rm, true);
    }
    function getPrecision(digits) {
      var w = digits.length - 1, len = w * LOG_BASE + 1;
      w = digits[w];
      if (w) {
        for (; w % 10 == 0; w /= 10)
          len--;
        for (w = digits[0]; w >= 10; w /= 10)
          len++;
      }
      return len;
    }
    function getZeroString(k) {
      var zs = "";
      for (; k--; )
        zs += "0";
      return zs;
    }
    function intPow(Ctor, x, n2, pr) {
      var isTruncated, r3 = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
      external = false;
      for (; ; ) {
        if (n2 % 2) {
          r3 = r3.times(x);
          if (truncate(r3.d, k))
            isTruncated = true;
        }
        n2 = mathfloor(n2 / 2);
        if (n2 === 0) {
          n2 = r3.d.length - 1;
          if (isTruncated && r3.d[n2] === 0)
            ++r3.d[n2];
          break;
        }
        x = x.times(x);
        truncate(x.d, k);
      }
      external = true;
      return r3;
    }
    function isOdd(n2) {
      return n2.d[n2.d.length - 1] & 1;
    }
    function maxOrMin(Ctor, args, n2) {
      var k, y, x = new Ctor(args[0]), i = 0;
      for (; ++i < args.length; ) {
        y = new Ctor(args[i]);
        if (!y.s) {
          x = y;
          break;
        }
        k = x.cmp(y);
        if (k === n2 || k === 0 && x.s === n2) {
          x = y;
        }
      }
      return x;
    }
    function naturalExponential(x, sd) {
      var denominator, guard, j, pow2, sum2, t2, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (!x.d || !x.d[0] || x.e > 17) {
        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      t2 = new Ctor(0.03125);
      while (x.e > -2) {
        x = x.times(t2);
        k += 5;
      }
      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow2 = sum2 = new Ctor(1);
      Ctor.precision = wpr;
      for (; ; ) {
        pow2 = finalise(pow2.times(x), wpr, 1);
        denominator = denominator.times(++i);
        t2 = sum2.plus(divide(pow2, denominator, wpr, 1));
        if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
          j = k;
          while (j--)
            sum2 = finalise(sum2.times(sum2), wpr, 1);
          if (sd == null) {
            if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += 10;
              denominator = pow2 = t2 = new Ctor(1);
              i = 0;
              rep++;
            } else {
              return finalise(sum2, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum2;
          }
        }
        sum2 = t2;
      }
    }
    function naturalLogarithm(y, sd) {
      var c2, c0, denominator, e3, numerator, rep, sum2, t2, wpr, x1, x2, n2 = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
      }
      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }
      Ctor.precision = wpr += guard;
      c2 = digitsToString(xd);
      c0 = c2.charAt(0);
      if (Math.abs(e3 = x.e) < 15e14) {
        while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
          x = x.times(y);
          c2 = digitsToString(x.d);
          c0 = c2.charAt(0);
          n2++;
        }
        e3 = x.e;
        if (c0 > 1) {
          x = new Ctor("0." + c2);
          e3++;
        } else {
          x = new Ctor(c0 + "." + c2.slice(1));
        }
      } else {
        t2 = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
        x = naturalLogarithm(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
        Ctor.precision = pr;
        return sd == null ? finalise(x, pr, rm, external = true) : x;
      }
      x1 = x;
      sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
      x2 = finalise(x.times(x), wpr, 1);
      denominator = 3;
      for (; ; ) {
        numerator = finalise(numerator.times(x2), wpr, 1);
        t2 = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
        if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
          sum2 = sum2.times(2);
          if (e3 !== 0)
            sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
          sum2 = divide(sum2, new Ctor(n2), wpr, 1);
          if (sd == null) {
            if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += guard;
              t2 = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
              x2 = finalise(x.times(x), wpr, 1);
              denominator = rep = 1;
            } else {
              return finalise(sum2, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum2;
          }
        }
        sum2 = t2;
        denominator += 2;
      }
    }
    function nonFiniteToString(x) {
      return String(x.s * x.s / 0);
    }
    function parseDecimal(x, str) {
      var e3, i, len;
      if ((e3 = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i = str.search(/e/i)) > 0) {
        if (e3 < 0)
          e3 = i;
        e3 += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e3 < 0) {
        e3 = str.length;
      }
      for (i = 0; str.charCodeAt(i) === 48; i++)
        ;
      for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
        ;
      str = str.slice(i, len);
      if (str) {
        len -= i;
        x.e = e3 = e3 - i - 1;
        x.d = [];
        i = (e3 + 1) % LOG_BASE;
        if (e3 < 0)
          i += LOG_BASE;
        if (i < len) {
          if (i)
            x.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len; )
            x.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }
        for (; i--; )
          str += "0";
        x.d.push(+str);
        if (external) {
          if (x.e > x.constructor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < x.constructor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
      } else {
        x.e = 0;
        x.d = [0];
      }
      return x;
    }
    function parseOther(x, str) {
      var base2, Ctor, divisor, i, isFloat, len, p, xd, xe;
      if (str.indexOf("_") > -1) {
        str = str.replace(/(\d)_(?=\d)/g, "$1");
        if (isDecimal.test(str))
          return parseDecimal(x, str);
      } else if (str === "Infinity" || str === "NaN") {
        if (!+str)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return x;
      }
      if (isHex.test(str)) {
        base2 = 16;
        str = str.toLowerCase();
      } else if (isBinary.test(str)) {
        base2 = 2;
      } else if (isOctal.test(str)) {
        base2 = 8;
      } else {
        throw Error(invalidArgument + str);
      }
      i = str.search(/p/i);
      if (i > 0) {
        p = +str.slice(i + 1);
        str = str.substring(2, i);
      } else {
        str = str.slice(2);
      }
      i = str.indexOf(".");
      isFloat = i >= 0;
      Ctor = x.constructor;
      if (isFloat) {
        str = str.replace(".", "");
        len = str.length;
        i = len - i;
        divisor = intPow(Ctor, new Ctor(base2), i, i * 2);
      }
      xd = convertBase(str, base2, BASE);
      xe = xd.length - 1;
      for (i = xe; xd[i] === 0; --i)
        xd.pop();
      if (i < 0)
        return new Ctor(x.s * 0);
      x.e = getBase10Exponent(xd, xe);
      x.d = xd;
      external = false;
      if (isFloat)
        x = divide(x, divisor, len * 4);
      if (p)
        x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal2.pow(2, p));
      external = true;
      return x;
    }
    function sine(Ctor, x) {
      var k, len = x.d.length;
      if (len < 3) {
        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
      }
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x);
      var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sin2_x = x.times(x);
        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
      }
      return x;
    }
    function taylorSeries(Ctor, n2, x, y, isHyperbolic) {
      var j, t2, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
      external = false;
      x2 = x.times(x);
      u = new Ctor(y);
      for (; ; ) {
        t2 = divide(u.times(x2), new Ctor(n2++ * n2++), pr, 1);
        u = isHyperbolic ? y.plus(t2) : y.minus(t2);
        y = divide(t2.times(x2), new Ctor(n2++ * n2++), pr, 1);
        t2 = u.plus(y);
        if (t2.d[k] !== void 0) {
          for (j = k; t2.d[j] === u.d[j] && j--; )
            ;
          if (j == -1)
            break;
        }
        j = u;
        u = y;
        y = t2;
        t2 = j;
        i++;
      }
      external = true;
      t2.d.length = k + 1;
      return t2;
    }
    function tinyPow(b, e3) {
      var n2 = b;
      while (--e3)
        n2 *= b;
      return n2;
    }
    function toLessThanHalfPi(Ctor, x) {
      var t2, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
      x = x.abs();
      if (x.lte(halfPi)) {
        quadrant = isNeg ? 4 : 1;
        return x;
      }
      t2 = x.divToInt(pi);
      if (t2.isZero()) {
        quadrant = isNeg ? 3 : 2;
      } else {
        x = x.minus(t2.times(pi));
        if (x.lte(halfPi)) {
          quadrant = isOdd(t2) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
          return x;
        }
        quadrant = isOdd(t2) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
      }
      return x.minus(pi).abs();
    }
    function toStringBinary(x, baseOut, sd, rm) {
      var base2, e3, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
      if (isExp) {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0)
          rm = Ctor.rounding;
        else
          checkInt32(rm, 0, 8);
      } else {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      }
      if (!x.isFinite()) {
        str = nonFiniteToString(x);
      } else {
        str = finiteToString(x);
        i = str.indexOf(".");
        if (isExp) {
          base2 = 2;
          if (baseOut == 16) {
            sd = sd * 4 - 3;
          } else if (baseOut == 8) {
            sd = sd * 3 - 2;
          }
        } else {
          base2 = baseOut;
        }
        if (i >= 0) {
          str = str.replace(".", "");
          y = new Ctor(1);
          y.e = str.length - i;
          y.d = convertBase(finiteToString(y), 10, base2);
          y.e = y.d.length;
        }
        xd = convertBase(str, 10, base2);
        e3 = len = xd.length;
        for (; xd[--len] == 0; )
          xd.pop();
        if (!xd[0]) {
          str = isExp ? "0p+0" : "0";
        } else {
          if (i < 0) {
            e3--;
          } else {
            x = new Ctor(x);
            x.d = xd;
            x.e = e3;
            x = divide(x, y, sd, rm, 0, base2);
            xd = x.d;
            e3 = x.e;
            roundUp = inexact;
          }
          i = xd[sd];
          k = base2 / 2;
          roundUp = roundUp || xd[sd + 1] !== void 0;
          roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
          xd.length = sd;
          if (roundUp) {
            for (; ++xd[--sd] > base2 - 1; ) {
              xd[sd] = 0;
              if (!sd) {
                ++e3;
                xd.unshift(1);
              }
            }
          }
          for (len = xd.length; !xd[len - 1]; --len)
            ;
          for (i = 0, str = ""; i < len; i++)
            str += NUMERALS.charAt(xd[i]);
          if (isExp) {
            if (len > 1) {
              if (baseOut == 16 || baseOut == 8) {
                i = baseOut == 16 ? 4 : 3;
                for (--len; len % i; len++)
                  str += "0";
                xd = convertBase(str, base2, baseOut);
                for (len = xd.length; !xd[len - 1]; --len)
                  ;
                for (i = 1, str = "1."; i < len; i++)
                  str += NUMERALS.charAt(xd[i]);
              } else {
                str = str.charAt(0) + "." + str.slice(1);
              }
            }
            str = str + (e3 < 0 ? "p" : "p+") + e3;
          } else if (e3 < 0) {
            for (; ++e3; )
              str = "0" + str;
            str = "0." + str;
          } else {
            if (++e3 > len)
              for (e3 -= len; e3--; )
                str += "0";
            else if (e3 < len)
              str = str.slice(0, e3) + "." + str.slice(e3);
          }
        }
        str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
      }
      return x.s < 0 ? "-" + str : str;
    }
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }
    function abs(x) {
      return new this(x).abs();
    }
    function acos(x) {
      return new this(x).acos();
    }
    function acosh(x) {
      return new this(x).acosh();
    }
    function add(x, y) {
      return new this(x).plus(y);
    }
    function asin(x) {
      return new this(x).asin();
    }
    function asinh(x) {
      return new this(x).asinh();
    }
    function atan(x) {
      return new this(x).atan();
    }
    function atanh(x) {
      return new this(x).atanh();
    }
    function atan2(y, x) {
      y = new this(y);
      x = new this(x);
      var r3, pr = this.precision, rm = this.rounding, wpr = pr + 4;
      if (!y.s || !x.s) {
        r3 = new this(NaN);
      } else if (!y.d && !x.d) {
        r3 = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
        r3.s = y.s;
      } else if (!x.d || y.isZero()) {
        r3 = x.s < 0 ? getPi(this, pr, rm) : new this(0);
        r3.s = y.s;
      } else if (!y.d || x.isZero()) {
        r3 = getPi(this, wpr, 1).times(0.5);
        r3.s = y.s;
      } else if (x.s < 0) {
        this.precision = wpr;
        this.rounding = 1;
        r3 = this.atan(divide(y, x, wpr, 1));
        x = getPi(this, wpr, 1);
        this.precision = pr;
        this.rounding = rm;
        r3 = y.s < 0 ? r3.minus(x) : r3.plus(x);
      } else {
        r3 = this.atan(divide(y, x, wpr, 1));
      }
      return r3;
    }
    function cbrt(x) {
      return new this(x).cbrt();
    }
    function ceil(x) {
      return finalise(x = new this(x), x.e + 1, 2);
    }
    function clamp(x, min2, max2) {
      return new this(x).clamp(min2, max2);
    }
    function config2(obj) {
      if (!obj || typeof obj !== "object")
        throw Error(decimalError + "Object expected");
      var i, p, v, useDefaults = obj.defaults === true, ps = [
        "precision",
        1,
        MAX_DIGITS,
        "rounding",
        0,
        8,
        "toExpNeg",
        -EXP_LIMIT,
        0,
        "toExpPos",
        0,
        EXP_LIMIT,
        "maxE",
        0,
        EXP_LIMIT,
        "minE",
        -EXP_LIMIT,
        0,
        "modulo",
        0,
        9
      ];
      for (i = 0; i < ps.length; i += 3) {
        if (p = ps[i], useDefaults)
          this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
            this[p] = v;
          else
            throw Error(invalidArgument + p + ": " + v);
        }
      }
      if (p = "crypto", useDefaults)
        this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (v === true || v === false || v === 0 || v === 1) {
          if (v) {
            if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
              this[p] = true;
            } else {
              throw Error(cryptoUnavailable);
            }
          } else {
            this[p] = false;
          }
        } else {
          throw Error(invalidArgument + p + ": " + v);
        }
      }
      return this;
    }
    function cos(x) {
      return new this(x).cos();
    }
    function cosh(x) {
      return new this(x).cosh();
    }
    function clone2(obj) {
      var i, p, ps;
      function Decimal22(v) {
        var e3, i2, t2, x = this;
        if (!(x instanceof Decimal22))
          return new Decimal22(v);
        x.constructor = Decimal22;
        if (isDecimalInstance(v)) {
          x.s = v.s;
          if (external) {
            if (!v.d || v.e > Decimal22.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (v.e < Decimal22.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = v.e;
              x.d = v.d.slice();
            }
          } else {
            x.e = v.e;
            x.d = v.d ? v.d.slice() : v.d;
          }
          return;
        }
        t2 = typeof v;
        if (t2 === "number") {
          if (v === 0) {
            x.s = 1 / v < 0 ? -1 : 1;
            x.e = 0;
            x.d = [0];
            return;
          }
          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }
          if (v === ~~v && v < 1e7) {
            for (e3 = 0, i2 = v; i2 >= 10; i2 /= 10)
              e3++;
            if (external) {
              if (e3 > Decimal22.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (e3 < Decimal22.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = e3;
                x.d = [v];
              }
            } else {
              x.e = e3;
              x.d = [v];
            }
            return;
          }
          if (v * 0 !== 0) {
            if (!v)
              x.s = NaN;
            x.e = NaN;
            x.d = null;
            return;
          }
          return parseDecimal(x, v.toString());
        }
        if (t2 === "string") {
          if ((i2 = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            if (i2 === 43)
              v = v.slice(1);
            x.s = 1;
          }
          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }
        if (t2 === "bigint") {
          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }
          return parseDecimal(x, v.toString());
        }
        throw Error(invalidArgument + v);
      }
      Decimal22.prototype = P;
      Decimal22.ROUND_UP = 0;
      Decimal22.ROUND_DOWN = 1;
      Decimal22.ROUND_CEIL = 2;
      Decimal22.ROUND_FLOOR = 3;
      Decimal22.ROUND_HALF_UP = 4;
      Decimal22.ROUND_HALF_DOWN = 5;
      Decimal22.ROUND_HALF_EVEN = 6;
      Decimal22.ROUND_HALF_CEIL = 7;
      Decimal22.ROUND_HALF_FLOOR = 8;
      Decimal22.EUCLID = 9;
      Decimal22.config = Decimal22.set = config2;
      Decimal22.clone = clone2;
      Decimal22.isDecimal = isDecimalInstance;
      Decimal22.abs = abs;
      Decimal22.acos = acos;
      Decimal22.acosh = acosh;
      Decimal22.add = add;
      Decimal22.asin = asin;
      Decimal22.asinh = asinh;
      Decimal22.atan = atan;
      Decimal22.atanh = atanh;
      Decimal22.atan2 = atan2;
      Decimal22.cbrt = cbrt;
      Decimal22.ceil = ceil;
      Decimal22.clamp = clamp;
      Decimal22.cos = cos;
      Decimal22.cosh = cosh;
      Decimal22.div = div;
      Decimal22.exp = exp;
      Decimal22.floor = floor;
      Decimal22.hypot = hypot;
      Decimal22.ln = ln;
      Decimal22.log = log2;
      Decimal22.log10 = log10;
      Decimal22.log2 = log22;
      Decimal22.max = max;
      Decimal22.min = min;
      Decimal22.mod = mod;
      Decimal22.mul = mul;
      Decimal22.pow = pow;
      Decimal22.random = random;
      Decimal22.round = round;
      Decimal22.sign = sign;
      Decimal22.sin = sin;
      Decimal22.sinh = sinh;
      Decimal22.sqrt = sqrt;
      Decimal22.sub = sub;
      Decimal22.sum = sum;
      Decimal22.tan = tan;
      Decimal22.tanh = tanh;
      Decimal22.trunc = trunc;
      if (obj === void 0)
        obj = {};
      if (obj) {
        if (obj.defaults !== true) {
          ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
          for (i = 0; i < ps.length; )
            if (!obj.hasOwnProperty(p = ps[i++]))
              obj[p] = this[p];
        }
      }
      Decimal22.config(obj);
      return Decimal22;
    }
    function div(x, y) {
      return new this(x).div(y);
    }
    function exp(x) {
      return new this(x).exp();
    }
    function floor(x) {
      return finalise(x = new this(x), x.e + 1, 3);
    }
    function hypot() {
      var i, n2, t2 = new this(0);
      external = false;
      for (i = 0; i < arguments.length; ) {
        n2 = new this(arguments[i++]);
        if (!n2.d) {
          if (n2.s) {
            external = true;
            return new this(1 / 0);
          }
          t2 = n2;
        } else if (t2.d) {
          t2 = t2.plus(n2.times(n2));
        }
      }
      external = true;
      return t2.sqrt();
    }
    function isDecimalInstance(obj) {
      return obj instanceof Decimal2 || obj && obj.toStringTag === tag || false;
    }
    function ln(x) {
      return new this(x).ln();
    }
    function log2(x, y) {
      return new this(x).log(y);
    }
    function log22(x) {
      return new this(x).log(2);
    }
    function log10(x) {
      return new this(x).log(10);
    }
    function max() {
      return maxOrMin(this, arguments, -1);
    }
    function min() {
      return maxOrMin(this, arguments, 1);
    }
    function mod(x, y) {
      return new this(x).mod(y);
    }
    function mul(x, y) {
      return new this(x).mul(y);
    }
    function pow(x, y) {
      return new this(x).pow(y);
    }
    function random(sd) {
      var d, e3, k, n2, i = 0, r3 = new this(1), rd = [];
      if (sd === void 0)
        sd = this.precision;
      else
        checkInt32(sd, 1, MAX_DIGITS);
      k = Math.ceil(sd / LOG_BASE);
      if (!this.crypto) {
        for (; i < k; )
          rd[i++] = Math.random() * 1e7 | 0;
      } else if (crypto.getRandomValues) {
        d = crypto.getRandomValues(new Uint32Array(k));
        for (; i < k; ) {
          n2 = d[i];
          if (n2 >= 429e7) {
            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
          } else {
            rd[i++] = n2 % 1e7;
          }
        }
      } else if (crypto.randomBytes) {
        d = crypto.randomBytes(k *= 4);
        for (; i < k; ) {
          n2 = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
          if (n2 >= 214e7) {
            crypto.randomBytes(4).copy(d, i);
          } else {
            rd.push(n2 % 1e7);
            i += 4;
          }
        }
        i = k / 4;
      } else {
        throw Error(cryptoUnavailable);
      }
      k = rd[--i];
      sd %= LOG_BASE;
      if (k && sd) {
        n2 = mathpow(10, LOG_BASE - sd);
        rd[i] = (k / n2 | 0) * n2;
      }
      for (; rd[i] === 0; i--)
        rd.pop();
      if (i < 0) {
        e3 = 0;
        rd = [0];
      } else {
        e3 = -1;
        for (; rd[0] === 0; e3 -= LOG_BASE)
          rd.shift();
        for (k = 1, n2 = rd[0]; n2 >= 10; n2 /= 10)
          k++;
        if (k < LOG_BASE)
          e3 -= LOG_BASE - k;
      }
      r3.e = e3;
      r3.d = rd;
      return r3;
    }
    function round(x) {
      return finalise(x = new this(x), x.e + 1, this.rounding);
    }
    function sign(x) {
      x = new this(x);
      return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
    }
    function sin(x) {
      return new this(x).sin();
    }
    function sinh(x) {
      return new this(x).sinh();
    }
    function sqrt(x) {
      return new this(x).sqrt();
    }
    function sub(x, y) {
      return new this(x).sub(y);
    }
    function sum() {
      var i = 0, args = arguments, x = new this(args[i]);
      external = false;
      for (; x.s && ++i < args.length; )
        x = x.plus(args[i]);
      external = true;
      return finalise(x, this.precision, this.rounding);
    }
    function tan(x) {
      return new this(x).tan();
    }
    function tanh(x) {
      return new this(x).tanh();
    }
    function trunc(x) {
      return finalise(x = new this(x), x.e + 1, 1);
    }
    P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
    P[Symbol.toStringTag] = "Decimal";
    var Decimal2 = P.constructor = clone2(DEFAULTS);
    LN10 = new Decimal2(LN10);
    PI = new Decimal2(PI);
    var Sql2 = class _Sql {
      constructor(rawStrings, rawValues) {
        if (rawStrings.length - 1 !== rawValues.length) {
          if (rawStrings.length === 0) {
            throw new TypeError("Expected at least 1 string");
          }
          throw new TypeError(`Expected ${rawStrings.length} strings to have ${rawStrings.length - 1} values`);
        }
        const valuesLength = rawValues.reduce((len, value) => len + (value instanceof _Sql ? value.values.length : 1), 0);
        this.values = new Array(valuesLength);
        this.strings = new Array(valuesLength + 1);
        this.strings[0] = rawStrings[0];
        let i = 0, pos = 0;
        while (i < rawValues.length) {
          const child = rawValues[i++];
          const rawString = rawStrings[i];
          if (child instanceof _Sql) {
            this.strings[pos] += child.strings[0];
            let childIndex = 0;
            while (childIndex < child.values.length) {
              this.values[pos++] = child.values[childIndex++];
              this.strings[pos] = child.strings[childIndex];
            }
            this.strings[pos] += rawString;
          } else {
            this.values[pos++] = child;
            this.strings[pos] = rawString;
          }
        }
      }
      get sql() {
        const len = this.strings.length;
        let i = 1;
        let value = this.strings[0];
        while (i < len)
          value += `?${this.strings[i++]}`;
        return value;
      }
      get statement() {
        const len = this.strings.length;
        let i = 1;
        let value = this.strings[0];
        while (i < len)
          value += `:${i}${this.strings[i++]}`;
        return value;
      }
      get text() {
        const len = this.strings.length;
        let i = 1;
        let value = this.strings[0];
        while (i < len)
          value += `$${i}${this.strings[i++]}`;
        return value;
      }
      inspect() {
        return {
          sql: this.sql,
          statement: this.statement,
          text: this.text,
          values: this.values
        };
      }
    };
    function join2(values, separator = ",", prefix = "", suffix = "") {
      if (values.length === 0) {
        throw new TypeError("Expected `join([])` to be called with an array of multiple elements, but got an empty array");
      }
      return new Sql2([prefix, ...Array(values.length - 1).fill(separator), suffix], values);
    }
    function raw2(value) {
      return new Sql2([value], []);
    }
    var empty2 = raw2("");
    function sql(strings, ...values) {
      return new Sql2(strings, values);
    }
  }
});

// node_modules/.prisma/client/runtime/wasm-compiler-edge.js
var require_wasm_compiler_edge = __commonJS({
  "node_modules/.prisma/client/runtime/wasm-compiler-edge.js"(exports, module) {
    "use strict";
    var nu = Object.create;
    var pr = Object.defineProperty;
    var iu = Object.getOwnPropertyDescriptor;
    var ou = Object.getOwnPropertyNames;
    var su = Object.getPrototypeOf;
    var au = Object.prototype.hasOwnProperty;
    var fe = (e3, t2) => () => (e3 && (t2 = e3(e3 = 0)), t2);
    var oe = (e3, t2) => () => (t2 || e3((t2 = { exports: {} }).exports, t2), t2.exports);
    var Ye = (e3, t2) => {
      for (var r3 in t2)
        pr(e3, r3, { get: t2[r3], enumerable: true });
    };
    var Ui = (e3, t2, r3, n2) => {
      if (t2 && typeof t2 == "object" || typeof t2 == "function")
        for (let i of ou(t2))
          !au.call(e3, i) && i !== r3 && pr(e3, i, { get: () => t2[i], enumerable: !(n2 = iu(t2, i)) || n2.enumerable });
      return e3;
    };
    var Ue = (e3, t2, r3) => (r3 = e3 != null ? nu(su(e3)) : {}, Ui(t2 || !e3 || !e3.__esModule ? pr(r3, "default", { value: e3, enumerable: true }) : r3, e3));
    var $i = (e3) => Ui(pr({}, "__esModule", { value: true }), e3);
    function xn(e3, t2) {
      if (t2 = t2.toLowerCase(), t2 === "utf8" || t2 === "utf-8")
        return new h(pu.encode(e3));
      if (t2 === "base64" || t2 === "base64url")
        return e3 = e3.replace(/-/g, "+").replace(/_/g, "/"), e3 = e3.replace(/[^A-Za-z0-9+/]/g, ""), new h([...atob(e3)].map((r3) => r3.charCodeAt(0)));
      if (t2 === "binary" || t2 === "ascii" || t2 === "latin1" || t2 === "latin-1")
        return new h([...e3].map((r3) => r3.charCodeAt(0)));
      if (t2 === "ucs2" || t2 === "ucs-2" || t2 === "utf16le" || t2 === "utf-16le") {
        let r3 = new h(e3.length * 2), n2 = new DataView(r3.buffer);
        for (let i = 0; i < e3.length; i++)
          n2.setUint16(i * 2, e3.charCodeAt(i), true);
        return r3;
      }
      if (t2 === "hex") {
        let r3 = new h(e3.length / 2);
        for (let n2 = 0, i = 0; i < e3.length; i += 2, n2++)
          r3[n2] = parseInt(e3.slice(i, i + 2), 16);
        return r3;
      }
      Vi(`encoding "${t2}"`);
    }
    function lu(e3) {
      let r3 = Object.getOwnPropertyNames(DataView.prototype).filter((a) => a.startsWith("get") || a.startsWith("set")), n2 = r3.map((a) => a.replace("get", "read").replace("set", "write")), i = (a, d) => function(f = 0) {
        return H(f, "offset"), ie(f, "offset"), W(f, "offset", this.length - 1), new DataView(this.buffer)[r3[a]](f, d);
      }, o2 = (a, d) => function(f, P = 0) {
        let A = r3[a].match(/set(\w+\d+)/)[1].toLowerCase(), S = cu[A];
        return H(P, "offset"), ie(P, "offset"), W(P, "offset", this.length - 1), uu(f, "value", S[0], S[1]), new DataView(this.buffer)[r3[a]](P, f, d), P + parseInt(r3[a].match(/\d+/)[0]) / 8;
      }, s3 = (a) => {
        a.forEach((d) => {
          d.includes("Uint") && (e3[d.replace("Uint", "UInt")] = e3[d]), d.includes("Float64") && (e3[d.replace("Float64", "Double")] = e3[d]), d.includes("Float32") && (e3[d.replace("Float32", "Float")] = e3[d]);
        });
      };
      n2.forEach((a, d) => {
        a.startsWith("read") && (e3[a] = i(d, false), e3[a + "LE"] = i(d, true), e3[a + "BE"] = i(d, false)), a.startsWith("write") && (e3[a] = o2(d, false), e3[a + "LE"] = o2(d, true), e3[a + "BE"] = o2(d, false)), s3([a, a + "LE", a + "BE"]);
      });
    }
    function Vi(e3) {
      throw new Error(`Buffer polyfill does not implement "${e3}"`);
    }
    function mr(e3, t2) {
      if (!(e3 instanceof Uint8Array))
        throw new TypeError(`The "${t2}" argument must be an instance of Buffer or Uint8Array`);
    }
    function W(e3, t2, r3 = fu + 1) {
      if (e3 < 0 || e3 > r3) {
        let n2 = new RangeError(`The value of "${t2}" is out of range. It must be >= 0 && <= ${r3}. Received ${e3}`);
        throw n2.code = "ERR_OUT_OF_RANGE", n2;
      }
    }
    function H(e3, t2) {
      if (typeof e3 != "number") {
        let r3 = new TypeError(`The "${t2}" argument must be of type number. Received type ${typeof e3}.`);
        throw r3.code = "ERR_INVALID_ARG_TYPE", r3;
      }
    }
    function ie(e3, t2) {
      if (!Number.isInteger(e3) || Number.isNaN(e3)) {
        let r3 = new RangeError(`The value of "${t2}" is out of range. It must be an integer. Received ${e3}`);
        throw r3.code = "ERR_OUT_OF_RANGE", r3;
      }
    }
    function uu(e3, t2, r3, n2) {
      if (e3 < r3 || e3 > n2) {
        let i = new RangeError(`The value of "${t2}" is out of range. It must be >= ${r3} and <= ${n2}. Received ${e3}`);
        throw i.code = "ERR_OUT_OF_RANGE", i;
      }
    }
    function qi(e3, t2) {
      if (typeof e3 != "string") {
        let r3 = new TypeError(`The "${t2}" argument must be of type string. Received type ${typeof e3}`);
        throw r3.code = "ERR_INVALID_ARG_TYPE", r3;
      }
    }
    function gu(e3, t2 = "utf8") {
      return h.from(e3, t2);
    }
    var h;
    var cu;
    var pu;
    var mu;
    var du;
    var fu;
    var y;
    var En;
    var l = fe(() => {
      "use strict";
      h = class e3 extends Uint8Array {
        _isBuffer = true;
        get offset() {
          return this.byteOffset;
        }
        static alloc(t2, r3 = 0, n2 = "utf8") {
          return qi(n2, "encoding"), e3.allocUnsafe(t2).fill(r3, n2);
        }
        static allocUnsafe(t2) {
          return e3.from(t2);
        }
        static allocUnsafeSlow(t2) {
          return e3.from(t2);
        }
        static isBuffer(t2) {
          return t2 && !!t2._isBuffer;
        }
        static byteLength(t2, r3 = "utf8") {
          if (typeof t2 == "string")
            return xn(t2, r3).byteLength;
          if (t2 && t2.byteLength)
            return t2.byteLength;
          let n2 = new TypeError('The "string" argument must be of type string or an instance of Buffer or ArrayBuffer.');
          throw n2.code = "ERR_INVALID_ARG_TYPE", n2;
        }
        static isEncoding(t2) {
          return du.includes(t2);
        }
        static compare(t2, r3) {
          mr(t2, "buff1"), mr(r3, "buff2");
          for (let n2 = 0; n2 < t2.length; n2++) {
            if (t2[n2] < r3[n2])
              return -1;
            if (t2[n2] > r3[n2])
              return 1;
          }
          return t2.length === r3.length ? 0 : t2.length > r3.length ? 1 : -1;
        }
        static from(t2, r3 = "utf8") {
          if (t2 && typeof t2 == "object" && t2.type === "Buffer")
            return new e3(t2.data);
          if (typeof t2 == "number")
            return new e3(new Uint8Array(t2));
          if (typeof t2 == "string")
            return xn(t2, r3);
          if (ArrayBuffer.isView(t2)) {
            let { byteOffset: n2, byteLength: i, buffer: o2 } = t2;
            return "map" in t2 && typeof t2.map == "function" ? new e3(t2.map((s3) => s3 % 256), n2, i) : new e3(o2, n2, i);
          }
          if (t2 && typeof t2 == "object" && ("length" in t2 || "byteLength" in t2 || "buffer" in t2))
            return new e3(t2);
          throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
        }
        static concat(t2, r3) {
          if (t2.length === 0)
            return e3.alloc(0);
          let n2 = [].concat(...t2.map((o2) => [...o2])), i = e3.alloc(r3 !== void 0 ? r3 : n2.length);
          return i.set(r3 !== void 0 ? n2.slice(0, r3) : n2), i;
        }
        slice(t2 = 0, r3 = this.length) {
          return this.subarray(t2, r3);
        }
        subarray(t2 = 0, r3 = this.length) {
          return Object.setPrototypeOf(super.subarray(t2, r3), e3.prototype);
        }
        reverse() {
          return super.reverse(), this;
        }
        readIntBE(t2, r3) {
          H(t2, "offset"), ie(t2, "offset"), W(t2, "offset", this.length - 1), H(r3, "byteLength"), ie(r3, "byteLength");
          let n2 = new DataView(this.buffer, t2, r3), i = 0;
          for (let o2 = 0; o2 < r3; o2++)
            i = i * 256 + n2.getUint8(o2);
          return n2.getUint8(0) & 128 && (i -= Math.pow(256, r3)), i;
        }
        readIntLE(t2, r3) {
          H(t2, "offset"), ie(t2, "offset"), W(t2, "offset", this.length - 1), H(r3, "byteLength"), ie(r3, "byteLength");
          let n2 = new DataView(this.buffer, t2, r3), i = 0;
          for (let o2 = 0; o2 < r3; o2++)
            i += n2.getUint8(o2) * Math.pow(256, o2);
          return n2.getUint8(r3 - 1) & 128 && (i -= Math.pow(256, r3)), i;
        }
        readUIntBE(t2, r3) {
          H(t2, "offset"), ie(t2, "offset"), W(t2, "offset", this.length - 1), H(r3, "byteLength"), ie(r3, "byteLength");
          let n2 = new DataView(this.buffer, t2, r3), i = 0;
          for (let o2 = 0; o2 < r3; o2++)
            i = i * 256 + n2.getUint8(o2);
          return i;
        }
        readUintBE(t2, r3) {
          return this.readUIntBE(t2, r3);
        }
        readUIntLE(t2, r3) {
          H(t2, "offset"), ie(t2, "offset"), W(t2, "offset", this.length - 1), H(r3, "byteLength"), ie(r3, "byteLength");
          let n2 = new DataView(this.buffer, t2, r3), i = 0;
          for (let o2 = 0; o2 < r3; o2++)
            i += n2.getUint8(o2) * Math.pow(256, o2);
          return i;
        }
        readUintLE(t2, r3) {
          return this.readUIntLE(t2, r3);
        }
        writeIntBE(t2, r3, n2) {
          return t2 = t2 < 0 ? t2 + Math.pow(256, n2) : t2, this.writeUIntBE(t2, r3, n2);
        }
        writeIntLE(t2, r3, n2) {
          return t2 = t2 < 0 ? t2 + Math.pow(256, n2) : t2, this.writeUIntLE(t2, r3, n2);
        }
        writeUIntBE(t2, r3, n2) {
          H(r3, "offset"), ie(r3, "offset"), W(r3, "offset", this.length - 1), H(n2, "byteLength"), ie(n2, "byteLength");
          let i = new DataView(this.buffer, r3, n2);
          for (let o2 = n2 - 1; o2 >= 0; o2--)
            i.setUint8(o2, t2 & 255), t2 = t2 / 256;
          return r3 + n2;
        }
        writeUintBE(t2, r3, n2) {
          return this.writeUIntBE(t2, r3, n2);
        }
        writeUIntLE(t2, r3, n2) {
          H(r3, "offset"), ie(r3, "offset"), W(r3, "offset", this.length - 1), H(n2, "byteLength"), ie(n2, "byteLength");
          let i = new DataView(this.buffer, r3, n2);
          for (let o2 = 0; o2 < n2; o2++)
            i.setUint8(o2, t2 & 255), t2 = t2 / 256;
          return r3 + n2;
        }
        writeUintLE(t2, r3, n2) {
          return this.writeUIntLE(t2, r3, n2);
        }
        toJSON() {
          return { type: "Buffer", data: Array.from(this) };
        }
        swap16() {
          let t2 = new DataView(this.buffer, this.byteOffset, this.byteLength);
          for (let r3 = 0; r3 < this.length; r3 += 2)
            t2.setUint16(r3, t2.getUint16(r3, true), false);
          return this;
        }
        swap32() {
          let t2 = new DataView(this.buffer, this.byteOffset, this.byteLength);
          for (let r3 = 0; r3 < this.length; r3 += 4)
            t2.setUint32(r3, t2.getUint32(r3, true), false);
          return this;
        }
        swap64() {
          let t2 = new DataView(this.buffer, this.byteOffset, this.byteLength);
          for (let r3 = 0; r3 < this.length; r3 += 8)
            t2.setBigUint64(r3, t2.getBigUint64(r3, true), false);
          return this;
        }
        compare(t2, r3 = 0, n2 = t2.length, i = 0, o2 = this.length) {
          return mr(t2, "target"), H(r3, "targetStart"), H(n2, "targetEnd"), H(i, "sourceStart"), H(o2, "sourceEnd"), W(r3, "targetStart"), W(n2, "targetEnd", t2.length), W(i, "sourceStart"), W(o2, "sourceEnd", this.length), e3.compare(this.slice(i, o2), t2.slice(r3, n2));
        }
        equals(t2) {
          return mr(t2, "otherBuffer"), this.length === t2.length && this.every((r3, n2) => r3 === t2[n2]);
        }
        copy(t2, r3 = 0, n2 = 0, i = this.length) {
          W(r3, "targetStart"), W(n2, "sourceStart", this.length), W(i, "sourceEnd"), r3 >>>= 0, n2 >>>= 0, i >>>= 0;
          let o2 = 0;
          for (; n2 < i && !(this[n2] === void 0 || t2[r3] === void 0); )
            t2[r3] = this[n2], o2++, n2++, r3++;
          return o2;
        }
        write(t2, r3, n2, i = "utf8") {
          let o2 = typeof r3 == "string" ? 0 : r3 ?? 0, s3 = typeof n2 == "string" ? this.length - o2 : n2 ?? this.length - o2;
          return i = typeof r3 == "string" ? r3 : typeof n2 == "string" ? n2 : i, H(o2, "offset"), H(s3, "length"), W(o2, "offset", this.length), W(s3, "length", this.length), (i === "ucs2" || i === "ucs-2" || i === "utf16le" || i === "utf-16le") && (s3 = s3 - s3 % 2), xn(t2, i).copy(this, o2, 0, s3);
        }
        fill(t2 = 0, r3 = 0, n2 = this.length, i = "utf-8") {
          let o2 = typeof r3 == "string" ? 0 : r3, s3 = typeof n2 == "string" ? this.length : n2;
          if (i = typeof r3 == "string" ? r3 : typeof n2 == "string" ? n2 : i, t2 = e3.from(typeof t2 == "number" ? [t2] : t2 ?? [], i), qi(i, "encoding"), W(o2, "offset", this.length), W(s3, "end", this.length), t2.length !== 0)
            for (let a = o2; a < s3; a += t2.length)
              super.set(t2.slice(0, t2.length + a >= this.length ? this.length - a : t2.length), a);
          return this;
        }
        includes(t2, r3 = null, n2 = "utf-8") {
          return this.indexOf(t2, r3, n2) !== -1;
        }
        lastIndexOf(t2, r3 = null, n2 = "utf-8") {
          return this.indexOf(t2, r3, n2, true);
        }
        indexOf(t2, r3 = null, n2 = "utf-8", i = false) {
          let o2 = i ? this.findLastIndex.bind(this) : this.findIndex.bind(this);
          n2 = typeof r3 == "string" ? r3 : n2;
          let s3 = e3.from(typeof t2 == "number" ? [t2] : t2, n2), a = typeof r3 == "string" ? 0 : r3;
          return a = typeof r3 == "number" ? a : null, a = Number.isNaN(a) ? null : a, a ??= i ? this.length : 0, a = a < 0 ? this.length + a : a, s3.length === 0 && i === false ? a >= this.length ? this.length : a : s3.length === 0 && i === true ? (a >= this.length ? this.length : a) || this.length : o2((d, f) => (i ? f <= a : f >= a) && this[f] === s3[0] && s3.every((A, S) => this[f + S] === A));
        }
        toString(t2 = "utf8", r3 = 0, n2 = this.length) {
          if (r3 = r3 < 0 ? 0 : r3, t2 = t2.toString().toLowerCase(), n2 <= 0)
            return "";
          if (t2 === "utf8" || t2 === "utf-8")
            return mu.decode(this.slice(r3, n2));
          if (t2 === "base64" || t2 === "base64url") {
            let i = btoa(this.reduce((o2, s3) => o2 + En(s3), ""));
            return t2 === "base64url" ? i.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "") : i;
          }
          if (t2 === "binary" || t2 === "ascii" || t2 === "latin1" || t2 === "latin-1")
            return this.slice(r3, n2).reduce((i, o2) => i + En(o2 & (t2 === "ascii" ? 127 : 255)), "");
          if (t2 === "ucs2" || t2 === "ucs-2" || t2 === "utf16le" || t2 === "utf-16le") {
            let i = new DataView(this.buffer.slice(r3, n2));
            return Array.from({ length: i.byteLength / 2 }, (o2, s3) => s3 * 2 + 1 < i.byteLength ? En(i.getUint16(s3 * 2, true)) : "").join("");
          }
          if (t2 === "hex")
            return this.slice(r3, n2).reduce((i, o2) => i + o2.toString(16).padStart(2, "0"), "");
          Vi(`encoding "${t2}"`);
        }
        toLocaleString() {
          return this.toString();
        }
        inspect() {
          return `<Buffer ${this.toString("hex").match(/.{1,2}/g).join(" ")}>`;
        }
      };
      cu = { int8: [-128, 127], int16: [-32768, 32767], int32: [-2147483648, 2147483647], uint8: [0, 255], uint16: [0, 65535], uint32: [0, 4294967295], float32: [-1 / 0, 1 / 0], float64: [-1 / 0, 1 / 0], bigint64: [-0x8000000000000000n, 0x7fffffffffffffffn], biguint64: [0n, 0xffffffffffffffffn] }, pu = new TextEncoder(), mu = new TextDecoder(), du = ["utf8", "utf-8", "hex", "base64", "ascii", "binary", "base64url", "ucs2", "ucs-2", "utf16le", "utf-16le", "latin1", "latin-1"], fu = 4294967295;
      lu(h.prototype);
      y = new Proxy(gu, { construct(e3, [t2, r3]) {
        return h.from(t2, r3);
      }, get(e3, t2) {
        return h[t2];
      } }), En = String.fromCodePoint;
    });
    var g;
    var x;
    var u = fe(() => {
      "use strict";
      g = { nextTick: (e3, ...t2) => {
        setTimeout(() => {
          e3(...t2);
        }, 0);
      }, env: {}, version: "", cwd: () => "/", stderr: {}, argv: ["/bin/node"], pid: 1e4 }, { cwd: x } = g;
    });
    var w;
    var c2 = fe(() => {
      "use strict";
      w = globalThis.performance ?? (() => {
        let e3 = Date.now();
        return { now: () => Date.now() - e3 };
      })();
    });
    var b;
    var p = fe(() => {
      "use strict";
      b = () => {
      };
      b.prototype = b;
    });
    function Hi(e3, t2) {
      var r3, n2, i, o2, s3, a, d, f, P = e3.constructor, A = P.precision;
      if (!e3.s || !t2.s)
        return t2.s || (t2 = new P(e3)), B ? _(t2, A) : t2;
      if (d = e3.d, f = t2.d, s3 = e3.e, i = t2.e, d = d.slice(), o2 = s3 - i, o2) {
        for (o2 < 0 ? (n2 = d, o2 = -o2, a = f.length) : (n2 = f, i = s3, a = d.length), s3 = Math.ceil(A / $), a = s3 > a ? s3 + 1 : a + 1, o2 > a && (o2 = a, n2.length = 1), n2.reverse(); o2--; )
          n2.push(0);
        n2.reverse();
      }
      for (a = d.length, o2 = f.length, a - o2 < 0 && (o2 = a, n2 = f, f = d, d = n2), r3 = 0; o2; )
        r3 = (d[--o2] = d[o2] + f[o2] + r3) / G | 0, d[o2] %= G;
      for (r3 && (d.unshift(r3), ++i), a = d.length; d[--a] == 0; )
        d.pop();
      return t2.d = d, t2.e = i, B ? _(t2, A) : t2;
    }
    function ye(e3, t2, r3) {
      if (e3 !== ~~e3 || e3 < t2 || e3 > r3)
        throw Error(qe + e3);
    }
    function ge(e3) {
      var t2, r3, n2, i = e3.length - 1, o2 = "", s3 = e3[0];
      if (i > 0) {
        for (o2 += s3, t2 = 1; t2 < i; t2++)
          n2 = e3[t2] + "", r3 = $ - n2.length, r3 && (o2 += Re(r3)), o2 += n2;
        s3 = e3[t2], n2 = s3 + "", r3 = $ - n2.length, r3 && (o2 += Re(r3));
      } else if (s3 === 0)
        return "0";
      for (; s3 % 10 === 0; )
        s3 /= 10;
      return o2 + s3;
    }
    function Ji(e3, t2) {
      var r3, n2, i, o2, s3, a, d = 0, f = 0, P = e3.constructor, A = P.precision;
      if (J(e3) > 16)
        throw Error(Pn + J(e3));
      if (!e3.s)
        return new P(se);
      for (t2 == null ? (B = false, a = A) : a = t2, s3 = new P(0.03125); e3.abs().gte(0.1); )
        e3 = e3.times(s3), f += 5;
      for (n2 = Math.log($e(2, f)) / Math.LN10 * 2 + 5 | 0, a += n2, r3 = i = o2 = new P(se), P.precision = a; ; ) {
        if (i = _(i.times(e3), a), r3 = r3.times(++d), s3 = o2.plus(Ae(i, r3, a)), ge(s3.d).slice(0, a) === ge(o2.d).slice(0, a)) {
          for (; f--; )
            o2 = _(o2.times(o2), a);
          return P.precision = A, t2 == null ? (B = true, _(o2, A)) : o2;
        }
        o2 = s3;
      }
    }
    function J(e3) {
      for (var t2 = e3.e * $, r3 = e3.d[0]; r3 >= 10; r3 /= 10)
        t2++;
      return t2;
    }
    function Tn(e3, t2, r3) {
      if (t2 > e3.LN10.sd())
        throw B = true, r3 && (e3.precision = r3), Error(le + "LN10 precision limit exceeded");
      return _(new e3(e3.LN10), t2);
    }
    function Re(e3) {
      for (var t2 = ""; e3--; )
        t2 += "0";
      return t2;
    }
    function Ct(e3, t2) {
      var r3, n2, i, o2, s3, a, d, f, P, A = 1, S = 10, C = e3, M = C.d, R = C.constructor, k = R.precision;
      if (C.s < 1)
        throw Error(le + (C.s ? "NaN" : "-Infinity"));
      if (C.eq(se))
        return new R(0);
      if (t2 == null ? (B = false, f = k) : f = t2, C.eq(10))
        return t2 == null && (B = true), Tn(R, f);
      if (f += S, R.precision = f, r3 = ge(M), n2 = r3.charAt(0), o2 = J(C), Math.abs(o2) < 15e14) {
        for (; n2 < 7 && n2 != 1 || n2 == 1 && r3.charAt(1) > 3; )
          C = C.times(e3), r3 = ge(C.d), n2 = r3.charAt(0), A++;
        o2 = J(C), n2 > 1 ? (C = new R("0." + r3), o2++) : C = new R(n2 + "." + r3.slice(1));
      } else
        return d = Tn(R, f + 2, k).times(o2 + ""), C = Ct(new R(n2 + "." + r3.slice(1)), f - S).plus(d), R.precision = k, t2 == null ? (B = true, _(C, k)) : C;
      for (a = s3 = C = Ae(C.minus(se), C.plus(se), f), P = _(C.times(C), f), i = 3; ; ) {
        if (s3 = _(s3.times(P), f), d = a.plus(Ae(s3, new R(i), f)), ge(d.d).slice(0, f) === ge(a.d).slice(0, f))
          return a = a.times(2), o2 !== 0 && (a = a.plus(Tn(R, f + 2, k).times(o2 + ""))), a = Ae(a, new R(A), f), R.precision = k, t2 == null ? (B = true, _(a, k)) : a;
        a = d, i += 2;
      }
    }
    function Bi(e3, t2) {
      var r3, n2, i;
      for ((r3 = t2.indexOf(".")) > -1 && (t2 = t2.replace(".", "")), (n2 = t2.search(/e/i)) > 0 ? (r3 < 0 && (r3 = n2), r3 += +t2.slice(n2 + 1), t2 = t2.substring(0, n2)) : r3 < 0 && (r3 = t2.length), n2 = 0; t2.charCodeAt(n2) === 48; )
        ++n2;
      for (i = t2.length; t2.charCodeAt(i - 1) === 48; )
        --i;
      if (t2 = t2.slice(n2, i), t2) {
        if (i -= n2, r3 = r3 - n2 - 1, e3.e = et(r3 / $), e3.d = [], n2 = (r3 + 1) % $, r3 < 0 && (n2 += $), n2 < i) {
          for (n2 && e3.d.push(+t2.slice(0, n2)), i -= $; n2 < i; )
            e3.d.push(+t2.slice(n2, n2 += $));
          t2 = t2.slice(n2), n2 = $ - t2.length;
        } else
          n2 -= i;
        for (; n2--; )
          t2 += "0";
        if (e3.d.push(+t2), B && (e3.e > dr || e3.e < -dr))
          throw Error(Pn + r3);
      } else
        e3.s = 0, e3.e = 0, e3.d = [0];
      return e3;
    }
    function _(e3, t2, r3) {
      var n2, i, o2, s3, a, d, f, P, A = e3.d;
      for (s3 = 1, o2 = A[0]; o2 >= 10; o2 /= 10)
        s3++;
      if (n2 = t2 - s3, n2 < 0)
        n2 += $, i = t2, f = A[P = 0];
      else {
        if (P = Math.ceil((n2 + 1) / $), o2 = A.length, P >= o2)
          return e3;
        for (f = o2 = A[P], s3 = 1; o2 >= 10; o2 /= 10)
          s3++;
        n2 %= $, i = n2 - $ + s3;
      }
      if (r3 !== void 0 && (o2 = $e(10, s3 - i - 1), a = f / o2 % 10 | 0, d = t2 < 0 || A[P + 1] !== void 0 || f % o2, d = r3 < 4 ? (a || d) && (r3 == 0 || r3 == (e3.s < 0 ? 3 : 2)) : a > 5 || a == 5 && (r3 == 4 || d || r3 == 6 && (n2 > 0 ? i > 0 ? f / $e(10, s3 - i) : 0 : A[P - 1]) % 10 & 1 || r3 == (e3.s < 0 ? 8 : 7))), t2 < 1 || !A[0])
        return d ? (o2 = J(e3), A.length = 1, t2 = t2 - o2 - 1, A[0] = $e(10, ($ - t2 % $) % $), e3.e = et(-t2 / $) || 0) : (A.length = 1, A[0] = e3.e = e3.s = 0), e3;
      if (n2 == 0 ? (A.length = P, o2 = 1, P--) : (A.length = P + 1, o2 = $e(10, $ - n2), A[P] = i > 0 ? (f / $e(10, s3 - i) % $e(10, i) | 0) * o2 : 0), d)
        for (; ; )
          if (P == 0) {
            (A[0] += o2) == G && (A[0] = 1, ++e3.e);
            break;
          } else {
            if (A[P] += o2, A[P] != G)
              break;
            A[P--] = 0, o2 = 1;
          }
      for (n2 = A.length; A[--n2] === 0; )
        A.pop();
      if (B && (e3.e > dr || e3.e < -dr))
        throw Error(Pn + J(e3));
      return e3;
    }
    function Wi(e3, t2) {
      var r3, n2, i, o2, s3, a, d, f, P, A, S = e3.constructor, C = S.precision;
      if (!e3.s || !t2.s)
        return t2.s ? t2.s = -t2.s : t2 = new S(e3), B ? _(t2, C) : t2;
      if (d = e3.d, A = t2.d, n2 = t2.e, f = e3.e, d = d.slice(), s3 = f - n2, s3) {
        for (P = s3 < 0, P ? (r3 = d, s3 = -s3, a = A.length) : (r3 = A, n2 = f, a = d.length), i = Math.max(Math.ceil(C / $), a) + 2, s3 > i && (s3 = i, r3.length = 1), r3.reverse(), i = s3; i--; )
          r3.push(0);
        r3.reverse();
      } else {
        for (i = d.length, a = A.length, P = i < a, P && (a = i), i = 0; i < a; i++)
          if (d[i] != A[i]) {
            P = d[i] < A[i];
            break;
          }
        s3 = 0;
      }
      for (P && (r3 = d, d = A, A = r3, t2.s = -t2.s), a = d.length, i = A.length - a; i > 0; --i)
        d[a++] = 0;
      for (i = A.length; i > s3; ) {
        if (d[--i] < A[i]) {
          for (o2 = i; o2 && d[--o2] === 0; )
            d[o2] = G - 1;
          --d[o2], d[i] += G;
        }
        d[i] -= A[i];
      }
      for (; d[--a] === 0; )
        d.pop();
      for (; d[0] === 0; d.shift())
        --n2;
      return d[0] ? (t2.d = d, t2.e = n2, B ? _(t2, C) : t2) : new S(0);
    }
    function Ve(e3, t2, r3) {
      var n2, i = J(e3), o2 = ge(e3.d), s3 = o2.length;
      return t2 ? (r3 && (n2 = r3 - s3) > 0 ? o2 = o2.charAt(0) + "." + o2.slice(1) + Re(n2) : s3 > 1 && (o2 = o2.charAt(0) + "." + o2.slice(1)), o2 = o2 + (i < 0 ? "e" : "e+") + i) : i < 0 ? (o2 = "0." + Re(-i - 1) + o2, r3 && (n2 = r3 - s3) > 0 && (o2 += Re(n2))) : i >= s3 ? (o2 += Re(i + 1 - s3), r3 && (n2 = r3 - i - 1) > 0 && (o2 = o2 + "." + Re(n2))) : ((n2 = i + 1) < s3 && (o2 = o2.slice(0, n2) + "." + o2.slice(n2)), r3 && (n2 = r3 - s3) > 0 && (i + 1 === s3 && (o2 += "."), o2 += Re(n2))), e3.s < 0 ? "-" + o2 : o2;
    }
    function ji(e3, t2) {
      if (e3.length > t2)
        return e3.length = t2, true;
    }
    function Gi(e3) {
      var t2, r3, n2;
      function i(o2) {
        var s3 = this;
        if (!(s3 instanceof i))
          return new i(o2);
        if (s3.constructor = i, o2 instanceof i) {
          s3.s = o2.s, s3.e = o2.e, s3.d = (o2 = o2.d) ? o2.slice() : o2;
          return;
        }
        if (typeof o2 == "number") {
          if (o2 * 0 !== 0)
            throw Error(qe + o2);
          if (o2 > 0)
            s3.s = 1;
          else if (o2 < 0)
            o2 = -o2, s3.s = -1;
          else {
            s3.s = 0, s3.e = 0, s3.d = [0];
            return;
          }
          if (o2 === ~~o2 && o2 < 1e7) {
            s3.e = 0, s3.d = [o2];
            return;
          }
          return Bi(s3, o2.toString());
        } else if (typeof o2 != "string")
          throw Error(qe + o2);
        if (o2.charCodeAt(0) === 45 ? (o2 = o2.slice(1), s3.s = -1) : s3.s = 1, hu.test(o2))
          Bi(s3, o2);
        else
          throw Error(qe + o2);
      }
      if (i.prototype = v, i.ROUND_UP = 0, i.ROUND_DOWN = 1, i.ROUND_CEIL = 2, i.ROUND_FLOOR = 3, i.ROUND_HALF_UP = 4, i.ROUND_HALF_DOWN = 5, i.ROUND_HALF_EVEN = 6, i.ROUND_HALF_CEIL = 7, i.ROUND_HALF_FLOOR = 8, i.clone = Gi, i.config = i.set = wu, e3 === void 0 && (e3 = {}), e3)
        for (n2 = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"], t2 = 0; t2 < n2.length; )
          e3.hasOwnProperty(r3 = n2[t2++]) || (e3[r3] = this[r3]);
      return i.config(e3), i;
    }
    function wu(e3) {
      if (!e3 || typeof e3 != "object")
        throw Error(le + "Object expected");
      var t2, r3, n2, i = ["precision", 1, Xe, "rounding", 0, 8, "toExpNeg", -1 / 0, 0, "toExpPos", 0, 1 / 0];
      for (t2 = 0; t2 < i.length; t2 += 3)
        if ((n2 = e3[r3 = i[t2]]) !== void 0)
          if (et(n2) === n2 && n2 >= i[t2 + 1] && n2 <= i[t2 + 2])
            this[r3] = n2;
          else
            throw Error(qe + r3 + ": " + n2);
      if ((n2 = e3[r3 = "LN10"]) !== void 0)
        if (n2 == Math.LN10)
          this[r3] = new this(n2);
        else
          throw Error(qe + r3 + ": " + n2);
      return this;
    }
    var Xe;
    var yu;
    var Ki;
    var B;
    var le;
    var qe;
    var Pn;
    var et;
    var $e;
    var hu;
    var se;
    var G;
    var $;
    var Qi;
    var dr;
    var v;
    var Ae;
    var Ki;
    var zi = fe(() => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Xe = 1e9, yu = { precision: 20, rounding: 4, toExpNeg: -7, toExpPos: 21, LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286" }, B = true, le = "[DecimalError] ", qe = le + "Invalid argument: ", Pn = le + "Exponent out of range: ", et = Math.floor, $e = Math.pow, hu = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, G = 1e7, $ = 7, Qi = 9007199254740991, dr = et(Qi / $), v = {};
      v.absoluteValue = v.abs = function() {
        var e3 = new this.constructor(this);
        return e3.s && (e3.s = 1), e3;
      };
      v.comparedTo = v.cmp = function(e3) {
        var t2, r3, n2, i, o2 = this;
        if (e3 = new o2.constructor(e3), o2.s !== e3.s)
          return o2.s || -e3.s;
        if (o2.e !== e3.e)
          return o2.e > e3.e ^ o2.s < 0 ? 1 : -1;
        for (n2 = o2.d.length, i = e3.d.length, t2 = 0, r3 = n2 < i ? n2 : i; t2 < r3; ++t2)
          if (o2.d[t2] !== e3.d[t2])
            return o2.d[t2] > e3.d[t2] ^ o2.s < 0 ? 1 : -1;
        return n2 === i ? 0 : n2 > i ^ o2.s < 0 ? 1 : -1;
      };
      v.decimalPlaces = v.dp = function() {
        var e3 = this, t2 = e3.d.length - 1, r3 = (t2 - e3.e) * $;
        if (t2 = e3.d[t2], t2)
          for (; t2 % 10 == 0; t2 /= 10)
            r3--;
        return r3 < 0 ? 0 : r3;
      };
      v.dividedBy = v.div = function(e3) {
        return Ae(this, new this.constructor(e3));
      };
      v.dividedToIntegerBy = v.idiv = function(e3) {
        var t2 = this, r3 = t2.constructor;
        return _(Ae(t2, new r3(e3), 0, 1), r3.precision);
      };
      v.equals = v.eq = function(e3) {
        return !this.cmp(e3);
      };
      v.exponent = function() {
        return J(this);
      };
      v.greaterThan = v.gt = function(e3) {
        return this.cmp(e3) > 0;
      };
      v.greaterThanOrEqualTo = v.gte = function(e3) {
        return this.cmp(e3) >= 0;
      };
      v.isInteger = v.isint = function() {
        return this.e > this.d.length - 2;
      };
      v.isNegative = v.isneg = function() {
        return this.s < 0;
      };
      v.isPositive = v.ispos = function() {
        return this.s > 0;
      };
      v.isZero = function() {
        return this.s === 0;
      };
      v.lessThan = v.lt = function(e3) {
        return this.cmp(e3) < 0;
      };
      v.lessThanOrEqualTo = v.lte = function(e3) {
        return this.cmp(e3) < 1;
      };
      v.logarithm = v.log = function(e3) {
        var t2, r3 = this, n2 = r3.constructor, i = n2.precision, o2 = i + 5;
        if (e3 === void 0)
          e3 = new n2(10);
        else if (e3 = new n2(e3), e3.s < 1 || e3.eq(se))
          throw Error(le + "NaN");
        if (r3.s < 1)
          throw Error(le + (r3.s ? "NaN" : "-Infinity"));
        return r3.eq(se) ? new n2(0) : (B = false, t2 = Ae(Ct(r3, o2), Ct(e3, o2), o2), B = true, _(t2, i));
      };
      v.minus = v.sub = function(e3) {
        var t2 = this;
        return e3 = new t2.constructor(e3), t2.s == e3.s ? Wi(t2, e3) : Hi(t2, (e3.s = -e3.s, e3));
      };
      v.modulo = v.mod = function(e3) {
        var t2, r3 = this, n2 = r3.constructor, i = n2.precision;
        if (e3 = new n2(e3), !e3.s)
          throw Error(le + "NaN");
        return r3.s ? (B = false, t2 = Ae(r3, e3, 0, 1).times(e3), B = true, r3.minus(t2)) : _(new n2(r3), i);
      };
      v.naturalExponential = v.exp = function() {
        return Ji(this);
      };
      v.naturalLogarithm = v.ln = function() {
        return Ct(this);
      };
      v.negated = v.neg = function() {
        var e3 = new this.constructor(this);
        return e3.s = -e3.s || 0, e3;
      };
      v.plus = v.add = function(e3) {
        var t2 = this;
        return e3 = new t2.constructor(e3), t2.s == e3.s ? Hi(t2, e3) : Wi(t2, (e3.s = -e3.s, e3));
      };
      v.precision = v.sd = function(e3) {
        var t2, r3, n2, i = this;
        if (e3 !== void 0 && e3 !== !!e3 && e3 !== 1 && e3 !== 0)
          throw Error(qe + e3);
        if (t2 = J(i) + 1, n2 = i.d.length - 1, r3 = n2 * $ + 1, n2 = i.d[n2], n2) {
          for (; n2 % 10 == 0; n2 /= 10)
            r3--;
          for (n2 = i.d[0]; n2 >= 10; n2 /= 10)
            r3++;
        }
        return e3 && t2 > r3 ? t2 : r3;
      };
      v.squareRoot = v.sqrt = function() {
        var e3, t2, r3, n2, i, o2, s3, a = this, d = a.constructor;
        if (a.s < 1) {
          if (!a.s)
            return new d(0);
          throw Error(le + "NaN");
        }
        for (e3 = J(a), B = false, i = Math.sqrt(+a), i == 0 || i == 1 / 0 ? (t2 = ge(a.d), (t2.length + e3) % 2 == 0 && (t2 += "0"), i = Math.sqrt(t2), e3 = et((e3 + 1) / 2) - (e3 < 0 || e3 % 2), i == 1 / 0 ? t2 = "5e" + e3 : (t2 = i.toExponential(), t2 = t2.slice(0, t2.indexOf("e") + 1) + e3), n2 = new d(t2)) : n2 = new d(i.toString()), r3 = d.precision, i = s3 = r3 + 3; ; )
          if (o2 = n2, n2 = o2.plus(Ae(a, o2, s3 + 2)).times(0.5), ge(o2.d).slice(0, s3) === (t2 = ge(n2.d)).slice(0, s3)) {
            if (t2 = t2.slice(s3 - 3, s3 + 1), i == s3 && t2 == "4999") {
              if (_(o2, r3 + 1, 0), o2.times(o2).eq(a)) {
                n2 = o2;
                break;
              }
            } else if (t2 != "9999")
              break;
            s3 += 4;
          }
        return B = true, _(n2, r3);
      };
      v.times = v.mul = function(e3) {
        var t2, r3, n2, i, o2, s3, a, d, f, P = this, A = P.constructor, S = P.d, C = (e3 = new A(e3)).d;
        if (!P.s || !e3.s)
          return new A(0);
        for (e3.s *= P.s, r3 = P.e + e3.e, d = S.length, f = C.length, d < f && (o2 = S, S = C, C = o2, s3 = d, d = f, f = s3), o2 = [], s3 = d + f, n2 = s3; n2--; )
          o2.push(0);
        for (n2 = f; --n2 >= 0; ) {
          for (t2 = 0, i = d + n2; i > n2; )
            a = o2[i] + C[n2] * S[i - n2 - 1] + t2, o2[i--] = a % G | 0, t2 = a / G | 0;
          o2[i] = (o2[i] + t2) % G | 0;
        }
        for (; !o2[--s3]; )
          o2.pop();
        return t2 ? ++r3 : o2.shift(), e3.d = o2, e3.e = r3, B ? _(e3, A.precision) : e3;
      };
      v.toDecimalPlaces = v.todp = function(e3, t2) {
        var r3 = this, n2 = r3.constructor;
        return r3 = new n2(r3), e3 === void 0 ? r3 : (ye(e3, 0, Xe), t2 === void 0 ? t2 = n2.rounding : ye(t2, 0, 8), _(r3, e3 + J(r3) + 1, t2));
      };
      v.toExponential = function(e3, t2) {
        var r3, n2 = this, i = n2.constructor;
        return e3 === void 0 ? r3 = Ve(n2, true) : (ye(e3, 0, Xe), t2 === void 0 ? t2 = i.rounding : ye(t2, 0, 8), n2 = _(new i(n2), e3 + 1, t2), r3 = Ve(n2, true, e3 + 1)), r3;
      };
      v.toFixed = function(e3, t2) {
        var r3, n2, i = this, o2 = i.constructor;
        return e3 === void 0 ? Ve(i) : (ye(e3, 0, Xe), t2 === void 0 ? t2 = o2.rounding : ye(t2, 0, 8), n2 = _(new o2(i), e3 + J(i) + 1, t2), r3 = Ve(n2.abs(), false, e3 + J(n2) + 1), i.isneg() && !i.isZero() ? "-" + r3 : r3);
      };
      v.toInteger = v.toint = function() {
        var e3 = this, t2 = e3.constructor;
        return _(new t2(e3), J(e3) + 1, t2.rounding);
      };
      v.toNumber = function() {
        return +this;
      };
      v.toPower = v.pow = function(e3) {
        var t2, r3, n2, i, o2, s3, a = this, d = a.constructor, f = 12, P = +(e3 = new d(e3));
        if (!e3.s)
          return new d(se);
        if (a = new d(a), !a.s) {
          if (e3.s < 1)
            throw Error(le + "Infinity");
          return a;
        }
        if (a.eq(se))
          return a;
        if (n2 = d.precision, e3.eq(se))
          return _(a, n2);
        if (t2 = e3.e, r3 = e3.d.length - 1, s3 = t2 >= r3, o2 = a.s, s3) {
          if ((r3 = P < 0 ? -P : P) <= Qi) {
            for (i = new d(se), t2 = Math.ceil(n2 / $ + 4), B = false; r3 % 2 && (i = i.times(a), ji(i.d, t2)), r3 = et(r3 / 2), r3 !== 0; )
              a = a.times(a), ji(a.d, t2);
            return B = true, e3.s < 0 ? new d(se).div(i) : _(i, n2);
          }
        } else if (o2 < 0)
          throw Error(le + "NaN");
        return o2 = o2 < 0 && e3.d[Math.max(t2, r3)] & 1 ? -1 : 1, a.s = 1, B = false, i = e3.times(Ct(a, n2 + f)), B = true, i = Ji(i), i.s = o2, i;
      };
      v.toPrecision = function(e3, t2) {
        var r3, n2, i = this, o2 = i.constructor;
        return e3 === void 0 ? (r3 = J(i), n2 = Ve(i, r3 <= o2.toExpNeg || r3 >= o2.toExpPos)) : (ye(e3, 1, Xe), t2 === void 0 ? t2 = o2.rounding : ye(t2, 0, 8), i = _(new o2(i), e3, t2), r3 = J(i), n2 = Ve(i, e3 <= r3 || r3 <= o2.toExpNeg, e3)), n2;
      };
      v.toSignificantDigits = v.tosd = function(e3, t2) {
        var r3 = this, n2 = r3.constructor;
        return e3 === void 0 ? (e3 = n2.precision, t2 = n2.rounding) : (ye(e3, 1, Xe), t2 === void 0 ? t2 = n2.rounding : ye(t2, 0, 8)), _(new n2(r3), e3, t2);
      };
      v.toString = v.valueOf = v.val = v.toJSON = v[Symbol.for("nodejs.util.inspect.custom")] = function() {
        var e3 = this, t2 = J(e3), r3 = e3.constructor;
        return Ve(e3, t2 <= r3.toExpNeg || t2 >= r3.toExpPos);
      };
      Ae = function() {
        function e3(n2, i) {
          var o2, s3 = 0, a = n2.length;
          for (n2 = n2.slice(); a--; )
            o2 = n2[a] * i + s3, n2[a] = o2 % G | 0, s3 = o2 / G | 0;
          return s3 && n2.unshift(s3), n2;
        }
        function t2(n2, i, o2, s3) {
          var a, d;
          if (o2 != s3)
            d = o2 > s3 ? 1 : -1;
          else
            for (a = d = 0; a < o2; a++)
              if (n2[a] != i[a]) {
                d = n2[a] > i[a] ? 1 : -1;
                break;
              }
          return d;
        }
        function r3(n2, i, o2) {
          for (var s3 = 0; o2--; )
            n2[o2] -= s3, s3 = n2[o2] < i[o2] ? 1 : 0, n2[o2] = s3 * G + n2[o2] - i[o2];
          for (; !n2[0] && n2.length > 1; )
            n2.shift();
        }
        return function(n2, i, o2, s3) {
          var a, d, f, P, A, S, C, M, R, k, Pe, re, F, ne, Fe, bn, ce, ur, cr = n2.constructor, ru = n2.s == i.s ? 1 : -1, de = n2.d, Q = i.d;
          if (!n2.s)
            return new cr(n2);
          if (!i.s)
            throw Error(le + "Division by zero");
          for (d = n2.e - i.e, ce = Q.length, Fe = de.length, C = new cr(ru), M = C.d = [], f = 0; Q[f] == (de[f] || 0); )
            ++f;
          if (Q[f] > (de[f] || 0) && --d, o2 == null ? re = o2 = cr.precision : s3 ? re = o2 + (J(n2) - J(i)) + 1 : re = o2, re < 0)
            return new cr(0);
          if (re = re / $ + 2 | 0, f = 0, ce == 1)
            for (P = 0, Q = Q[0], re++; (f < Fe || P) && re--; f++)
              F = P * G + (de[f] || 0), M[f] = F / Q | 0, P = F % Q | 0;
          else {
            for (P = G / (Q[0] + 1) | 0, P > 1 && (Q = e3(Q, P), de = e3(de, P), ce = Q.length, Fe = de.length), ne = ce, R = de.slice(0, ce), k = R.length; k < ce; )
              R[k++] = 0;
            ur = Q.slice(), ur.unshift(0), bn = Q[0], Q[1] >= G / 2 && ++bn;
            do
              P = 0, a = t2(Q, R, ce, k), a < 0 ? (Pe = R[0], ce != k && (Pe = Pe * G + (R[1] || 0)), P = Pe / bn | 0, P > 1 ? (P >= G && (P = G - 1), A = e3(Q, P), S = A.length, k = R.length, a = t2(A, R, S, k), a == 1 && (P--, r3(A, ce < S ? ur : Q, S))) : (P == 0 && (a = P = 1), A = Q.slice()), S = A.length, S < k && A.unshift(0), r3(R, A, k), a == -1 && (k = R.length, a = t2(Q, R, ce, k), a < 1 && (P++, r3(R, ce < k ? ur : Q, k))), k = R.length) : a === 0 && (P++, R = [0]), M[f++] = P, a && R[0] ? R[k++] = de[ne] || 0 : (R = [de[ne]], k = 1);
            while ((ne++ < Fe || R[0] !== void 0) && re--);
          }
          return M[0] || M.shift(), C.e = d, _(C, s3 ? o2 + J(C) + 1 : o2);
        };
      }();
      Ki = Gi(yu);
      se = new Ki(1);
    });
    var m = fe(() => {
      "use strict";
      zi();
    });
    var In = {};
    Ye(In, { Hash: () => Ot, createHash: () => yo, default: () => rt, randomFillSync: () => wr, randomUUID: () => hr, webcrypto: () => kt });
    function hr() {
      return globalThis.crypto.randomUUID();
    }
    function wr(e3, t2, r3) {
      return t2 !== void 0 && (r3 !== void 0 ? e3 = e3.subarray(t2, t2 + r3) : e3 = e3.subarray(t2)), globalThis.crypto.getRandomValues(e3);
    }
    function yo(e3) {
      return new Ot(e3);
    }
    var kt;
    var Ot;
    var rt;
    var Be = fe(() => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      kt = globalThis.crypto;
      Ot = class {
        #t = [];
        #e;
        constructor(t2) {
          this.#e = t2;
        }
        update(t2) {
          this.#t.push(t2);
        }
        async digest() {
          let t2 = new Uint8Array(this.#t.reduce((i, o2) => i + o2.length, 0)), r3 = 0;
          for (let i of this.#t)
            t2.set(i, r3), r3 += i.length;
          let n2 = await globalThis.crypto.subtle.digest(this.#e, t2);
          return new Uint8Array(n2);
        }
      }, rt = { webcrypto: kt, randomUUID: hr, randomFillSync: wr, createHash: yo, Hash: Ot };
    });
    var ho = oe(() => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
    });
    var wo = oe((jg, Au) => {
      Au.exports = { name: "@prisma/engines-version", version: "7.1.0-6.ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba", main: "index.js", types: "index.d.ts", license: "Apache-2.0", author: "Tim Suchanek <suchanek@prisma.io>", prisma: { enginesVersion: "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba" }, repository: { type: "git", url: "https://github.com/prisma/engines-wrapper.git", directory: "packages/engines-version" }, devDependencies: { "@types/node": "18.19.76", typescript: "4.9.5" }, files: ["index.js", "index.d.ts"], scripts: { build: "tsc -d" } };
    });
    var bo = oe((br) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Object.defineProperty(br, "__esModule", { value: true });
      br.enginesVersion = void 0;
      br.enginesVersion = wo().prisma.enginesVersion;
    });
    var Po = oe((ry, To) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      To.exports = (e3, t2 = 1, r3) => {
        if (r3 = { indent: " ", includeEmptyLines: false, ...r3 }, typeof e3 != "string")
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof e3}\``);
        if (typeof t2 != "number")
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof t2}\``);
        if (typeof r3.indent != "string")
          throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof r3.indent}\``);
        if (t2 === 0)
          return e3;
        let n2 = r3.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return e3.replace(n2, r3.indent.repeat(t2));
      };
    });
    var vo = oe((Dy, Er) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Er.exports = (e3 = {}) => {
        let t2;
        if (e3.repoUrl)
          t2 = e3.repoUrl;
        else if (e3.user && e3.repo)
          t2 = `https://github.com/${e3.user}/${e3.repo}`;
        else
          throw new Error("You need to specify either the `repoUrl` option or both the `user` and `repo` options");
        let r3 = new URL(`${t2}/issues/new`), n2 = ["body", "title", "labels", "template", "milestone", "assignee", "projects"];
        for (let i of n2) {
          let o2 = e3[i];
          if (o2 !== void 0) {
            if (i === "labels" || i === "projects") {
              if (!Array.isArray(o2))
                throw new TypeError(`The \`${i}\` option should be an array`);
              o2 = o2.join(",");
            }
            r3.searchParams.set(i, o2);
          }
        }
        return r3.toString();
      };
      Er.exports.default = Er.exports;
    });
    var _n = oe((Ew, Ro) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Ro.exports = function() {
        function e3(t2, r3, n2, i, o2) {
          return t2 < r3 || n2 < r3 ? t2 > n2 ? n2 + 1 : t2 + 1 : i === o2 ? r3 : r3 + 1;
        }
        return function(t2, r3) {
          if (t2 === r3)
            return 0;
          if (t2.length > r3.length) {
            var n2 = t2;
            t2 = r3, r3 = n2;
          }
          for (var i = t2.length, o2 = r3.length; i > 0 && t2.charCodeAt(i - 1) === r3.charCodeAt(o2 - 1); )
            i--, o2--;
          for (var s3 = 0; s3 < i && t2.charCodeAt(s3) === r3.charCodeAt(s3); )
            s3++;
          if (i -= s3, o2 -= s3, i === 0 || o2 < 3)
            return o2;
          var a = 0, d, f, P, A, S, C, M, R, k, Pe, re, F, ne = [];
          for (d = 0; d < i; d++)
            ne.push(d + 1), ne.push(t2.charCodeAt(s3 + d));
          for (var Fe = ne.length - 1; a < o2 - 3; )
            for (k = r3.charCodeAt(s3 + (f = a)), Pe = r3.charCodeAt(s3 + (P = a + 1)), re = r3.charCodeAt(s3 + (A = a + 2)), F = r3.charCodeAt(s3 + (S = a + 3)), C = a += 4, d = 0; d < Fe; d += 2)
              M = ne[d], R = ne[d + 1], f = e3(M, f, P, k, R), P = e3(f, P, A, Pe, R), A = e3(P, A, S, re, R), C = e3(A, S, C, F, R), ne[d] = C, S = A, A = P, P = f, f = M;
          for (; a < o2; )
            for (k = r3.charCodeAt(s3 + (f = a)), C = ++a, d = 0; d < Fe; d += 2)
              M = ne[d], ne[d] = C = e3(M, f, C, k, ne[d + 1]), f = M;
          return C;
        };
      }();
    });
    var Do = fe(() => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
    });
    var No = fe(() => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
    });
    var $r;
    var os = fe(() => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      $r = class {
        events = {};
        on(t2, r3) {
          return this.events[t2] || (this.events[t2] = []), this.events[t2].push(r3), this;
        }
        emit(t2, ...r3) {
          return this.events[t2] ? (this.events[t2].forEach((n2) => {
            n2(...r3);
          }), true) : false;
        }
      };
    });
    var ri = oe((Je) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Object.defineProperty(Je, "__esModule", { value: true });
      Je.anumber = ti;
      Je.abytes = Gs;
      Je.ahash = ip;
      Je.aexists = op;
      Je.aoutput = sp;
      function ti(e3) {
        if (!Number.isSafeInteger(e3) || e3 < 0)
          throw new Error("positive integer expected, got " + e3);
      }
      function np(e3) {
        return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
      }
      function Gs(e3, ...t2) {
        if (!np(e3))
          throw new Error("Uint8Array expected");
        if (t2.length > 0 && !t2.includes(e3.length))
          throw new Error("Uint8Array expected of length " + t2 + ", got length=" + e3.length);
      }
      function ip(e3) {
        if (typeof e3 != "function" || typeof e3.create != "function")
          throw new Error("Hash should be wrapped by utils.wrapConstructor");
        ti(e3.outputLen), ti(e3.blockLen);
      }
      function op(e3, t2 = true) {
        if (e3.destroyed)
          throw new Error("Hash instance has been destroyed");
        if (t2 && e3.finished)
          throw new Error("Hash#digest() has already been called");
      }
      function sp(e3, t2) {
        Gs(e3);
        let r3 = t2.outputLen;
        if (e3.length < r3)
          throw new Error("digestInto() expects output buffer of length at least " + r3);
      }
    });
    var ya = oe((O) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Object.defineProperty(O, "__esModule", { value: true });
      O.add5L = O.add5H = O.add4H = O.add4L = O.add3H = O.add3L = O.rotlBL = O.rotlBH = O.rotlSL = O.rotlSH = O.rotr32L = O.rotr32H = O.rotrBL = O.rotrBH = O.rotrSL = O.rotrSH = O.shrSL = O.shrSH = O.toBig = void 0;
      O.fromBig = ii;
      O.split = Ks;
      O.add = ua;
      var Gr = BigInt(2 ** 32 - 1), ni = BigInt(32);
      function ii(e3, t2 = false) {
        return t2 ? { h: Number(e3 & Gr), l: Number(e3 >> ni & Gr) } : { h: Number(e3 >> ni & Gr) | 0, l: Number(e3 & Gr) | 0 };
      }
      function Ks(e3, t2 = false) {
        let r3 = new Uint32Array(e3.length), n2 = new Uint32Array(e3.length);
        for (let i = 0; i < e3.length; i++) {
          let { h: o2, l: s3 } = ii(e3[i], t2);
          [r3[i], n2[i]] = [o2, s3];
        }
        return [r3, n2];
      }
      var zs = (e3, t2) => BigInt(e3 >>> 0) << ni | BigInt(t2 >>> 0);
      O.toBig = zs;
      var Zs = (e3, t2, r3) => e3 >>> r3;
      O.shrSH = Zs;
      var Ys = (e3, t2, r3) => e3 << 32 - r3 | t2 >>> r3;
      O.shrSL = Ys;
      var Xs = (e3, t2, r3) => e3 >>> r3 | t2 << 32 - r3;
      O.rotrSH = Xs;
      var ea = (e3, t2, r3) => e3 << 32 - r3 | t2 >>> r3;
      O.rotrSL = ea;
      var ta = (e3, t2, r3) => e3 << 64 - r3 | t2 >>> r3 - 32;
      O.rotrBH = ta;
      var ra = (e3, t2, r3) => e3 >>> r3 - 32 | t2 << 64 - r3;
      O.rotrBL = ra;
      var na = (e3, t2) => t2;
      O.rotr32H = na;
      var ia = (e3, t2) => e3;
      O.rotr32L = ia;
      var oa = (e3, t2, r3) => e3 << r3 | t2 >>> 32 - r3;
      O.rotlSH = oa;
      var sa = (e3, t2, r3) => t2 << r3 | e3 >>> 32 - r3;
      O.rotlSL = sa;
      var aa = (e3, t2, r3) => t2 << r3 - 32 | e3 >>> 64 - r3;
      O.rotlBH = aa;
      var la = (e3, t2, r3) => e3 << r3 - 32 | t2 >>> 64 - r3;
      O.rotlBL = la;
      function ua(e3, t2, r3, n2) {
        let i = (t2 >>> 0) + (n2 >>> 0);
        return { h: e3 + r3 + (i / 2 ** 32 | 0) | 0, l: i | 0 };
      }
      var ca = (e3, t2, r3) => (e3 >>> 0) + (t2 >>> 0) + (r3 >>> 0);
      O.add3L = ca;
      var pa = (e3, t2, r3, n2) => t2 + r3 + n2 + (e3 / 2 ** 32 | 0) | 0;
      O.add3H = pa;
      var ma = (e3, t2, r3, n2) => (e3 >>> 0) + (t2 >>> 0) + (r3 >>> 0) + (n2 >>> 0);
      O.add4L = ma;
      var da = (e3, t2, r3, n2, i) => t2 + r3 + n2 + i + (e3 / 2 ** 32 | 0) | 0;
      O.add4H = da;
      var fa = (e3, t2, r3, n2, i) => (e3 >>> 0) + (t2 >>> 0) + (r3 >>> 0) + (n2 >>> 0) + (i >>> 0);
      O.add5L = fa;
      var ga = (e3, t2, r3, n2, i, o2) => t2 + r3 + n2 + i + o2 + (e3 / 2 ** 32 | 0) | 0;
      O.add5H = ga;
      var ap = { fromBig: ii, split: Ks, toBig: zs, shrSH: Zs, shrSL: Ys, rotrSH: Xs, rotrSL: ea, rotrBH: ta, rotrBL: ra, rotr32H: na, rotr32L: ia, rotlSH: oa, rotlSL: sa, rotlBH: aa, rotlBL: la, add: ua, add3L: ca, add3H: pa, add4L: ma, add4H: da, add5H: ga, add5L: fa };
      O.default = ap;
    });
    var ha = oe((Kr) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Object.defineProperty(Kr, "__esModule", { value: true });
      Kr.crypto = void 0;
      var Ne = (Be(), $i(In));
      Kr.crypto = Ne && typeof Ne == "object" && "webcrypto" in Ne ? Ne.webcrypto : Ne && typeof Ne == "object" && "randomBytes" in Ne ? Ne : void 0;
    });
    var xa = oe((N) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Object.defineProperty(N, "__esModule", { value: true });
      N.Hash = N.nextTick = N.byteSwapIfBE = N.isLE = void 0;
      N.isBytes = lp;
      N.u8 = up;
      N.u32 = cp;
      N.createView = pp;
      N.rotr = mp;
      N.rotl = dp;
      N.byteSwap = ai;
      N.byteSwap32 = fp;
      N.bytesToHex = yp;
      N.hexToBytes = hp;
      N.asyncLoop = bp;
      N.utf8ToBytes = ba;
      N.toBytes = zr;
      N.concatBytes = xp;
      N.checkOpts = Ep;
      N.wrapConstructor = Tp;
      N.wrapConstructorWithOpts = Pp;
      N.wrapXOFConstructorWithOpts = Ap;
      N.randomBytes = vp;
      var wt = ha(), si = ri();
      function lp(e3) {
        return e3 instanceof Uint8Array || ArrayBuffer.isView(e3) && e3.constructor.name === "Uint8Array";
      }
      function up(e3) {
        return new Uint8Array(e3.buffer, e3.byteOffset, e3.byteLength);
      }
      function cp(e3) {
        return new Uint32Array(e3.buffer, e3.byteOffset, Math.floor(e3.byteLength / 4));
      }
      function pp(e3) {
        return new DataView(e3.buffer, e3.byteOffset, e3.byteLength);
      }
      function mp(e3, t2) {
        return e3 << 32 - t2 | e3 >>> t2;
      }
      function dp(e3, t2) {
        return e3 << t2 | e3 >>> 32 - t2 >>> 0;
      }
      N.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
      function ai(e3) {
        return e3 << 24 & 4278190080 | e3 << 8 & 16711680 | e3 >>> 8 & 65280 | e3 >>> 24 & 255;
      }
      N.byteSwapIfBE = N.isLE ? (e3) => e3 : (e3) => ai(e3);
      function fp(e3) {
        for (let t2 = 0; t2 < e3.length; t2++)
          e3[t2] = ai(e3[t2]);
      }
      var gp = Array.from({ length: 256 }, (e3, t2) => t2.toString(16).padStart(2, "0"));
      function yp(e3) {
        (0, si.abytes)(e3);
        let t2 = "";
        for (let r3 = 0; r3 < e3.length; r3++)
          t2 += gp[e3[r3]];
        return t2;
      }
      var Ce = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
      function wa(e3) {
        if (e3 >= Ce._0 && e3 <= Ce._9)
          return e3 - Ce._0;
        if (e3 >= Ce.A && e3 <= Ce.F)
          return e3 - (Ce.A - 10);
        if (e3 >= Ce.a && e3 <= Ce.f)
          return e3 - (Ce.a - 10);
      }
      function hp(e3) {
        if (typeof e3 != "string")
          throw new Error("hex string expected, got " + typeof e3);
        let t2 = e3.length, r3 = t2 / 2;
        if (t2 % 2)
          throw new Error("hex string expected, got unpadded hex of length " + t2);
        let n2 = new Uint8Array(r3);
        for (let i = 0, o2 = 0; i < r3; i++, o2 += 2) {
          let s3 = wa(e3.charCodeAt(o2)), a = wa(e3.charCodeAt(o2 + 1));
          if (s3 === void 0 || a === void 0) {
            let d = e3[o2] + e3[o2 + 1];
            throw new Error('hex string expected, got non-hex character "' + d + '" at index ' + o2);
          }
          n2[i] = s3 * 16 + a;
        }
        return n2;
      }
      var wp = async () => {
      };
      N.nextTick = wp;
      async function bp(e3, t2, r3) {
        let n2 = Date.now();
        for (let i = 0; i < e3; i++) {
          r3(i);
          let o2 = Date.now() - n2;
          o2 >= 0 && o2 < t2 || (await (0, N.nextTick)(), n2 += o2);
        }
      }
      function ba(e3) {
        if (typeof e3 != "string")
          throw new Error("utf8ToBytes expected string, got " + typeof e3);
        return new Uint8Array(new TextEncoder().encode(e3));
      }
      function zr(e3) {
        return typeof e3 == "string" && (e3 = ba(e3)), (0, si.abytes)(e3), e3;
      }
      function xp(...e3) {
        let t2 = 0;
        for (let n2 = 0; n2 < e3.length; n2++) {
          let i = e3[n2];
          (0, si.abytes)(i), t2 += i.length;
        }
        let r3 = new Uint8Array(t2);
        for (let n2 = 0, i = 0; n2 < e3.length; n2++) {
          let o2 = e3[n2];
          r3.set(o2, i), i += o2.length;
        }
        return r3;
      }
      var oi = class {
        clone() {
          return this._cloneInto();
        }
      };
      N.Hash = oi;
      function Ep(e3, t2) {
        if (t2 !== void 0 && {}.toString.call(t2) !== "[object Object]")
          throw new Error("Options should be object or undefined");
        return Object.assign(e3, t2);
      }
      function Tp(e3) {
        let t2 = (n2) => e3().update(zr(n2)).digest(), r3 = e3();
        return t2.outputLen = r3.outputLen, t2.blockLen = r3.blockLen, t2.create = () => e3(), t2;
      }
      function Pp(e3) {
        let t2 = (n2, i) => e3(i).update(zr(n2)).digest(), r3 = e3({});
        return t2.outputLen = r3.outputLen, t2.blockLen = r3.blockLen, t2.create = (n2) => e3(n2), t2;
      }
      function Ap(e3) {
        let t2 = (n2, i) => e3(i).update(zr(n2)).digest(), r3 = e3({});
        return t2.outputLen = r3.outputLen, t2.blockLen = r3.blockLen, t2.create = (n2) => e3(n2), t2;
      }
      function vp(e3 = 32) {
        if (wt.crypto && typeof wt.crypto.getRandomValues == "function")
          return wt.crypto.getRandomValues(new Uint8Array(e3));
        if (wt.crypto && typeof wt.crypto.randomBytes == "function")
          return wt.crypto.randomBytes(e3);
        throw new Error("crypto.getRandomValues must be defined");
      }
    });
    var Ra = oe((V) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      Object.defineProperty(V, "__esModule", { value: true });
      V.shake256 = V.shake128 = V.keccak_512 = V.keccak_384 = V.keccak_256 = V.keccak_224 = V.sha3_512 = V.sha3_384 = V.sha3_256 = V.sha3_224 = V.Keccak = void 0;
      V.keccakP = Ca;
      var bt = ri(), zt = ya(), Se = xa(), Pa = [], Aa = [], va = [], Cp = BigInt(0), Kt = BigInt(1), Sp = BigInt(2), Rp = BigInt(7), Ip = BigInt(256), Op = BigInt(113);
      for (let e3 = 0, t2 = Kt, r3 = 1, n2 = 0; e3 < 24; e3++) {
        [r3, n2] = [n2, (2 * r3 + 3 * n2) % 5], Pa.push(2 * (5 * n2 + r3)), Aa.push((e3 + 1) * (e3 + 2) / 2 % 64);
        let i = Cp;
        for (let o2 = 0; o2 < 7; o2++)
          t2 = (t2 << Kt ^ (t2 >> Rp) * Op) % Ip, t2 & Sp && (i ^= Kt << (Kt << BigInt(o2)) - Kt);
        va.push(i);
      }
      var [kp, Mp] = (0, zt.split)(va, true), Ea = (e3, t2, r3) => r3 > 32 ? (0, zt.rotlBH)(e3, t2, r3) : (0, zt.rotlSH)(e3, t2, r3), Ta = (e3, t2, r3) => r3 > 32 ? (0, zt.rotlBL)(e3, t2, r3) : (0, zt.rotlSL)(e3, t2, r3);
      function Ca(e3, t2 = 24) {
        let r3 = new Uint32Array(10);
        for (let n2 = 24 - t2; n2 < 24; n2++) {
          for (let s3 = 0; s3 < 10; s3++)
            r3[s3] = e3[s3] ^ e3[s3 + 10] ^ e3[s3 + 20] ^ e3[s3 + 30] ^ e3[s3 + 40];
          for (let s3 = 0; s3 < 10; s3 += 2) {
            let a = (s3 + 8) % 10, d = (s3 + 2) % 10, f = r3[d], P = r3[d + 1], A = Ea(f, P, 1) ^ r3[a], S = Ta(f, P, 1) ^ r3[a + 1];
            for (let C = 0; C < 50; C += 10)
              e3[s3 + C] ^= A, e3[s3 + C + 1] ^= S;
          }
          let i = e3[2], o2 = e3[3];
          for (let s3 = 0; s3 < 24; s3++) {
            let a = Aa[s3], d = Ea(i, o2, a), f = Ta(i, o2, a), P = Pa[s3];
            i = e3[P], o2 = e3[P + 1], e3[P] = d, e3[P + 1] = f;
          }
          for (let s3 = 0; s3 < 50; s3 += 10) {
            for (let a = 0; a < 10; a++)
              r3[a] = e3[s3 + a];
            for (let a = 0; a < 10; a++)
              e3[s3 + a] ^= ~r3[(a + 2) % 10] & r3[(a + 4) % 10];
          }
          e3[0] ^= kp[n2], e3[1] ^= Mp[n2];
        }
        r3.fill(0);
      }
      var Zt = class e3 extends Se.Hash {
        constructor(t2, r3, n2, i = false, o2 = 24) {
          if (super(), this.blockLen = t2, this.suffix = r3, this.outputLen = n2, this.enableXOF = i, this.rounds = o2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, (0, bt.anumber)(n2), 0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
          this.state = new Uint8Array(200), this.state32 = (0, Se.u32)(this.state);
        }
        keccak() {
          Se.isLE || (0, Se.byteSwap32)(this.state32), Ca(this.state32, this.rounds), Se.isLE || (0, Se.byteSwap32)(this.state32), this.posOut = 0, this.pos = 0;
        }
        update(t2) {
          (0, bt.aexists)(this);
          let { blockLen: r3, state: n2 } = this;
          t2 = (0, Se.toBytes)(t2);
          let i = t2.length;
          for (let o2 = 0; o2 < i; ) {
            let s3 = Math.min(r3 - this.pos, i - o2);
            for (let a = 0; a < s3; a++)
              n2[this.pos++] ^= t2[o2++];
            this.pos === r3 && this.keccak();
          }
          return this;
        }
        finish() {
          if (this.finished)
            return;
          this.finished = true;
          let { state: t2, suffix: r3, pos: n2, blockLen: i } = this;
          t2[n2] ^= r3, (r3 & 128) !== 0 && n2 === i - 1 && this.keccak(), t2[i - 1] ^= 128, this.keccak();
        }
        writeInto(t2) {
          (0, bt.aexists)(this, false), (0, bt.abytes)(t2), this.finish();
          let r3 = this.state, { blockLen: n2 } = this;
          for (let i = 0, o2 = t2.length; i < o2; ) {
            this.posOut >= n2 && this.keccak();
            let s3 = Math.min(n2 - this.posOut, o2 - i);
            t2.set(r3.subarray(this.posOut, this.posOut + s3), i), this.posOut += s3, i += s3;
          }
          return t2;
        }
        xofInto(t2) {
          if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
          return this.writeInto(t2);
        }
        xof(t2) {
          return (0, bt.anumber)(t2), this.xofInto(new Uint8Array(t2));
        }
        digestInto(t2) {
          if ((0, bt.aoutput)(t2, this), this.finished)
            throw new Error("digest() was already called");
          return this.writeInto(t2), this.destroy(), t2;
        }
        digest() {
          return this.digestInto(new Uint8Array(this.outputLen));
        }
        destroy() {
          this.destroyed = true, this.state.fill(0);
        }
        _cloneInto(t2) {
          let { blockLen: r3, suffix: n2, outputLen: i, rounds: o2, enableXOF: s3 } = this;
          return t2 || (t2 = new e3(r3, n2, i, s3, o2)), t2.state32.set(this.state32), t2.pos = this.pos, t2.posOut = this.posOut, t2.finished = this.finished, t2.rounds = o2, t2.suffix = n2, t2.outputLen = i, t2.enableXOF = s3, t2.destroyed = this.destroyed, t2;
        }
      };
      V.Keccak = Zt;
      var Le = (e3, t2, r3) => (0, Se.wrapConstructor)(() => new Zt(t2, e3, r3));
      V.sha3_224 = Le(6, 144, 224 / 8);
      V.sha3_256 = Le(6, 136, 256 / 8);
      V.sha3_384 = Le(6, 104, 384 / 8);
      V.sha3_512 = Le(6, 72, 512 / 8);
      V.keccak_224 = Le(1, 144, 224 / 8);
      V.keccak_256 = Le(1, 136, 256 / 8);
      V.keccak_384 = Le(1, 104, 384 / 8);
      V.keccak_512 = Le(1, 72, 512 / 8);
      var Sa = (e3, t2, r3) => (0, Se.wrapXOFConstructorWithOpts)((n2 = {}) => new Zt(t2, e3, n2.dkLen === void 0 ? r3 : n2.dkLen, true));
      V.shake128 = Sa(31, 168, 128 / 8);
      V.shake256 = Sa(31, 136, 256 / 8);
    });
    var _a2 = oe((LI, _e) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      var { sha3_512: Dp } = Ra(), Oa = 24, Yt = 32, li = (e3 = 4, t2 = Math.random) => {
        let r3 = "";
        for (; r3.length < e3; )
          r3 = r3 + Math.floor(t2() * 36).toString(36);
        return r3;
      };
      function ka(e3) {
        let t2 = 8n, r3 = 0n;
        for (let n2 of e3.values()) {
          let i = BigInt(n2);
          r3 = (r3 << t2) + i;
        }
        return r3;
      }
      var Ma = (e3 = "") => ka(Dp(e3)).toString(36).slice(1), Ia = Array.from({ length: 26 }, (e3, t2) => String.fromCharCode(t2 + 97)), Np = (e3) => Ia[Math.floor(e3() * Ia.length)], Da = ({ globalObj: e3 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {}, random: t2 = Math.random } = {}) => {
        let r3 = Object.keys(e3).toString(), n2 = r3.length ? r3 + li(Yt, t2) : li(Yt, t2);
        return Ma(n2).substring(0, Yt);
      }, Na = (e3) => () => e3++, Lp = 476782367, La = ({ random: e3 = Math.random, counter: t2 = Na(Math.floor(e3() * Lp)), length: r3 = Oa, fingerprint: n2 = Da({ random: e3 }) } = {}) => function() {
        let o2 = Np(e3), s3 = Date.now().toString(36), a = t2().toString(36), d = li(r3, e3), f = `${s3 + d + a + n2}`;
        return `${o2 + Ma(f).substring(1, r3)}`;
      }, _p = La(), Fp = (e3, { minLength: t2 = 2, maxLength: r3 = Yt } = {}) => {
        let n2 = e3.length, i = /^[0-9a-z]+$/;
        try {
          if (typeof e3 == "string" && n2 >= t2 && n2 <= r3 && i.test(e3))
            return true;
        } finally {
        }
        return false;
      };
      _e.exports.getConstants = () => ({ defaultLength: Oa, bigLength: Yt });
      _e.exports.init = La;
      _e.exports.createId = _p;
      _e.exports.bufToBigInt = ka;
      _e.exports.createCounter = Na;
      _e.exports.createFingerprint = Da;
      _e.exports.isCuid = Fp;
    });
    var Fa = oe((VI, Xt) => {
      "use strict";
      l();
      u();
      c2();
      p();
      m();
      var { createId: Up, init: $p, getConstants: qp, isCuid: Vp } = _a2();
      Xt.exports.createId = Up;
      Xt.exports.init = $p;
      Xt.exports.getConstants = qp;
      Xt.exports.isCuid = Vp;
    });
    var id = {};
    Ye(id, { AnyNull: () => X.AnyNull, DMMF: () => _t, DbNull: () => X.DbNull, Debug: () => Y, Decimal: () => tu.Decimal, Extensions: () => An, JsonNull: () => X.JsonNull, NullTypes: () => X.NullTypes, ObjectEnumValue: () => X.ObjectEnumValue, PrismaClientInitializationError: () => D.PrismaClientInitializationError, PrismaClientKnownRequestError: () => D.PrismaClientKnownRequestError, PrismaClientRustPanicError: () => D.PrismaClientRustPanicError, PrismaClientUnknownRequestError: () => D.PrismaClientUnknownRequestError, PrismaClientValidationError: () => D.PrismaClientValidationError, Public: () => vn, Sql: () => Te.Sql, createParam: () => Yo, defineDmmfProperty: () => ns, deserializeJsonResponse: () => De, deserializeRawResult: () => hn, dmmfToRuntimeDataModel: () => to, empty: () => Te.empty, getPrismaClient: () => Yl, getRuntime: () => eu, isAnyNull: () => X.isAnyNull, isDbNull: () => X.isDbNull, isJsonNull: () => X.isJsonNull, join: () => Te.join, makeStrictEnum: () => Xl, makeTypedQueryFactory: () => is, raw: () => Te.raw, serializeJsonQuery: () => _r, skip: () => Lr, sqltag: () => Te.sql, warnOnce: () => Ln });
    module.exports = $i(id);
    l();
    u();
    c2();
    p();
    m();
    var An = {};
    Ye(An, { defineExtension: () => Zi, getExtensionContext: () => Yi });
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function Zi(e3) {
      return typeof e3 == "function" ? e3 : (t2) => t2.$extends(e3);
    }
    l();
    u();
    c2();
    p();
    m();
    function Yi(e3) {
      return e3;
    }
    var vn = {};
    Ye(vn, { validator: () => Xi });
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function Xi(...e3) {
      return (t2) => t2;
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var he = class {
      _map = /* @__PURE__ */ new Map();
      get(t2) {
        return this._map.get(t2)?.value;
      }
      set(t2, r3) {
        this._map.set(t2, { value: r3 });
      }
      getOrCreate(t2, r3) {
        let n2 = this._map.get(t2);
        if (n2)
          return n2.value;
        let i = r3();
        return this.set(t2, i), i;
      }
    };
    l();
    u();
    c2();
    p();
    m();
    function Ie(e3) {
      return e3.substring(0, 1).toLowerCase() + e3.substring(1);
    }
    l();
    u();
    c2();
    p();
    m();
    function eo(e3, t2) {
      let r3 = {};
      for (let n2 of e3) {
        let i = n2[t2];
        r3[i] = n2;
      }
      return r3;
    }
    l();
    u();
    c2();
    p();
    m();
    function St(e3) {
      let t2;
      return { get() {
        return t2 || (t2 = { value: e3() }), t2.value;
      } };
    }
    l();
    u();
    c2();
    p();
    m();
    function to(e3) {
      return { models: Cn(e3.models), enums: Cn(e3.enums), types: Cn(e3.types) };
    }
    function Cn(e3) {
      let t2 = {};
      for (let { name: r3, ...n2 } of e3)
        t2[r3] = n2;
      return t2;
    }
    var ke = require_dist();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var Sn;
    var ro;
    var no;
    var io;
    var oo = true;
    typeof g < "u" && ({ FORCE_COLOR: Sn, NODE_DISABLE_COLORS: ro, NO_COLOR: no, TERM: io } = g.env || {}, oo = g.stdout && g.stdout.isTTY);
    var bu = { enabled: !ro && no == null && io !== "dumb" && (Sn != null && Sn !== "0" || oo) };
    function U(e3, t2) {
      let r3 = new RegExp(`\\x1b\\[${t2}m`, "g"), n2 = `\x1B[${e3}m`, i = `\x1B[${t2}m`;
      return function(o2) {
        return !bu.enabled || o2 == null ? o2 : n2 + (~("" + o2).indexOf(i) ? o2.replace(r3, i + n2) : o2) + i;
      };
    }
    var Jf = U(0, 0);
    var fr = U(1, 22);
    var gr = U(2, 22);
    var Wf = U(3, 23);
    var yr = U(4, 24);
    var Gf = U(7, 27);
    var Kf = U(8, 28);
    var zf = U(9, 29);
    var Zf = U(30, 39);
    var tt = U(31, 39);
    var so = U(32, 39);
    var ao = U(33, 39);
    var lo = U(34, 39);
    var Yf = U(35, 39);
    var uo = U(36, 39);
    var Xf = U(37, 39);
    var co = U(90, 39);
    var eg = U(90, 39);
    var tg = U(40, 49);
    var rg = U(41, 49);
    var ng = U(42, 49);
    var ig = U(43, 49);
    var og = U(44, 49);
    var sg = U(45, 49);
    var ag = U(46, 49);
    var lg = U(47, 49);
    l();
    u();
    c2();
    p();
    m();
    var xu = 100;
    var po = ["green", "yellow", "blue", "magenta", "cyan", "red"];
    var Rt = [];
    var mo = Date.now();
    var Eu = 0;
    var Rn = typeof g < "u" ? g.env : {};
    globalThis.DEBUG ??= Rn.DEBUG ?? "";
    globalThis.DEBUG_COLORS ??= Rn.DEBUG_COLORS ? Rn.DEBUG_COLORS === "true" : true;
    var It = { enable(e3) {
      typeof e3 == "string" && (globalThis.DEBUG = e3);
    }, disable() {
      let e3 = globalThis.DEBUG;
      return globalThis.DEBUG = "", e3;
    }, enabled(e3) {
      let t2 = globalThis.DEBUG.split(",").map((i) => i.replace(/[.+?^${}()|[\]\\]/g, "\\$&")), r3 = t2.some((i) => i === "" || i[0] === "-" ? false : e3.match(RegExp(i.split("*").join(".*") + "$"))), n2 = t2.some((i) => i === "" || i[0] !== "-" ? false : e3.match(RegExp(i.slice(1).split("*").join(".*") + "$")));
      return r3 && !n2;
    }, log: (...e3) => {
      let [t2, r3, ...n2] = e3;
      (console.warn ?? console.log)(`${t2} ${r3}`, ...n2);
    }, formatters: {} };
    function Tu(e3) {
      let t2 = { color: po[Eu++ % po.length], enabled: It.enabled(e3), namespace: e3, log: It.log, extend: () => {
      } }, r3 = (...n2) => {
        let { enabled: i, namespace: o2, color: s3, log: a } = t2;
        if (n2.length !== 0 && Rt.push([o2, ...n2]), Rt.length > xu && Rt.shift(), It.enabled(o2) || i) {
          let d = n2.map((P) => typeof P == "string" ? P : Pu(P)), f = `+${Date.now() - mo}ms`;
          mo = Date.now(), a(o2, ...d, f);
        }
      };
      return new Proxy(r3, { get: (n2, i) => t2[i], set: (n2, i, o2) => t2[i] = o2 });
    }
    var Y = new Proxy(Tu, { get: (e3, t2) => It[t2], set: (e3, t2, r3) => It[t2] = r3 });
    function Pu(e3, t2 = 2) {
      let r3 = /* @__PURE__ */ new Set();
      return JSON.stringify(e3, (n2, i) => {
        if (typeof i == "object" && i !== null) {
          if (r3.has(i))
            return "[Circular *]";
          r3.add(i);
        } else if (typeof i == "bigint")
          return i.toString();
        return i;
      }, t2);
    }
    function fo(e3 = 7500) {
      let t2 = Rt.map(([r3, ...n2]) => `${r3} ${n2.map((i) => typeof i == "string" ? i : JSON.stringify(i)).join(" ")}`).join(`
`);
      return t2.length < e3 ? t2 : t2.slice(-e3);
    }
    function go() {
      Rt.length = 0;
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var xo = "prisma+postgres";
    var xr = `${xo}:`;
    function Eo(e3) {
      return e3?.toString().startsWith(`${xr}//`) ?? false;
    }
    function On(e3) {
      if (!Eo(e3))
        return false;
      let { host: t2 } = new URL(e3);
      return t2.includes("localhost") || t2.includes("127.0.0.1") || t2.includes("[::1]");
    }
    var Dt = {};
    Ye(Dt, { error: () => Su, info: () => Cu, log: () => vu, query: () => Ru, should: () => Ao, tags: () => Mt, warn: () => kn });
    l();
    u();
    c2();
    p();
    m();
    var Mt = { error: tt("prisma:error"), warn: ao("prisma:warn"), info: uo("prisma:info"), query: lo("prisma:query") };
    var Ao = { warn: () => !g.env.PRISMA_DISABLE_WARNINGS };
    function vu(...e3) {
      console.log(...e3);
    }
    function kn(e3, ...t2) {
      Ao.warn() && console.warn(`${Mt.warn} ${e3}`, ...t2);
    }
    function Cu(e3, ...t2) {
      console.info(`${Mt.info} ${e3}`, ...t2);
    }
    function Su(e3, ...t2) {
      console.error(`${Mt.error} ${e3}`, ...t2);
    }
    function Ru(e3, ...t2) {
      console.log(`${Mt.query} ${e3}`, ...t2);
    }
    l();
    u();
    c2();
    p();
    m();
    function ve(e3, t2) {
      throw new Error(t2);
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function Mn({ onlyFirst: e3 = false } = {}) {
      let r3 = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?(?:\\u0007|\\u001B\\u005C|\\u009C))", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))"].join("|");
      return new RegExp(r3, e3 ? void 0 : "g");
    }
    var Iu = Mn();
    function nt(e3) {
      if (typeof e3 != "string")
        throw new TypeError(`Expected a \`string\`, got \`${typeof e3}\``);
      return e3.replace(Iu, "");
    }
    l();
    u();
    c2();
    p();
    m();
    function Dn(e3, t2) {
      return Object.prototype.hasOwnProperty.call(e3, t2);
    }
    l();
    u();
    c2();
    p();
    m();
    function Tr(e3, t2) {
      let r3 = {};
      for (let n2 of Object.keys(e3))
        r3[n2] = t2(e3[n2], n2);
      return r3;
    }
    l();
    u();
    c2();
    p();
    m();
    function Nn(e3, t2) {
      if (e3.length === 0)
        return;
      let r3 = e3[0];
      for (let n2 = 1; n2 < e3.length; n2++)
        t2(r3, e3[n2]) < 0 && (r3 = e3[n2]);
      return r3;
    }
    l();
    u();
    c2();
    p();
    m();
    function Nt(e3, t2) {
      Object.defineProperty(e3, "name", { value: t2, configurable: true });
    }
    l();
    u();
    c2();
    p();
    m();
    var Co = /* @__PURE__ */ new Set();
    var Ln = (e3, t2, ...r3) => {
      Co.has(e3) || (Co.add(e3), kn(t2, ...r3));
    };
    l();
    u();
    c2();
    p();
    m();
    function it(e3) {
      return e3 instanceof Date || Object.prototype.toString.call(e3) === "[object Date]";
    }
    function Pr(e3) {
      return e3.toString() !== "Invalid Date";
    }
    l();
    u();
    c2();
    p();
    m();
    var So = require_dist();
    function ot(e3) {
      return So.Decimal.isDecimal(e3) ? true : e3 !== null && typeof e3 == "object" && typeof e3.s == "number" && typeof e3.e == "number" && typeof e3.toFixed == "function" && Array.isArray(e3.d);
    }
    l();
    u();
    c2();
    p();
    m();
    var Jo = require_dist();
    l();
    u();
    c2();
    p();
    m();
    var _t = {};
    Ye(_t, { ModelAction: () => Lt, datamodelEnumToSchemaEnum: () => Ou, datamodelSchemaEnumToSchemaEnum: () => ku });
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function Ou(e3) {
      return { name: e3.name, data: e3.values.map((t2) => ({ key: t2.name, value: t2.dbName ?? t2.name })) };
    }
    function ku(e3) {
      return { name: e3.name, data: e3.values.map((t2) => ({ key: t2, value: t2 })) };
    }
    l();
    u();
    c2();
    p();
    m();
    var Lt = ((F) => (F.findUnique = "findUnique", F.findUniqueOrThrow = "findUniqueOrThrow", F.findFirst = "findFirst", F.findFirstOrThrow = "findFirstOrThrow", F.findMany = "findMany", F.create = "create", F.createMany = "createMany", F.createManyAndReturn = "createManyAndReturn", F.update = "update", F.updateMany = "updateMany", F.updateManyAndReturn = "updateManyAndReturn", F.upsert = "upsert", F.delete = "delete", F.deleteMany = "deleteMany", F.groupBy = "groupBy", F.count = "count", F.aggregate = "aggregate", F.findRaw = "findRaw", F.aggregateRaw = "aggregateRaw", F))(Lt || {});
    var Mu = Ue(Po());
    var Du = { red: tt, gray: co, dim: gr, bold: fr, underline: yr, highlightSource: (e3) => e3.highlight() };
    var Nu = { red: (e3) => e3, gray: (e3) => e3, dim: (e3) => e3, bold: (e3) => e3, underline: (e3) => e3, highlightSource: (e3) => e3 };
    function Lu({ message: e3, originalMethod: t2, isPanic: r3, callArguments: n2 }) {
      return { functionName: `prisma.${t2}()`, message: e3, isPanic: r3 ?? false, callArguments: n2 };
    }
    function _u({ functionName: e3, location: t2, message: r3, isPanic: n2, contextLines: i, callArguments: o2 }, s3) {
      let a = [""], d = t2 ? " in" : ":";
      if (n2 ? (a.push(s3.red(`Oops, an unknown error occurred! This is ${s3.bold("on us")}, you did nothing wrong.`)), a.push(s3.red(`It occurred in the ${s3.bold(`\`${e3}\``)} invocation${d}`))) : a.push(s3.red(`Invalid ${s3.bold(`\`${e3}\``)} invocation${d}`)), t2 && a.push(s3.underline(Fu(t2))), i) {
        a.push("");
        let f = [i.toString()];
        o2 && (f.push(o2), f.push(s3.dim(")"))), a.push(f.join("")), o2 && a.push("");
      } else
        a.push(""), o2 && a.push(o2), a.push("");
      return a.push(r3), a.join(`
`);
    }
    function Fu(e3) {
      let t2 = [e3.fileName];
      return e3.lineNumber && t2.push(String(e3.lineNumber)), e3.columnNumber && t2.push(String(e3.columnNumber)), t2.join(":");
    }
    function Ar(e3) {
      let t2 = e3.showColors ? Du : Nu, r3;
      return typeof $getTemplateParameters < "u" ? r3 = $getTemplateParameters(e3, t2) : r3 = Lu(e3), _u(r3, t2);
    }
    l();
    u();
    c2();
    p();
    m();
    var _o = Ue(_n());
    l();
    u();
    c2();
    p();
    m();
    function ko(e3, t2, r3) {
      let n2 = Mo(e3), i = Uu(n2), o2 = qu(i);
      o2 ? vr(o2, t2, r3) : t2.addErrorMessage(() => "Unknown error");
    }
    function Mo(e3) {
      return e3.errors.flatMap((t2) => t2.kind === "Union" ? Mo(t2) : [t2]);
    }
    function Uu(e3) {
      let t2 = /* @__PURE__ */ new Map(), r3 = [];
      for (let n2 of e3) {
        if (n2.kind !== "InvalidArgumentType") {
          r3.push(n2);
          continue;
        }
        let i = `${n2.selectionPath.join(".")}:${n2.argumentPath.join(".")}`, o2 = t2.get(i);
        o2 ? t2.set(i, { ...n2, argument: { ...n2.argument, typeNames: $u(o2.argument.typeNames, n2.argument.typeNames) } }) : t2.set(i, n2);
      }
      return r3.push(...t2.values()), r3;
    }
    function $u(e3, t2) {
      return [...new Set(e3.concat(t2))];
    }
    function qu(e3) {
      return Nn(e3, (t2, r3) => {
        let n2 = Io(t2), i = Io(r3);
        return n2 !== i ? n2 - i : Oo(t2) - Oo(r3);
      });
    }
    function Io(e3) {
      let t2 = 0;
      return Array.isArray(e3.selectionPath) && (t2 += e3.selectionPath.length), Array.isArray(e3.argumentPath) && (t2 += e3.argumentPath.length), t2;
    }
    function Oo(e3) {
      switch (e3.kind) {
        case "InvalidArgumentValue":
        case "ValueTooLarge":
          return 20;
        case "InvalidArgumentType":
          return 10;
        case "RequiredArgumentMissing":
          return -10;
        default:
          return 0;
      }
    }
    l();
    u();
    c2();
    p();
    m();
    var ae = class {
      constructor(t2, r3) {
        this.name = t2;
        this.value = r3;
      }
      isRequired = false;
      makeRequired() {
        return this.isRequired = true, this;
      }
      write(t2) {
        let { colors: { green: r3 } } = t2.context;
        t2.addMarginSymbol(r3(this.isRequired ? "+" : "?")), t2.write(r3(this.name)), this.isRequired || t2.write(r3("?")), t2.write(r3(": ")), typeof this.value == "string" ? t2.write(r3(this.value)) : t2.write(this.value);
      }
    };
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    No();
    l();
    u();
    c2();
    p();
    m();
    var st = class {
      constructor(t2 = 0, r3) {
        this.context = r3;
        this.currentIndent = t2;
      }
      lines = [];
      currentLine = "";
      currentIndent = 0;
      marginSymbol;
      afterNextNewLineCallback;
      write(t2) {
        return typeof t2 == "string" ? this.currentLine += t2 : t2.write(this), this;
      }
      writeJoined(t2, r3, n2 = (i, o2) => o2.write(i)) {
        let i = r3.length - 1;
        for (let o2 = 0; o2 < r3.length; o2++)
          n2(r3[o2], this), o2 !== i && this.write(t2);
        return this;
      }
      writeLine(t2) {
        return this.write(t2).newLine();
      }
      newLine() {
        this.lines.push(this.indentedCurrentLine()), this.currentLine = "", this.marginSymbol = void 0;
        let t2 = this.afterNextNewLineCallback;
        return this.afterNextNewLineCallback = void 0, t2?.(), this;
      }
      withIndent(t2) {
        return this.indent(), t2(this), this.unindent(), this;
      }
      afterNextNewline(t2) {
        return this.afterNextNewLineCallback = t2, this;
      }
      indent() {
        return this.currentIndent++, this;
      }
      unindent() {
        return this.currentIndent > 0 && this.currentIndent--, this;
      }
      addMarginSymbol(t2) {
        return this.marginSymbol = t2, this;
      }
      toString() {
        return this.lines.concat(this.indentedCurrentLine()).join(`
`);
      }
      getCurrentLineLength() {
        return this.currentLine.length;
      }
      indentedCurrentLine() {
        let t2 = this.currentLine.padStart(this.currentLine.length + 2 * this.currentIndent);
        return this.marginSymbol ? this.marginSymbol + t2.slice(1) : t2;
      }
    };
    Do();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var Cr = class {
      constructor(t2) {
        this.value = t2;
      }
      write(t2) {
        t2.write(this.value);
      }
      markAsError() {
        this.value.markAsError();
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var Sr = (e3) => e3;
    var Rr = { bold: Sr, red: Sr, green: Sr, dim: Sr, enabled: false };
    var Lo = { bold: fr, red: tt, green: so, dim: gr, enabled: true };
    var at = { write(e3) {
      e3.writeLine(",");
    } };
    l();
    u();
    c2();
    p();
    m();
    var we = class {
      constructor(t2) {
        this.contents = t2;
      }
      isUnderlined = false;
      color = (t2) => t2;
      underline() {
        return this.isUnderlined = true, this;
      }
      setColor(t2) {
        return this.color = t2, this;
      }
      write(t2) {
        let r3 = t2.getCurrentLineLength();
        t2.write(this.color(this.contents)), this.isUnderlined && t2.afterNextNewline(() => {
          t2.write(" ".repeat(r3)).writeLine(this.color("~".repeat(this.contents.length)));
        });
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var Oe = class {
      hasError = false;
      markAsError() {
        return this.hasError = true, this;
      }
    };
    var lt = class extends Oe {
      items = [];
      addItem(t2) {
        return this.items.push(new Cr(t2)), this;
      }
      getField(t2) {
        return this.items[t2];
      }
      getPrintWidth() {
        return this.items.length === 0 ? 2 : Math.max(...this.items.map((r3) => r3.value.getPrintWidth())) + 2;
      }
      write(t2) {
        if (this.items.length === 0) {
          this.writeEmpty(t2);
          return;
        }
        this.writeWithItems(t2);
      }
      writeEmpty(t2) {
        let r3 = new we("[]");
        this.hasError && r3.setColor(t2.context.colors.red).underline(), t2.write(r3);
      }
      writeWithItems(t2) {
        let { colors: r3 } = t2.context;
        t2.writeLine("[").withIndent(() => t2.writeJoined(at, this.items).newLine()).write("]"), this.hasError && t2.afterNextNewline(() => {
          t2.writeLine(r3.red("~".repeat(this.getPrintWidth())));
        });
      }
      asObject() {
      }
    };
    var ut = class e3 extends Oe {
      fields = {};
      suggestions = [];
      addField(t2) {
        this.fields[t2.name] = t2;
      }
      addSuggestion(t2) {
        this.suggestions.push(t2);
      }
      getField(t2) {
        return this.fields[t2];
      }
      getDeepField(t2) {
        let [r3, ...n2] = t2, i = this.getField(r3);
        if (!i)
          return;
        let o2 = i;
        for (let s3 of n2) {
          let a;
          if (o2.value instanceof e3 ? a = o2.value.getField(s3) : o2.value instanceof lt && (a = o2.value.getField(Number(s3))), !a)
            return;
          o2 = a;
        }
        return o2;
      }
      getDeepFieldValue(t2) {
        return t2.length === 0 ? this : this.getDeepField(t2)?.value;
      }
      hasField(t2) {
        return !!this.getField(t2);
      }
      removeAllFields() {
        this.fields = {};
      }
      removeField(t2) {
        delete this.fields[t2];
      }
      getFields() {
        return this.fields;
      }
      isEmpty() {
        return Object.keys(this.fields).length === 0;
      }
      getFieldValue(t2) {
        return this.getField(t2)?.value;
      }
      getDeepSubSelectionValue(t2) {
        let r3 = this;
        for (let n2 of t2) {
          if (!(r3 instanceof e3))
            return;
          let i = r3.getSubSelectionValue(n2);
          if (!i)
            return;
          r3 = i;
        }
        return r3;
      }
      getDeepSelectionParent(t2) {
        let r3 = this.getSelectionParent();
        if (!r3)
          return;
        let n2 = r3;
        for (let i of t2) {
          let o2 = n2.value.getFieldValue(i);
          if (!o2 || !(o2 instanceof e3))
            return;
          let s3 = o2.getSelectionParent();
          if (!s3)
            return;
          n2 = s3;
        }
        return n2;
      }
      getSelectionParent() {
        let t2 = this.getField("select")?.value.asObject();
        if (t2)
          return { kind: "select", value: t2 };
        let r3 = this.getField("include")?.value.asObject();
        if (r3)
          return { kind: "include", value: r3 };
      }
      getSubSelectionValue(t2) {
        return this.getSelectionParent()?.value.fields[t2].value;
      }
      getPrintWidth() {
        let t2 = Object.values(this.fields);
        return t2.length == 0 ? 2 : Math.max(...t2.map((n2) => n2.getPrintWidth())) + 2;
      }
      write(t2) {
        let r3 = Object.values(this.fields);
        if (r3.length === 0 && this.suggestions.length === 0) {
          this.writeEmpty(t2);
          return;
        }
        this.writeWithContents(t2, r3);
      }
      asObject() {
        return this;
      }
      writeEmpty(t2) {
        let r3 = new we("{}");
        this.hasError && r3.setColor(t2.context.colors.red).underline(), t2.write(r3);
      }
      writeWithContents(t2, r3) {
        t2.writeLine("{").withIndent(() => {
          t2.writeJoined(at, [...r3, ...this.suggestions]).newLine();
        }), t2.write("}"), this.hasError && t2.afterNextNewline(() => {
          t2.writeLine(t2.context.colors.red("~".repeat(this.getPrintWidth())));
        });
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var K = class extends Oe {
      constructor(r3) {
        super();
        this.text = r3;
      }
      getPrintWidth() {
        return this.text.length;
      }
      write(r3) {
        let n2 = new we(this.text);
        this.hasError && n2.underline().setColor(r3.context.colors.red), r3.write(n2);
      }
      asObject() {
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var Ft = class {
      fields = [];
      addField(t2, r3) {
        return this.fields.push({ write(n2) {
          let { green: i, dim: o2 } = n2.context.colors;
          n2.write(i(o2(`${t2}: ${r3}`))).addMarginSymbol(i(o2("+")));
        } }), this;
      }
      write(t2) {
        let { colors: { green: r3 } } = t2.context;
        t2.writeLine(r3("{")).withIndent(() => {
          t2.writeJoined(at, this.fields).newLine();
        }).write(r3("}")).addMarginSymbol(r3("+"));
      }
    };
    function vr(e3, t2, r3) {
      switch (e3.kind) {
        case "MutuallyExclusiveFields":
          Vu(e3, t2);
          break;
        case "IncludeOnScalar":
          Bu(e3, t2);
          break;
        case "EmptySelection":
          ju(e3, t2, r3);
          break;
        case "UnknownSelectionField":
          Wu(e3, t2);
          break;
        case "InvalidSelectionValue":
          Gu(e3, t2);
          break;
        case "UnknownArgument":
          Ku(e3, t2);
          break;
        case "UnknownInputField":
          zu(e3, t2);
          break;
        case "RequiredArgumentMissing":
          Zu(e3, t2);
          break;
        case "InvalidArgumentType":
          Yu(e3, t2);
          break;
        case "InvalidArgumentValue":
          Xu(e3, t2);
          break;
        case "ValueTooLarge":
          ec(e3, t2);
          break;
        case "SomeFieldsMissing":
          tc(e3, t2);
          break;
        case "TooManyFieldsGiven":
          rc(e3, t2);
          break;
        case "Union":
          ko(e3, t2, r3);
          break;
        default:
          throw new Error("not implemented: " + e3.kind);
      }
    }
    function Vu(e3, t2) {
      let r3 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      r3 && (r3.getField(e3.firstField)?.markAsError(), r3.getField(e3.secondField)?.markAsError()), t2.addErrorMessage((n2) => `Please ${n2.bold("either")} use ${n2.green(`\`${e3.firstField}\``)} or ${n2.green(`\`${e3.secondField}\``)}, but ${n2.red("not both")} at the same time.`);
    }
    function Bu(e3, t2) {
      let [r3, n2] = ct(e3.selectionPath), i = e3.outputType, o2 = t2.arguments.getDeepSelectionParent(r3)?.value;
      if (o2 && (o2.getField(n2)?.markAsError(), i))
        for (let s3 of i.fields)
          s3.isRelation && o2.addSuggestion(new ae(s3.name, "true"));
      t2.addErrorMessage((s3) => {
        let a = `Invalid scalar field ${s3.red(`\`${n2}\``)} for ${s3.bold("include")} statement`;
        return i ? a += ` on model ${s3.bold(i.name)}. ${Ut(s3)}` : a += ".", a += `
Note that ${s3.bold("include")} statements only accept relation fields.`, a;
      });
    }
    function ju(e3, t2, r3) {
      let n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      if (n2) {
        let i = n2.getField("omit")?.value.asObject();
        if (i) {
          Qu(e3, t2, i);
          return;
        }
        if (n2.hasField("select")) {
          Hu(e3, t2);
          return;
        }
      }
      if (r3?.[Ie(e3.outputType.name)]) {
        Ju(e3, t2);
        return;
      }
      t2.addErrorMessage(() => `Unknown field at "${e3.selectionPath.join(".")} selection"`);
    }
    function Qu(e3, t2, r3) {
      r3.removeAllFields();
      for (let n2 of e3.outputType.fields)
        r3.addSuggestion(new ae(n2.name, "false"));
      t2.addErrorMessage((n2) => `The ${n2.red("omit")} statement includes every field of the model ${n2.bold(e3.outputType.name)}. At least one field must be included in the result`);
    }
    function Hu(e3, t2) {
      let r3 = e3.outputType, n2 = t2.arguments.getDeepSelectionParent(e3.selectionPath)?.value, i = n2?.isEmpty() ?? false;
      n2 && (n2.removeAllFields(), $o(n2, r3)), t2.addErrorMessage((o2) => i ? `The ${o2.red("`select`")} statement for type ${o2.bold(r3.name)} must not be empty. ${Ut(o2)}` : `The ${o2.red("`select`")} statement for type ${o2.bold(r3.name)} needs ${o2.bold("at least one truthy value")}.`);
    }
    function Ju(e3, t2) {
      let r3 = new Ft();
      for (let i of e3.outputType.fields)
        i.isRelation || r3.addField(i.name, "false");
      let n2 = new ae("omit", r3).makeRequired();
      if (e3.selectionPath.length === 0)
        t2.arguments.addSuggestion(n2);
      else {
        let [i, o2] = ct(e3.selectionPath), a = t2.arguments.getDeepSelectionParent(i)?.value.asObject()?.getField(o2);
        if (a) {
          let d = a?.value.asObject() ?? new ut();
          d.addSuggestion(n2), a.value = d;
        }
      }
      t2.addErrorMessage((i) => `The global ${i.red("omit")} configuration excludes every field of the model ${i.bold(e3.outputType.name)}. At least one field must be included in the result`);
    }
    function Wu(e3, t2) {
      let r3 = qo(e3.selectionPath, t2);
      if (r3.parentKind !== "unknown") {
        r3.field.markAsError();
        let n2 = r3.parent;
        switch (r3.parentKind) {
          case "select":
            $o(n2, e3.outputType);
            break;
          case "include":
            nc(n2, e3.outputType);
            break;
          case "omit":
            ic(n2, e3.outputType);
            break;
        }
      }
      t2.addErrorMessage((n2) => {
        let i = [`Unknown field ${n2.red(`\`${r3.fieldName}\``)}`];
        return r3.parentKind !== "unknown" && i.push(`for ${n2.bold(r3.parentKind)} statement`), i.push(`on model ${n2.bold(`\`${e3.outputType.name}\``)}.`), i.push(Ut(n2)), i.join(" ");
      });
    }
    function Gu(e3, t2) {
      let r3 = qo(e3.selectionPath, t2);
      r3.parentKind !== "unknown" && r3.field.value.markAsError(), t2.addErrorMessage((n2) => `Invalid value for selection field \`${n2.red(r3.fieldName)}\`: ${e3.underlyingError}`);
    }
    function Ku(e3, t2) {
      let r3 = e3.argumentPath[0], n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      n2 && (n2.getField(r3)?.markAsError(), oc(n2, e3.arguments)), t2.addErrorMessage((i) => Fo(i, r3, e3.arguments.map((o2) => o2.name)));
    }
    function zu(e3, t2) {
      let [r3, n2] = ct(e3.argumentPath), i = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      if (i) {
        i.getDeepField(e3.argumentPath)?.markAsError();
        let o2 = i.getDeepFieldValue(r3)?.asObject();
        o2 && Vo(o2, e3.inputType);
      }
      t2.addErrorMessage((o2) => Fo(o2, n2, e3.inputType.fields.map((s3) => s3.name)));
    }
    function Fo(e3, t2, r3) {
      let n2 = [`Unknown argument \`${e3.red(t2)}\`.`], i = ac(t2, r3);
      return i && n2.push(`Did you mean \`${e3.green(i)}\`?`), r3.length > 0 && n2.push(Ut(e3)), n2.join(" ");
    }
    function Zu(e3, t2) {
      let r3;
      t2.addErrorMessage((d) => r3?.value instanceof K && r3.value.text === "null" ? `Argument \`${d.green(o2)}\` must not be ${d.red("null")}.` : `Argument \`${d.green(o2)}\` is missing.`);
      let n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      if (!n2)
        return;
      let [i, o2] = ct(e3.argumentPath), s3 = new Ft(), a = n2.getDeepFieldValue(i)?.asObject();
      if (a) {
        if (r3 = a.getField(o2), r3 && a.removeField(o2), e3.inputTypes.length === 1 && e3.inputTypes[0].kind === "object") {
          for (let d of e3.inputTypes[0].fields)
            s3.addField(d.name, d.typeNames.join(" | "));
          a.addSuggestion(new ae(o2, s3).makeRequired());
        } else {
          let d = e3.inputTypes.map(Uo).join(" | ");
          a.addSuggestion(new ae(o2, d).makeRequired());
        }
        if (e3.dependentArgumentPath) {
          n2.getDeepField(e3.dependentArgumentPath)?.markAsError();
          let [, d] = ct(e3.dependentArgumentPath);
          t2.addErrorMessage((f) => `Argument \`${f.green(o2)}\` is required because argument \`${f.green(d)}\` was provided.`);
        }
      }
    }
    function Uo(e3) {
      return e3.kind === "list" ? `${Uo(e3.elementType)}[]` : e3.name;
    }
    function Yu(e3, t2) {
      let r3 = e3.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      n2 && n2.getDeepFieldValue(e3.argumentPath)?.markAsError(), t2.addErrorMessage((i) => {
        let o2 = Ir("or", e3.argument.typeNames.map((s3) => i.green(s3)));
        return `Argument \`${i.bold(r3)}\`: Invalid value provided. Expected ${o2}, provided ${i.red(e3.inferredType)}.`;
      });
    }
    function Xu(e3, t2) {
      let r3 = e3.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      n2 && n2.getDeepFieldValue(e3.argumentPath)?.markAsError(), t2.addErrorMessage((i) => {
        let o2 = [`Invalid value for argument \`${i.bold(r3)}\``];
        if (e3.underlyingError && o2.push(`: ${e3.underlyingError}`), o2.push("."), e3.argument.typeNames.length > 0) {
          let s3 = Ir("or", e3.argument.typeNames.map((a) => i.green(a)));
          o2.push(` Expected ${s3}.`);
        }
        return o2.join("");
      });
    }
    function ec(e3, t2) {
      let r3 = e3.argument.name, n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject(), i;
      if (n2) {
        let s3 = n2.getDeepField(e3.argumentPath)?.value;
        s3?.markAsError(), s3 instanceof K && (i = s3.text);
      }
      t2.addErrorMessage((o2) => {
        let s3 = ["Unable to fit value"];
        return i && s3.push(o2.red(i)), s3.push(`into a 64-bit signed integer for field \`${o2.bold(r3)}\``), s3.join(" ");
      });
    }
    function tc(e3, t2) {
      let r3 = e3.argumentPath[e3.argumentPath.length - 1], n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject();
      if (n2) {
        let i = n2.getDeepFieldValue(e3.argumentPath)?.asObject();
        i && Vo(i, e3.inputType);
      }
      t2.addErrorMessage((i) => {
        let o2 = [`Argument \`${i.bold(r3)}\` of type ${i.bold(e3.inputType.name)} needs`];
        return e3.constraints.minFieldCount === 1 ? e3.constraints.requiredFields ? o2.push(`${i.green("at least one of")} ${Ir("or", e3.constraints.requiredFields.map((s3) => `\`${i.bold(s3)}\``))} arguments.`) : o2.push(`${i.green("at least one")} argument.`) : o2.push(`${i.green(`at least ${e3.constraints.minFieldCount}`)} arguments.`), o2.push(Ut(i)), o2.join(" ");
      });
    }
    function rc(e3, t2) {
      let r3 = e3.argumentPath[e3.argumentPath.length - 1], n2 = t2.arguments.getDeepSubSelectionValue(e3.selectionPath)?.asObject(), i = [];
      if (n2) {
        let o2 = n2.getDeepFieldValue(e3.argumentPath)?.asObject();
        o2 && (o2.markAsError(), i = Object.keys(o2.getFields()));
      }
      t2.addErrorMessage((o2) => {
        let s3 = [`Argument \`${o2.bold(r3)}\` of type ${o2.bold(e3.inputType.name)} needs`];
        return e3.constraints.minFieldCount === 1 && e3.constraints.maxFieldCount == 1 ? s3.push(`${o2.green("exactly one")} argument,`) : e3.constraints.maxFieldCount == 1 ? s3.push(`${o2.green("at most one")} argument,`) : s3.push(`${o2.green(`at most ${e3.constraints.maxFieldCount}`)} arguments,`), s3.push(`but you provided ${Ir("and", i.map((a) => o2.red(a)))}. Please choose`), e3.constraints.maxFieldCount === 1 ? s3.push("one.") : s3.push(`${e3.constraints.maxFieldCount}.`), s3.join(" ");
      });
    }
    function $o(e3, t2) {
      for (let r3 of t2.fields)
        e3.hasField(r3.name) || e3.addSuggestion(new ae(r3.name, "true"));
    }
    function nc(e3, t2) {
      for (let r3 of t2.fields)
        r3.isRelation && !e3.hasField(r3.name) && e3.addSuggestion(new ae(r3.name, "true"));
    }
    function ic(e3, t2) {
      for (let r3 of t2.fields)
        !e3.hasField(r3.name) && !r3.isRelation && e3.addSuggestion(new ae(r3.name, "true"));
    }
    function oc(e3, t2) {
      for (let r3 of t2)
        e3.hasField(r3.name) || e3.addSuggestion(new ae(r3.name, r3.typeNames.join(" | ")));
    }
    function qo(e3, t2) {
      let [r3, n2] = ct(e3), i = t2.arguments.getDeepSubSelectionValue(r3)?.asObject();
      if (!i)
        return { parentKind: "unknown", fieldName: n2 };
      let o2 = i.getFieldValue("select")?.asObject(), s3 = i.getFieldValue("include")?.asObject(), a = i.getFieldValue("omit")?.asObject(), d = o2?.getField(n2);
      return o2 && d ? { parentKind: "select", parent: o2, field: d, fieldName: n2 } : (d = s3?.getField(n2), s3 && d ? { parentKind: "include", field: d, parent: s3, fieldName: n2 } : (d = a?.getField(n2), a && d ? { parentKind: "omit", field: d, parent: a, fieldName: n2 } : { parentKind: "unknown", fieldName: n2 }));
    }
    function Vo(e3, t2) {
      if (t2.kind === "object")
        for (let r3 of t2.fields)
          e3.hasField(r3.name) || e3.addSuggestion(new ae(r3.name, r3.typeNames.join(" | ")));
    }
    function ct(e3) {
      let t2 = [...e3], r3 = t2.pop();
      if (!r3)
        throw new Error("unexpected empty path");
      return [t2, r3];
    }
    function Ut({ green: e3, enabled: t2 }) {
      return "Available options are " + (t2 ? `listed in ${e3("green")}` : "marked with ?") + ".";
    }
    function Ir(e3, t2) {
      if (t2.length === 1)
        return t2[0];
      let r3 = [...t2], n2 = r3.pop();
      return `${r3.join(", ")} ${e3} ${n2}`;
    }
    var sc = 3;
    function ac(e3, t2) {
      let r3 = 1 / 0, n2;
      for (let i of t2) {
        let o2 = (0, _o.default)(e3, i);
        o2 > sc || o2 < r3 && (r3 = o2, n2 = i);
      }
      return n2;
    }
    l();
    u();
    c2();
    p();
    m();
    var jo = require_dist();
    l();
    u();
    c2();
    p();
    m();
    var $t = class {
      modelName;
      name;
      typeName;
      isList;
      isEnum;
      constructor(t2, r3, n2, i, o2) {
        this.modelName = t2, this.name = r3, this.typeName = n2, this.isList = i, this.isEnum = o2;
      }
      _toGraphQLInputType() {
        let t2 = this.isList ? "List" : "", r3 = this.isEnum ? "Enum" : "";
        return `${t2}${r3}${this.typeName}FieldRefInput<${this.modelName}>`;
      }
    };
    function pt(e3) {
      return e3 instanceof $t;
    }
    l();
    u();
    c2();
    p();
    m();
    var Bo = ": ";
    var Or = class {
      constructor(t2, r3) {
        this.name = t2;
        this.value = r3;
      }
      hasError = false;
      markAsError() {
        this.hasError = true;
      }
      getPrintWidth() {
        return this.name.length + this.value.getPrintWidth() + Bo.length;
      }
      write(t2) {
        let r3 = new we(this.name);
        this.hasError && r3.underline().setColor(t2.context.colors.red), t2.write(r3).write(Bo).write(this.value);
      }
    };
    var Un = class {
      arguments;
      errorMessages = [];
      constructor(t2) {
        this.arguments = t2;
      }
      write(t2) {
        t2.write(this.arguments);
      }
      addErrorMessage(t2) {
        this.errorMessages.push(t2);
      }
      renderAllMessages(t2) {
        return this.errorMessages.map((r3) => r3(t2)).join(`
`);
      }
    };
    function mt(e3) {
      return new Un(Qo(e3));
    }
    function Qo(e3) {
      let t2 = new ut();
      for (let [r3, n2] of Object.entries(e3)) {
        let i = new Or(r3, Ho(n2));
        t2.addField(i);
      }
      return t2;
    }
    function Ho(e3) {
      if (typeof e3 == "string")
        return new K(JSON.stringify(e3));
      if (typeof e3 == "number" || typeof e3 == "boolean")
        return new K(String(e3));
      if (typeof e3 == "bigint")
        return new K(`${e3}n`);
      if (e3 === null)
        return new K("null");
      if (e3 === void 0)
        return new K("undefined");
      if (ot(e3))
        return new K(`new Prisma.Decimal("${e3.toFixed()}")`);
      if (e3 instanceof Uint8Array)
        return y.isBuffer(e3) ? new K(`Buffer.alloc(${e3.byteLength})`) : new K(`new Uint8Array(${e3.byteLength})`);
      if (e3 instanceof Date) {
        let t2 = Pr(e3) ? e3.toISOString() : "Invalid Date";
        return new K(`new Date("${t2}")`);
      }
      return e3 instanceof jo.ObjectEnumValue ? new K(`Prisma.${e3._getName()}`) : pt(e3) ? new K(`prisma.${Ie(e3.modelName)}.$fields.${e3.name}`) : Array.isArray(e3) ? lc(e3) : typeof e3 == "object" ? Qo(e3) : new K(Object.prototype.toString.call(e3));
    }
    function lc(e3) {
      let t2 = new lt();
      for (let r3 of e3)
        t2.addItem(Ho(r3));
      return t2;
    }
    function kr(e3, t2) {
      let r3 = t2 === "pretty" ? Lo : Rr, n2 = e3.renderAllMessages(r3), i = new st(0, { colors: r3 }).write(e3).toString();
      return { message: n2, args: i };
    }
    function Mr({ args: e3, errors: t2, errorFormat: r3, callsite: n2, originalMethod: i, clientVersion: o2, globalOmit: s3 }) {
      let a = mt(e3);
      for (let A of t2)
        vr(A, a, s3);
      let { message: d, args: f } = kr(a, r3), P = Ar({ message: d, callsite: n2, originalMethod: i, showColors: r3 === "pretty", callArguments: f });
      throw new Jo.PrismaClientValidationError(P, { clientVersion: o2 });
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function be(e3) {
      return e3.replace(/^./, (t2) => t2.toLowerCase());
    }
    l();
    u();
    c2();
    p();
    m();
    function Go(e3, t2, r3) {
      let n2 = be(r3);
      return !t2.result || !(t2.result.$allModels || t2.result[n2]) ? e3 : uc({ ...e3, ...Wo(t2.name, e3, t2.result.$allModels), ...Wo(t2.name, e3, t2.result[n2]) });
    }
    function uc(e3) {
      let t2 = new he(), r3 = (n2, i) => t2.getOrCreate(n2, () => i.has(n2) ? [n2] : (i.add(n2), e3[n2] ? e3[n2].needs.flatMap((o2) => r3(o2, i)) : [n2]));
      return Tr(e3, (n2) => ({ ...n2, needs: r3(n2.name, /* @__PURE__ */ new Set()) }));
    }
    function Wo(e3, t2, r3) {
      return r3 ? Tr(r3, ({ needs: n2, compute: i }, o2) => ({ name: o2, needs: n2 ? Object.keys(n2).filter((s3) => n2[s3]) : [], compute: cc(t2, o2, i) })) : {};
    }
    function cc(e3, t2, r3) {
      let n2 = e3?.[t2]?.compute;
      return n2 ? (i) => r3({ ...i, [t2]: n2(i) }) : r3;
    }
    function Ko(e3, t2) {
      if (!t2)
        return e3;
      let r3 = { ...e3 };
      for (let n2 of Object.values(t2))
        if (e3[n2.name])
          for (let i of n2.needs)
            r3[i] = true;
      return r3;
    }
    function zo(e3, t2) {
      if (!t2)
        return e3;
      let r3 = { ...e3 };
      for (let n2 of Object.values(t2))
        if (!e3[n2.name])
          for (let i of n2.needs)
            delete r3[i];
      return r3;
    }
    var Dr = class {
      constructor(t2, r3) {
        this.extension = t2;
        this.previous = r3;
      }
      computedFieldsCache = new he();
      modelExtensionsCache = new he();
      queryCallbacksCache = new he();
      clientExtensions = St(() => this.extension.client ? { ...this.previous?.getAllClientExtensions(), ...this.extension.client } : this.previous?.getAllClientExtensions());
      batchCallbacks = St(() => {
        let t2 = this.previous?.getAllBatchQueryCallbacks() ?? [], r3 = this.extension.query?.$__internalBatch;
        return r3 ? t2.concat(r3) : t2;
      });
      getAllComputedFields(t2) {
        return this.computedFieldsCache.getOrCreate(t2, () => Go(this.previous?.getAllComputedFields(t2), this.extension, t2));
      }
      getAllClientExtensions() {
        return this.clientExtensions.get();
      }
      getAllModelExtensions(t2) {
        return this.modelExtensionsCache.getOrCreate(t2, () => {
          let r3 = be(t2);
          return !this.extension.model || !(this.extension.model[r3] || this.extension.model.$allModels) ? this.previous?.getAllModelExtensions(t2) : { ...this.previous?.getAllModelExtensions(t2), ...this.extension.model.$allModels, ...this.extension.model[r3] };
        });
      }
      getAllQueryCallbacks(t2, r3) {
        return this.queryCallbacksCache.getOrCreate(`${t2}:${r3}`, () => {
          let n2 = this.previous?.getAllQueryCallbacks(t2, r3) ?? [], i = [], o2 = this.extension.query;
          return !o2 || !(o2[t2] || o2.$allModels || o2[r3] || o2.$allOperations) ? n2 : (o2[t2] !== void 0 && (o2[t2][r3] !== void 0 && i.push(o2[t2][r3]), o2[t2].$allOperations !== void 0 && i.push(o2[t2].$allOperations)), t2 !== "$none" && o2.$allModels !== void 0 && (o2.$allModels[r3] !== void 0 && i.push(o2.$allModels[r3]), o2.$allModels.$allOperations !== void 0 && i.push(o2.$allModels.$allOperations)), o2[r3] !== void 0 && i.push(o2[r3]), o2.$allOperations !== void 0 && i.push(o2.$allOperations), n2.concat(i));
        });
      }
      getAllBatchQueryCallbacks() {
        return this.batchCallbacks.get();
      }
    };
    var dt = class e3 {
      constructor(t2) {
        this.head = t2;
      }
      static empty() {
        return new e3();
      }
      static single(t2) {
        return new e3(new Dr(t2));
      }
      isEmpty() {
        return this.head === void 0;
      }
      append(t2) {
        return new e3(new Dr(t2, this.head));
      }
      getAllComputedFields(t2) {
        return this.head?.getAllComputedFields(t2);
      }
      getAllClientExtensions() {
        return this.head?.getAllClientExtensions();
      }
      getAllModelExtensions(t2) {
        return this.head?.getAllModelExtensions(t2);
      }
      getAllQueryCallbacks(t2, r3) {
        return this.head?.getAllQueryCallbacks(t2, r3) ?? [];
      }
      getAllBatchQueryCallbacks() {
        return this.head?.getAllBatchQueryCallbacks() ?? [];
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var Nr = class {
      constructor(t2) {
        this.name = t2;
      }
    };
    function Zo(e3) {
      return e3 instanceof Nr;
    }
    function Yo(e3) {
      return new Nr(e3);
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var Xo = Symbol();
    var qt = class {
      constructor(t2) {
        if (t2 !== Xo)
          throw new Error("Skip instance can not be constructed directly");
      }
      ifUndefined(t2) {
        return t2 === void 0 ? Lr : t2;
      }
    };
    var Lr = new qt(Xo);
    function xe(e3) {
      return e3 instanceof qt;
    }
    var pc = { findUnique: "findUnique", findUniqueOrThrow: "findUniqueOrThrow", findFirst: "findFirst", findFirstOrThrow: "findFirstOrThrow", findMany: "findMany", count: "aggregate", create: "createOne", createMany: "createMany", createManyAndReturn: "createManyAndReturn", update: "updateOne", updateMany: "updateMany", updateManyAndReturn: "updateManyAndReturn", upsert: "upsertOne", delete: "deleteOne", deleteMany: "deleteMany", executeRaw: "executeRaw", queryRaw: "queryRaw", aggregate: "aggregate", groupBy: "groupBy", runCommandRaw: "runCommandRaw", findRaw: "findRaw", aggregateRaw: "aggregateRaw" };
    var es = "explicitly `undefined` values are not allowed";
    function _r({ modelName: e3, action: t2, args: r3, runtimeDataModel: n2, extensions: i = dt.empty(), callsite: o2, clientMethod: s3, errorFormat: a, clientVersion: d, previewFeatures: f, globalOmit: P }) {
      let A = new $n({ runtimeDataModel: n2, modelName: e3, action: t2, rootArgs: r3, callsite: o2, extensions: i, selectionPath: [], argumentPath: [], originalMethod: s3, errorFormat: a, clientVersion: d, previewFeatures: f, globalOmit: P });
      return { modelName: e3, action: pc[t2], query: Vt(r3, A) };
    }
    function Vt({ select: e3, include: t2, ...r3 } = {}, n2) {
      let i = r3.omit;
      return delete r3.omit, { arguments: rs(r3, n2), selection: mc(e3, t2, i, n2) };
    }
    function mc(e3, t2, r3, n2) {
      return e3 ? (t2 ? n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "include", secondField: "select", selectionPath: n2.getSelectionPath() }) : r3 && n2.throwValidationError({ kind: "MutuallyExclusiveFields", firstField: "omit", secondField: "select", selectionPath: n2.getSelectionPath() }), yc(e3, n2)) : dc(n2, t2, r3);
    }
    function dc(e3, t2, r3) {
      let n2 = {};
      return e3.modelOrType && !e3.isRawAction() && (n2.$composites = true, n2.$scalars = true), t2 && fc(n2, t2, e3), gc(n2, r3, e3), n2;
    }
    function fc(e3, t2, r3) {
      for (let [n2, i] of Object.entries(t2)) {
        if (xe(i))
          continue;
        let o2 = r3.nestSelection(n2);
        if (qn(i, o2), i === false || i === void 0) {
          e3[n2] = false;
          continue;
        }
        let s3 = r3.findField(n2);
        if (s3 && s3.kind !== "object" && r3.throwValidationError({ kind: "IncludeOnScalar", selectionPath: r3.getSelectionPath().concat(n2), outputType: r3.getOutputTypeDescription() }), s3) {
          e3[n2] = Vt(i === true ? {} : i, o2);
          continue;
        }
        if (i === true) {
          e3[n2] = true;
          continue;
        }
        e3[n2] = Vt(i, o2);
      }
    }
    function gc(e3, t2, r3) {
      let n2 = r3.getComputedFields(), i = { ...r3.getGlobalOmit(), ...t2 }, o2 = zo(i, n2);
      for (let [s3, a] of Object.entries(o2)) {
        if (xe(a))
          continue;
        qn(a, r3.nestSelection(s3));
        let d = r3.findField(s3);
        n2?.[s3] && !d || (e3[s3] = !a);
      }
    }
    function yc(e3, t2) {
      let r3 = {}, n2 = t2.getComputedFields(), i = Ko(e3, n2);
      for (let [o2, s3] of Object.entries(i)) {
        if (xe(s3))
          continue;
        let a = t2.nestSelection(o2);
        qn(s3, a);
        let d = t2.findField(o2);
        if (!(n2?.[o2] && !d)) {
          if (s3 === false || s3 === void 0 || xe(s3)) {
            r3[o2] = false;
            continue;
          }
          if (s3 === true) {
            d?.kind === "object" ? r3[o2] = Vt({}, a) : r3[o2] = true;
            continue;
          }
          r3[o2] = Vt(s3, a);
        }
      }
      return r3;
    }
    function ts(e3, t2) {
      if (e3 === null)
        return null;
      if (typeof e3 == "string" || typeof e3 == "number" || typeof e3 == "boolean")
        return e3;
      if (typeof e3 == "bigint")
        return { $type: "BigInt", value: String(e3) };
      if (it(e3)) {
        if (Pr(e3))
          return { $type: "DateTime", value: e3.toISOString() };
        t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: ["Date"] }, underlyingError: "Provided Date object is invalid" });
      }
      if (Zo(e3))
        return { $type: "Param", value: e3.name };
      if (pt(e3))
        return { $type: "FieldRef", value: { _ref: e3.name, _container: e3.modelName } };
      if (Array.isArray(e3))
        return hc(e3, t2);
      if (ArrayBuffer.isView(e3)) {
        let { buffer: r3, byteOffset: n2, byteLength: i } = e3;
        return { $type: "Bytes", value: y.from(r3, n2, i).toString("base64") };
      }
      if (wc(e3))
        return e3.values;
      if (ot(e3))
        return { $type: "Decimal", value: e3.toFixed() };
      if (e3 instanceof ke.ObjectEnumValue) {
        if (!(0, ke.isDbNull)(e3) && !(0, ke.isJsonNull)(e3) && !(0, ke.isAnyNull)(e3))
          throw new Error("Invalid ObjectEnumValue");
        return { $type: "Enum", value: e3._getName() };
      }
      if (bc(e3))
        return e3.toJSON();
      if (typeof e3 == "object")
        return rs(e3, t2);
      t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: t2.getSelectionPath(), argumentPath: t2.getArgumentPath(), argument: { name: t2.getArgumentName(), typeNames: [] }, underlyingError: `We could not serialize ${Object.prototype.toString.call(e3)} value. Serialize the object to JSON or implement a ".toJSON()" method on it` });
    }
    function rs(e3, t2) {
      if (e3.$type)
        return { $type: "Raw", value: e3 };
      let r3 = {};
      for (let n2 in e3) {
        let i = e3[n2], o2 = t2.nestArgument(n2);
        xe(i) || (i !== void 0 ? r3[n2] = ts(i, o2) : t2.isPreviewFeatureOn("strictUndefinedChecks") && t2.throwValidationError({ kind: "InvalidArgumentValue", argumentPath: o2.getArgumentPath(), selectionPath: t2.getSelectionPath(), argument: { name: t2.getArgumentName(), typeNames: [] }, underlyingError: es }));
      }
      return r3;
    }
    function hc(e3, t2) {
      let r3 = [];
      for (let n2 = 0; n2 < e3.length; n2++) {
        let i = t2.nestArgument(String(n2)), o2 = e3[n2];
        if (o2 === void 0 || xe(o2)) {
          let s3 = o2 === void 0 ? "undefined" : "Prisma.skip";
          t2.throwValidationError({ kind: "InvalidArgumentValue", selectionPath: i.getSelectionPath(), argumentPath: i.getArgumentPath(), argument: { name: `${t2.getArgumentName()}[${n2}]`, typeNames: [] }, underlyingError: `Can not use \`${s3}\` value within array. Use \`null\` or filter out \`${s3}\` values` });
        }
        r3.push(ts(o2, i));
      }
      return r3;
    }
    function wc(e3) {
      return typeof e3 == "object" && e3 !== null && e3.__prismaRawParameters__ === true;
    }
    function bc(e3) {
      return typeof e3 == "object" && e3 !== null && typeof e3.toJSON == "function";
    }
    function qn(e3, t2) {
      e3 === void 0 && t2.isPreviewFeatureOn("strictUndefinedChecks") && t2.throwValidationError({ kind: "InvalidSelectionValue", selectionPath: t2.getSelectionPath(), underlyingError: es });
    }
    var $n = class e3 {
      constructor(t2) {
        this.params = t2;
        this.params.modelName && (this.modelOrType = this.params.runtimeDataModel.models[this.params.modelName] ?? this.params.runtimeDataModel.types[this.params.modelName]);
      }
      modelOrType;
      throwValidationError(t2) {
        Mr({ errors: [t2], originalMethod: this.params.originalMethod, args: this.params.rootArgs ?? {}, callsite: this.params.callsite, errorFormat: this.params.errorFormat, clientVersion: this.params.clientVersion, globalOmit: this.params.globalOmit });
      }
      getSelectionPath() {
        return this.params.selectionPath;
      }
      getArgumentPath() {
        return this.params.argumentPath;
      }
      getArgumentName() {
        return this.params.argumentPath[this.params.argumentPath.length - 1];
      }
      getOutputTypeDescription() {
        if (!(!this.params.modelName || !this.modelOrType))
          return { name: this.params.modelName, fields: this.modelOrType.fields.map((t2) => ({ name: t2.name, typeName: "boolean", isRelation: t2.kind === "object" })) };
      }
      isRawAction() {
        return ["executeRaw", "queryRaw", "runCommandRaw", "findRaw", "aggregateRaw"].includes(this.params.action);
      }
      isPreviewFeatureOn(t2) {
        return this.params.previewFeatures.includes(t2);
      }
      getComputedFields() {
        if (this.params.modelName)
          return this.params.extensions.getAllComputedFields(this.params.modelName);
      }
      findField(t2) {
        return this.modelOrType?.fields.find((r3) => r3.name === t2);
      }
      nestSelection(t2) {
        let r3 = this.findField(t2), n2 = r3?.kind === "object" ? r3.type : void 0;
        return new e3({ ...this.params, modelName: n2, selectionPath: this.params.selectionPath.concat(t2) });
      }
      getGlobalOmit() {
        return this.params.modelName && this.shouldApplyGlobalOmit() ? this.params.globalOmit?.[Ie(this.params.modelName)] ?? {} : {};
      }
      shouldApplyGlobalOmit() {
        switch (this.params.action) {
          case "findFirst":
          case "findFirstOrThrow":
          case "findUniqueOrThrow":
          case "findMany":
          case "upsert":
          case "findUnique":
          case "createManyAndReturn":
          case "create":
          case "update":
          case "updateManyAndReturn":
          case "delete":
            return true;
          case "executeRaw":
          case "aggregateRaw":
          case "runCommandRaw":
          case "findRaw":
          case "createMany":
          case "deleteMany":
          case "groupBy":
          case "updateMany":
          case "count":
          case "aggregate":
          case "queryRaw":
            return false;
          default:
            ve(this.params.action, "Unknown action");
        }
      }
      nestArgument(t2) {
        return new e3({ ...this.params, argumentPath: this.params.argumentPath.concat(t2) });
      }
    };
    l();
    u();
    c2();
    p();
    m();
    function ns(e3, t2) {
      let r3 = St(() => xc(t2));
      Object.defineProperty(e3, "dmmf", { get: () => r3.get() });
    }
    function xc(e3) {
      throw new Error("Prisma.dmmf is not available when running in edge runtimes.");
    }
    l();
    u();
    c2();
    p();
    m();
    var Bn = /* @__PURE__ */ new WeakMap();
    var Fr = "$$PrismaTypedSql";
    var Bt = class {
      constructor(t2, r3) {
        Bn.set(this, { sql: t2, values: r3 }), Object.defineProperty(this, Fr, { value: Fr });
      }
      get sql() {
        return Bn.get(this).sql;
      }
      get values() {
        return Bn.get(this).values;
      }
    };
    function is(e3) {
      return (...t2) => new Bt(e3, t2);
    }
    function Ur(e3) {
      return e3 != null && e3[Fr] === Fr;
    }
    l();
    u();
    c2();
    p();
    m();
    var Zl = require_dist();
    l();
    u();
    c2();
    p();
    m();
    os();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function jt(e3) {
      return { getKeys() {
        return Object.keys(e3);
      }, getPropertyValue(t2) {
        return e3[t2];
      } };
    }
    l();
    u();
    c2();
    p();
    m();
    function ee(e3, t2) {
      return { getKeys() {
        return [e3];
      }, getPropertyValue() {
        return t2();
      } };
    }
    l();
    u();
    c2();
    p();
    m();
    function je(e3) {
      let t2 = new he();
      return { getKeys() {
        return e3.getKeys();
      }, getPropertyValue(r3) {
        return t2.getOrCreate(r3, () => e3.getPropertyValue(r3));
      }, getPropertyDescriptor(r3) {
        return e3.getPropertyDescriptor?.(r3);
      } };
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var qr = { enumerable: true, configurable: true, writable: true };
    function Vr(e3) {
      let t2 = new Set(e3);
      return { getPrototypeOf: () => Object.prototype, getOwnPropertyDescriptor: () => qr, has: (r3, n2) => t2.has(n2), set: (r3, n2, i) => t2.add(n2) && Reflect.set(r3, n2, i), ownKeys: () => [...t2] };
    }
    var ss = Symbol.for("nodejs.util.inspect.custom");
    function pe(e3, t2) {
      let r3 = Ec(t2), n2 = /* @__PURE__ */ new Set(), i = new Proxy(e3, { get(o2, s3) {
        if (n2.has(s3))
          return o2[s3];
        let a = r3.get(s3);
        return a ? a.getPropertyValue(s3) : o2[s3];
      }, has(o2, s3) {
        if (n2.has(s3))
          return true;
        let a = r3.get(s3);
        return a ? a.has?.(s3) ?? true : Reflect.has(o2, s3);
      }, ownKeys(o2) {
        let s3 = as(Reflect.ownKeys(o2), r3), a = as(Array.from(r3.keys()), r3);
        return [.../* @__PURE__ */ new Set([...s3, ...a, ...n2])];
      }, set(o2, s3, a) {
        return r3.get(s3)?.getPropertyDescriptor?.(s3)?.writable === false ? false : (n2.add(s3), Reflect.set(o2, s3, a));
      }, getOwnPropertyDescriptor(o2, s3) {
        let a = Reflect.getOwnPropertyDescriptor(o2, s3);
        if (a && !a.configurable)
          return a;
        let d = r3.get(s3);
        return d ? d.getPropertyDescriptor ? { ...qr, ...d?.getPropertyDescriptor(s3) } : qr : a;
      }, defineProperty(o2, s3, a) {
        return n2.add(s3), Reflect.defineProperty(o2, s3, a);
      }, getPrototypeOf: () => Object.prototype });
      return i[ss] = function() {
        let o2 = { ...this };
        return delete o2[ss], o2;
      }, i;
    }
    function Ec(e3) {
      let t2 = /* @__PURE__ */ new Map();
      for (let r3 of e3) {
        let n2 = r3.getKeys();
        for (let i of n2)
          t2.set(i, r3);
      }
      return t2;
    }
    function as(e3, t2) {
      return e3.filter((r3) => t2.get(r3)?.has?.(r3) ?? true);
    }
    l();
    u();
    c2();
    p();
    m();
    function ft(e3) {
      return { getKeys() {
        return e3;
      }, has() {
        return false;
      }, getPropertyValue() {
      } };
    }
    l();
    u();
    c2();
    p();
    m();
    function ls(e3) {
      if (e3 === void 0)
        return "";
      let t2 = mt(e3);
      return new st(0, { colors: Rr }).write(t2).toString();
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var jn = class {
      getLocation() {
        return null;
      }
    };
    function Me(e3) {
      return typeof $EnabledCallSite == "function" && e3 !== "minimal" ? new $EnabledCallSite() : new jn();
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var us = { _avg: true, _count: true, _sum: true, _min: true, _max: true };
    function gt(e3 = {}) {
      let t2 = Pc(e3);
      return Object.entries(t2).reduce((n2, [i, o2]) => (us[i] !== void 0 ? n2.select[i] = { select: o2 } : n2[i] = o2, n2), { select: {} });
    }
    function Pc(e3 = {}) {
      return typeof e3._count == "boolean" ? { ...e3, _count: { _all: e3._count } } : e3;
    }
    function Br(e3 = {}) {
      return (t2) => (typeof e3._count == "boolean" && (t2._count = t2._count._all), t2);
    }
    function cs(e3, t2) {
      let r3 = Br(e3);
      return t2({ action: "aggregate", unpacker: r3, argsMapper: gt })(e3);
    }
    l();
    u();
    c2();
    p();
    m();
    function Ac(e3 = {}) {
      let { select: t2, ...r3 } = e3;
      return typeof t2 == "object" ? gt({ ...r3, _count: t2 }) : gt({ ...r3, _count: { _all: true } });
    }
    function vc(e3 = {}) {
      return typeof e3.select == "object" ? (t2) => Br(e3)(t2)._count : (t2) => Br(e3)(t2)._count._all;
    }
    function ps(e3, t2) {
      return t2({ action: "count", unpacker: vc(e3), argsMapper: Ac })(e3);
    }
    l();
    u();
    c2();
    p();
    m();
    function Cc(e3 = {}) {
      let t2 = gt(e3);
      if (Array.isArray(t2.by))
        for (let r3 of t2.by)
          typeof r3 == "string" && (t2.select[r3] = true);
      else
        typeof t2.by == "string" && (t2.select[t2.by] = true);
      return t2;
    }
    function Sc(e3 = {}) {
      return (t2) => (typeof e3?._count == "boolean" && t2.forEach((r3) => {
        r3._count = r3._count._all;
      }), t2);
    }
    function ms(e3, t2) {
      return t2({ action: "groupBy", unpacker: Sc(e3), argsMapper: Cc })(e3);
    }
    function ds(e3, t2, r3) {
      if (t2 === "aggregate")
        return (n2) => cs(n2, r3);
      if (t2 === "count")
        return (n2) => ps(n2, r3);
      if (t2 === "groupBy")
        return (n2) => ms(n2, r3);
    }
    l();
    u();
    c2();
    p();
    m();
    function fs(e3, t2) {
      let r3 = t2.fields.filter((i) => !i.relationName), n2 = eo(r3, "name");
      return new Proxy({}, { get(i, o2) {
        if (o2 in i || typeof o2 == "symbol")
          return i[o2];
        let s3 = n2[o2];
        if (s3)
          return new $t(e3, o2, s3.type, s3.isList, s3.kind === "enum");
      }, ...Vr(Object.keys(n2)) });
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var gs = (e3) => Array.isArray(e3) ? e3 : e3.split(".");
    var Qn = (e3, t2) => gs(t2).reduce((r3, n2) => r3 && r3[n2], e3);
    var ys = (e3, t2, r3) => gs(t2).reduceRight((n2, i, o2, s3) => Object.assign({}, Qn(e3, s3.slice(0, o2)), { [i]: n2 }), r3);
    function Rc(e3, t2) {
      return e3 === void 0 || t2 === void 0 ? [] : [...t2, "select", e3];
    }
    function Ic(e3, t2, r3) {
      return t2 === void 0 ? e3 ?? {} : ys(t2, r3, e3 || true);
    }
    function Hn(e3, t2, r3, n2, i, o2) {
      let a = e3._runtimeDataModel.models[t2].fields.reduce((d, f) => ({ ...d, [f.name]: f }), {});
      return (d) => {
        let f = Me(e3._errorFormat), P = Rc(n2, i), A = Ic(d, o2, P), S = r3({ dataPath: P, callsite: f })(A), C = Oc(e3, t2);
        return new Proxy(S, { get(M, R) {
          if (!C.includes(R))
            return M[R];
          let Pe = [a[R].type, r3, R], re = [P, A];
          return Hn(e3, ...Pe, ...re);
        }, ...Vr([...C, ...Object.getOwnPropertyNames(S)]) });
      };
    }
    function Oc(e3, t2) {
      return e3._runtimeDataModel.models[t2].fields.filter((r3) => r3.kind === "object").map((r3) => r3.name);
    }
    var kc = ["findUnique", "findUniqueOrThrow", "findFirst", "findFirstOrThrow", "create", "update", "upsert", "delete"];
    var Mc = ["aggregate", "count", "groupBy"];
    function Jn(e3, t2) {
      let r3 = e3._extensions.getAllModelExtensions(t2) ?? {}, n2 = [Dc(e3, t2), Lc(e3, t2), jt(r3), ee("name", () => t2), ee("$name", () => t2), ee("$parent", () => e3._appliedParent)];
      return pe({}, n2);
    }
    function Dc(e3, t2) {
      let r3 = be(t2), n2 = Object.keys(Lt).concat("count");
      return { getKeys() {
        return n2;
      }, getPropertyValue(i) {
        let o2 = i, s3 = (a) => (d) => {
          let f = Me(e3._errorFormat);
          return e3._createPrismaPromise((P) => {
            let A = { args: d, dataPath: [], action: o2, model: t2, clientMethod: `${r3}.${i}`, jsModelName: r3, transaction: P, callsite: f };
            return e3._request({ ...A, ...a });
          }, { action: o2, args: d, model: t2 });
        };
        return kc.includes(o2) ? Hn(e3, t2, s3) : Nc(i) ? ds(e3, i, s3) : s3({});
      } };
    }
    function Nc(e3) {
      return Mc.includes(e3);
    }
    function Lc(e3, t2) {
      return je(ee("fields", () => {
        let r3 = e3._runtimeDataModel.models[t2];
        return fs(t2, r3);
      }));
    }
    l();
    u();
    c2();
    p();
    m();
    function hs(e3) {
      return e3.replace(/^./, (t2) => t2.toUpperCase());
    }
    var Wn = Symbol();
    function Qt(e3) {
      let t2 = [_c(e3), Fc(e3), ee(Wn, () => e3), ee("$parent", () => e3._appliedParent)], r3 = e3._extensions.getAllClientExtensions();
      return r3 && t2.push(jt(r3)), pe(e3, t2);
    }
    function _c(e3) {
      let t2 = Object.getPrototypeOf(e3._originalClient), r3 = [...new Set(Object.getOwnPropertyNames(t2))];
      return { getKeys() {
        return r3;
      }, getPropertyValue(n2) {
        return e3[n2];
      } };
    }
    function Fc(e3) {
      let t2 = Object.keys(e3._runtimeDataModel.models), r3 = t2.map(be), n2 = [...new Set(t2.concat(r3))];
      return je({ getKeys() {
        return n2;
      }, getPropertyValue(i) {
        let o2 = hs(i);
        if (e3._runtimeDataModel.models[o2] !== void 0)
          return Jn(e3, o2);
        if (e3._runtimeDataModel.models[i] !== void 0)
          return Jn(e3, i);
      }, getPropertyDescriptor(i) {
        if (!r3.includes(i))
          return { enumerable: false };
      } });
    }
    function ws(e3) {
      return e3[Wn] ? e3[Wn] : e3;
    }
    function bs(e3) {
      if (typeof e3 == "function")
        return e3(this);
      let t2 = Object.create(this._originalClient, { _extensions: { value: this._extensions.append(e3) }, _appliedParent: { value: this, configurable: true }, $on: { value: void 0 } });
      return Qt(t2);
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function xs({ result: e3, modelName: t2, select: r3, omit: n2, extensions: i }) {
      let o2 = i.getAllComputedFields(t2);
      if (!o2)
        return e3;
      let s3 = [], a = [];
      for (let d of Object.values(o2)) {
        if (n2) {
          if (n2[d.name])
            continue;
          let f = d.needs.filter((P) => n2[P]);
          f.length > 0 && a.push(ft(f));
        } else if (r3) {
          if (!r3[d.name])
            continue;
          let f = d.needs.filter((P) => !r3[P]);
          f.length > 0 && a.push(ft(f));
        }
        Uc(e3, d.needs) && s3.push($c(d, pe(e3, s3)));
      }
      return s3.length > 0 || a.length > 0 ? pe(e3, [...s3, ...a]) : e3;
    }
    function Uc(e3, t2) {
      return t2.every((r3) => Dn(e3, r3));
    }
    function $c(e3, t2) {
      return je(ee(e3.name, () => e3.compute(t2)));
    }
    l();
    u();
    c2();
    p();
    m();
    function jr({ visitor: e3, result: t2, args: r3, runtimeDataModel: n2, modelName: i }) {
      if (Array.isArray(t2)) {
        for (let s3 = 0; s3 < t2.length; s3++)
          t2[s3] = jr({ result: t2[s3], args: r3, modelName: i, runtimeDataModel: n2, visitor: e3 });
        return t2;
      }
      let o2 = e3(t2, i, r3) ?? t2;
      return r3.include && Es({ includeOrSelect: r3.include, result: o2, parentModelName: i, runtimeDataModel: n2, visitor: e3 }), r3.select && Es({ includeOrSelect: r3.select, result: o2, parentModelName: i, runtimeDataModel: n2, visitor: e3 }), o2;
    }
    function Es({ includeOrSelect: e3, result: t2, parentModelName: r3, runtimeDataModel: n2, visitor: i }) {
      for (let [o2, s3] of Object.entries(e3)) {
        if (!s3 || t2[o2] == null || xe(s3))
          continue;
        let d = n2.models[r3].fields.find((P) => P.name === o2);
        if (!d || d.kind !== "object" || !d.relationName)
          continue;
        let f = typeof s3 == "object" ? s3 : {};
        t2[o2] = jr({ visitor: i, result: t2[o2], args: f, modelName: d.type, runtimeDataModel: n2 });
      }
    }
    function Ts({ result: e3, modelName: t2, args: r3, extensions: n2, runtimeDataModel: i, globalOmit: o2 }) {
      return n2.isEmpty() || e3 == null || typeof e3 != "object" || !i.models[t2] ? e3 : jr({ result: e3, args: r3 ?? {}, modelName: t2, runtimeDataModel: i, visitor: (a, d, f) => {
        let P = be(d);
        return xs({ result: a, modelName: P, select: f.select, omit: f.select ? void 0 : { ...o2?.[P], ...f.omit }, extensions: n2 });
      } });
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var Qe = require_dist();
    l();
    u();
    c2();
    p();
    m();
    var qc = ["$connect", "$disconnect", "$on", "$transaction", "$extends"];
    var Ps = qc;
    function As(e3) {
      if (e3 instanceof Qe.Sql)
        return Vc(e3);
      if (Ur(e3))
        return Bc(e3);
      if (Array.isArray(e3)) {
        let r3 = [e3[0]];
        for (let n2 = 1; n2 < e3.length; n2++)
          r3[n2] = Ht(e3[n2]);
        return r3;
      }
      let t2 = {};
      for (let r3 in e3)
        t2[r3] = Ht(e3[r3]);
      return t2;
    }
    function Vc(e3) {
      return new Qe.Sql(e3.strings, e3.values);
    }
    function Bc(e3) {
      return new Bt(e3.sql, e3.values);
    }
    function Ht(e3) {
      if (typeof e3 != "object" || e3 == null || e3 instanceof Qe.ObjectEnumValue || pt(e3))
        return e3;
      if (ot(e3))
        return new Qe.Decimal(e3.toFixed());
      if (it(e3))
        return /* @__PURE__ */ new Date(+e3);
      if (ArrayBuffer.isView(e3))
        return e3.slice(0);
      if (Array.isArray(e3)) {
        let t2 = e3.length, r3;
        for (r3 = Array(t2); t2--; )
          r3[t2] = Ht(e3[t2]);
        return r3;
      }
      if (typeof e3 == "object") {
        let t2 = {};
        for (let r3 in e3)
          r3 === "__proto__" ? Object.defineProperty(t2, r3, { value: Ht(e3[r3]), configurable: true, enumerable: true, writable: true }) : t2[r3] = Ht(e3[r3]);
        return t2;
      }
      ve(e3, "Unknown value");
    }
    function Cs(e3, t2, r3, n2 = 0) {
      return e3._createPrismaPromise((i) => {
        let o2 = t2.customDataProxyFetch;
        return "transaction" in t2 && i !== void 0 && (t2.transaction?.kind === "batch" && t2.transaction.lock.then(), t2.transaction = i), n2 === r3.length ? e3._executeRequest(t2) : r3[n2]({ model: t2.model, operation: t2.model ? t2.action : t2.clientMethod, args: As(t2.args ?? {}), __internalParams: t2, query: (s3, a = t2) => {
          let d = a.customDataProxyFetch;
          return a.customDataProxyFetch = Os(o2, d), a.args = s3, Cs(e3, a, r3, n2 + 1);
        } });
      });
    }
    function Ss(e3, t2) {
      let { jsModelName: r3, action: n2, clientMethod: i } = t2, o2 = r3 ? n2 : i;
      if (e3._extensions.isEmpty())
        return e3._executeRequest(t2);
      let s3 = e3._extensions.getAllQueryCallbacks(r3 ?? "$none", o2);
      return Cs(e3, t2, s3);
    }
    function Rs(e3) {
      return (t2) => {
        let r3 = { requests: t2 }, n2 = t2[0].extensions.getAllBatchQueryCallbacks();
        return n2.length ? Is(r3, n2, 0, e3) : e3(r3);
      };
    }
    function Is(e3, t2, r3, n2) {
      if (r3 === t2.length)
        return n2(e3);
      let i = e3.customDataProxyFetch, o2 = e3.requests[0].transaction;
      return t2[r3]({ args: { queries: e3.requests.map((s3) => ({ model: s3.modelName, operation: s3.action, args: s3.args })), transaction: o2 ? { isolationLevel: o2.kind === "batch" ? o2.isolationLevel : void 0 } : void 0 }, __internalParams: e3, query(s3, a = e3) {
        let d = a.customDataProxyFetch;
        return a.customDataProxyFetch = Os(i, d), Is(a, t2, r3 + 1, n2);
      } });
    }
    var vs = (e3) => e3;
    function Os(e3 = vs, t2 = vs) {
      return (r3) => e3(t2(r3));
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var _s = require_dist();
    l();
    u();
    c2();
    p();
    m();
    var Jt = require_dist();
    function L(e3, t2) {
      throw new Error(t2);
    }
    function Gn(e3, t2) {
      return e3 === t2 || e3 !== null && t2 !== null && typeof e3 == "object" && typeof t2 == "object" && Object.keys(e3).length === Object.keys(t2).length && Object.keys(e3).every((r3) => Gn(e3[r3], t2[r3]));
    }
    function yt(e3, t2) {
      let r3 = Object.keys(e3), n2 = Object.keys(t2);
      return (r3.length < n2.length ? r3 : n2).every((o2) => {
        if (typeof e3[o2] == typeof t2[o2] && typeof e3[o2] != "object")
          return e3[o2] === t2[o2];
        if (Jt.Decimal.isDecimal(e3[o2]) || Jt.Decimal.isDecimal(t2[o2])) {
          let s3 = ks(e3[o2]), a = ks(t2[o2]);
          return s3 && a && s3.equals(a);
        } else if (e3[o2] instanceof Uint8Array || t2[o2] instanceof Uint8Array) {
          let s3 = Ms(e3[o2]), a = Ms(t2[o2]);
          return s3 && a && s3.equals(a);
        } else {
          if (e3[o2] instanceof Date || t2[o2] instanceof Date)
            return Ds(e3[o2])?.getTime() === Ds(t2[o2])?.getTime();
          if (typeof e3[o2] == "bigint" || typeof t2[o2] == "bigint")
            return Ns(e3[o2]) === Ns(t2[o2]);
          if (typeof e3[o2] == "number" || typeof t2[o2] == "number")
            return Ls(e3[o2]) === Ls(t2[o2]);
        }
        return Gn(e3[o2], t2[o2]);
      });
    }
    function ks(e3) {
      return Jt.Decimal.isDecimal(e3) ? e3 : typeof e3 == "number" || typeof e3 == "string" ? new Jt.Decimal(e3) : void 0;
    }
    function Ms(e3) {
      return y.isBuffer(e3) ? e3 : e3 instanceof Uint8Array ? y.from(e3.buffer, e3.byteOffset, e3.byteLength) : typeof e3 == "string" ? y.from(e3, "base64") : void 0;
    }
    function Ds(e3) {
      return e3 instanceof Date ? e3 : typeof e3 == "string" || typeof e3 == "number" ? new Date(e3) : void 0;
    }
    function Ns(e3) {
      return typeof e3 == "bigint" ? e3 : typeof e3 == "number" || typeof e3 == "string" ? BigInt(e3) : void 0;
    }
    function Ls(e3) {
      return typeof e3 == "number" ? e3 : typeof e3 == "string" ? Number(e3) : void 0;
    }
    function Wt(e3) {
      return JSON.stringify(e3, (t2, r3) => typeof r3 == "bigint" ? r3.toString() : ArrayBuffer.isView(r3) ? y.from(r3.buffer, r3.byteOffset, r3.byteLength).toString("base64") : r3);
    }
    function jc(e3) {
      return e3 !== null && typeof e3 == "object" && typeof e3.$type == "string";
    }
    function Qc(e3, t2) {
      let r3 = {};
      for (let n2 of Object.keys(e3))
        r3[n2] = t2(e3[n2], n2);
      return r3;
    }
    function De(e3) {
      return e3 === null ? e3 : Array.isArray(e3) ? e3.map(De) : typeof e3 == "object" ? jc(e3) ? Hc(e3) : e3.constructor !== null && e3.constructor.name !== "Object" ? e3 : Qc(e3, De) : e3;
    }
    function Hc({ $type: e3, value: t2 }) {
      switch (e3) {
        case "BigInt":
          return BigInt(t2);
        case "Bytes": {
          let { buffer: r3, byteOffset: n2, byteLength: i } = y.from(t2, "base64");
          return new Uint8Array(r3, n2, i);
        }
        case "DateTime":
          return new Date(t2);
        case "Decimal":
          return new _s.Decimal(t2);
        case "Json":
          return JSON.parse(t2);
        default:
          L(t2, "Unknown tagged value");
      }
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function Qr(e3) {
      return e3.name === "DriverAdapterError" && typeof e3.cause == "object";
    }
    l();
    u();
    c2();
    p();
    m();
    var I = { Int32: 0, Int64: 1, Float: 2, Double: 3, Numeric: 4, Boolean: 5, Character: 6, Text: 7, Date: 8, Time: 9, DateTime: 10, Json: 11, Enum: 12, Bytes: 13, Set: 14, Uuid: 15, Int32Array: 64, Int64Array: 65, FloatArray: 66, DoubleArray: 67, NumericArray: 68, BooleanArray: 69, CharacterArray: 70, TextArray: 71, DateArray: 72, TimeArray: 73, DateTimeArray: 74, JsonArray: 75, EnumArray: 76, BytesArray: 77, UuidArray: 78, UnknownNumber: 128 };
    var te = class extends Error {
      name = "UserFacingError";
      code;
      meta;
      constructor(t2, r3, n2) {
        super(t2), this.code = r3, this.meta = n2 ?? {};
      }
      toQueryResponseErrorObject() {
        return { error: this.message, user_facing_error: { is_panic: false, message: this.message, meta: this.meta, error_code: this.code } };
      }
    };
    function ht(e3) {
      if (!Qr(e3))
        throw e3;
      let t2 = Jc(e3), r3 = Fs(e3);
      throw !t2 || !r3 ? e3 : new te(r3, t2, { driverAdapterError: e3 });
    }
    function zn(e3) {
      throw Qr(e3) ? new te(`Raw query failed. Code: \`${e3.cause.originalCode ?? "N/A"}\`. Message: \`${e3.cause.originalMessage ?? Fs(e3)}\``, "P2010", { driverAdapterError: e3 }) : e3;
    }
    function Jc(e3) {
      switch (e3.cause.kind) {
        case "AuthenticationFailed":
          return "P1000";
        case "DatabaseNotReachable":
          return "P1001";
        case "DatabaseDoesNotExist":
          return "P1003";
        case "SocketTimeout":
          return "P1008";
        case "DatabaseAlreadyExists":
          return "P1009";
        case "DatabaseAccessDenied":
          return "P1010";
        case "TlsConnectionError":
          return "P1011";
        case "ConnectionClosed":
          return "P1017";
        case "TransactionAlreadyClosed":
          return "P1018";
        case "LengthMismatch":
          return "P2000";
        case "UniqueConstraintViolation":
          return "P2002";
        case "ForeignKeyConstraintViolation":
          return "P2003";
        case "UnsupportedNativeDataType":
          return "P2010";
        case "NullConstraintViolation":
          return "P2011";
        case "ValueOutOfRange":
          return "P2020";
        case "TableDoesNotExist":
          return "P2021";
        case "ColumnNotFound":
          return "P2022";
        case "InvalidIsolationLevel":
        case "InconsistentColumnData":
          return "P2023";
        case "MissingFullTextSearchIndex":
          return "P2030";
        case "TransactionWriteConflict":
          return "P2034";
        case "GenericJs":
          return "P2036";
        case "TooManyConnections":
          return "P2037";
        case "postgres":
        case "sqlite":
        case "mysql":
        case "mssql":
          return;
        default:
          L(e3.cause, `Unknown error: ${e3.cause}`);
      }
    }
    function Fs(e3) {
      switch (e3.cause.kind) {
        case "AuthenticationFailed":
          return `Authentication failed against the database server, the provided database credentials for \`${e3.cause.user ?? "(not available)"}\` are not valid`;
        case "DatabaseNotReachable": {
          let t2 = e3.cause.host && e3.cause.port ? `${e3.cause.host}:${e3.cause.port}` : e3.cause.host;
          return `Can't reach database server${t2 ? ` at ${t2}` : ""}`;
        }
        case "DatabaseDoesNotExist":
          return `Database \`${e3.cause.db ?? "(not available)"}\` does not exist on the database server`;
        case "SocketTimeout":
          return "Operation has timed out";
        case "DatabaseAlreadyExists":
          return `Database \`${e3.cause.db ?? "(not available)"}\` already exists on the database server`;
        case "DatabaseAccessDenied":
          return `User was denied access on the database \`${e3.cause.db ?? "(not available)"}\``;
        case "TlsConnectionError":
          return `Error opening a TLS connection: ${e3.cause.reason}`;
        case "ConnectionClosed":
          return "Server has closed the connection.";
        case "TransactionAlreadyClosed":
          return e3.cause.cause;
        case "LengthMismatch":
          return `The provided value for the column is too long for the column's type. Column: ${e3.cause.column ?? "(not available)"}`;
        case "UniqueConstraintViolation":
          return `Unique constraint failed on the ${Kn(e3.cause.constraint)}`;
        case "ForeignKeyConstraintViolation":
          return `Foreign key constraint violated on the ${Kn(e3.cause.constraint)}`;
        case "UnsupportedNativeDataType":
          return `Failed to deserialize column of type '${e3.cause.type}'. If you're using $queryRaw and this column is explicitly marked as \`Unsupported\` in your Prisma schema, try casting this column to any supported Prisma type such as \`String\`.`;
        case "NullConstraintViolation":
          return `Null constraint violation on the ${Kn(e3.cause.constraint)}`;
        case "ValueOutOfRange":
          return `Value out of range for the type: ${e3.cause.cause}`;
        case "TableDoesNotExist":
          return `The table \`${e3.cause.table ?? "(not available)"}\` does not exist in the current database.`;
        case "ColumnNotFound":
          return `The column \`${e3.cause.column ?? "(not available)"}\` does not exist in the current database.`;
        case "InvalidIsolationLevel":
          return `Error in connector: Conversion error: ${e3.cause.level}`;
        case "InconsistentColumnData":
          return `Inconsistent column data: ${e3.cause.cause}`;
        case "MissingFullTextSearchIndex":
          return "Cannot find a fulltext index to use for the native search, try adding a @@fulltext([Fields...]) to your schema";
        case "TransactionWriteConflict":
          return "Transaction failed due to a write conflict or a deadlock. Please retry your transaction";
        case "GenericJs":
          return `Error in external connector (id ${e3.cause.id})`;
        case "TooManyConnections":
          return `Too many database connections opened: ${e3.cause.cause}`;
        case "sqlite":
        case "postgres":
        case "mysql":
        case "mssql":
          return;
        default:
          L(e3.cause, `Unknown error: ${e3.cause}`);
      }
    }
    function Kn(e3) {
      return e3 && "fields" in e3 ? `fields: (${e3.fields.map((t2) => `\`${t2}\``).join(", ")})` : e3 && "index" in e3 ? `constraint: \`${e3.index}\`` : e3 && "foreignKey" in e3 ? "foreign key" : "(not available)";
    }
    function Us(e3, t2) {
      let r3 = e3.map((i) => t2.keys.reduce((o2, s3) => (o2[s3] = De(i[s3]), o2), {})), n2 = new Set(t2.nestedSelection);
      return t2.arguments.map((i) => {
        let o2 = r3.findIndex((s3) => yt(s3, i));
        if (o2 === -1)
          return t2.expectNonEmpty ? new te("An operation failed because it depends on one or more records that were required but not found", "P2025") : null;
        {
          let s3 = Object.entries(e3[o2]).filter(([a]) => n2.has(a));
          return Object.fromEntries(s3);
        }
      });
    }
    l();
    u();
    c2();
    p();
    m();
    var qs = require_dist();
    var q = class extends Error {
      name = "DataMapperError";
    };
    function Vs(e3, t2, r3) {
      switch (t2.type) {
        case "affectedRows":
          if (typeof e3 != "number")
            throw new q(`Expected an affected rows count, got: ${typeof e3} (${e3})`);
          return { count: e3 };
        case "object":
          return Yn(e3, t2.fields, r3, t2.skipNulls);
        case "field":
          return Zn(e3, "<result>", t2.fieldType, r3);
        default:
          L(t2, `Invalid data mapping type: '${t2.type}'`);
      }
    }
    function Yn(e3, t2, r3, n2) {
      if (e3 === null)
        return null;
      if (Array.isArray(e3)) {
        let i = e3;
        return n2 && (i = i.filter((o2) => o2 !== null)), i.map((o2) => $s(o2, t2, r3));
      }
      if (typeof e3 == "object")
        return $s(e3, t2, r3);
      if (typeof e3 == "string") {
        let i;
        try {
          i = JSON.parse(e3);
        } catch (o2) {
          throw new q("Expected an array or object, got a string that is not valid JSON", { cause: o2 });
        }
        return Yn(i, t2, r3, n2);
      }
      throw new q(`Expected an array or an object, got: ${typeof e3}`);
    }
    function $s(e3, t2, r3) {
      if (typeof e3 != "object")
        throw new q(`Expected an object, but got '${typeof e3}'`);
      let n2 = {};
      for (let [i, o2] of Object.entries(t2))
        switch (o2.type) {
          case "affectedRows":
            throw new q(`Unexpected 'AffectedRows' node in data mapping for field '${i}'`);
          case "object": {
            if (o2.serializedName !== null && !Object.hasOwn(e3, o2.serializedName))
              throw new q(`Missing data field (Object): '${i}'; node: ${JSON.stringify(o2)}; data: ${JSON.stringify(e3)}`);
            let s3 = o2.serializedName !== null ? e3[o2.serializedName] : e3;
            n2[i] = Yn(s3, o2.fields, r3, o2.skipNulls);
            break;
          }
          case "field":
            {
              let s3 = o2.dbName;
              if (Object.hasOwn(e3, s3))
                n2[i] = Wc(e3[s3], s3, o2.fieldType, r3);
              else
                throw new q(`Missing data field (Value): '${s3}'; node: ${JSON.stringify(o2)}; data: ${JSON.stringify(e3)}`);
            }
            break;
          default:
            L(o2, `DataMapper: Invalid data mapping node type: '${o2.type}'`);
        }
      return n2;
    }
    function Wc(e3, t2, r3, n2) {
      return e3 === null ? r3.arity === "list" ? [] : null : r3.arity === "list" ? e3.map((o2, s3) => Zn(o2, `${t2}[${s3}]`, r3, n2)) : Zn(e3, t2, r3, n2);
    }
    function Zn(e3, t2, r3, n2) {
      switch (r3.type) {
        case "unsupported":
          return e3;
        case "string": {
          if (typeof e3 != "string")
            throw new q(`Expected a string in column '${t2}', got ${typeof e3}: ${e3}`);
          return e3;
        }
        case "int":
          switch (typeof e3) {
            case "number":
              return Math.trunc(e3);
            case "string": {
              let i = Math.trunc(Number(e3));
              if (Number.isNaN(i) || !Number.isFinite(i))
                throw new q(`Expected an integer in column '${t2}', got string: ${e3}`);
              if (!Number.isSafeInteger(i))
                throw new q(`Integer value in column '${t2}' is too large to represent as a JavaScript number without loss of precision, got: ${e3}. Consider using BigInt type.`);
              return i;
            }
            default:
              throw new q(`Expected an integer in column '${t2}', got ${typeof e3}: ${e3}`);
          }
        case "bigint": {
          if (typeof e3 != "number" && typeof e3 != "string")
            throw new q(`Expected a bigint in column '${t2}', got ${typeof e3}: ${e3}`);
          return { $type: "BigInt", value: e3 };
        }
        case "float": {
          if (typeof e3 == "number")
            return e3;
          if (typeof e3 == "string") {
            let i = Number(e3);
            if (Number.isNaN(i) && !/^[-+]?nan$/.test(e3.toLowerCase()))
              throw new q(`Expected a float in column '${t2}', got string: ${e3}`);
            return i;
          }
          throw new q(`Expected a float in column '${t2}', got ${typeof e3}: ${e3}`);
        }
        case "boolean": {
          if (typeof e3 == "boolean")
            return e3;
          if (typeof e3 == "number")
            return e3 === 1;
          if (typeof e3 == "string") {
            if (e3 === "true" || e3 === "TRUE" || e3 === "1")
              return true;
            if (e3 === "false" || e3 === "FALSE" || e3 === "0")
              return false;
            throw new q(`Expected a boolean in column '${t2}', got ${typeof e3}: ${e3}`);
          }
          if (Array.isArray(e3)) {
            for (let i of e3)
              if (i !== 0)
                return true;
            return false;
          }
          throw new q(`Expected a boolean in column '${t2}', got ${typeof e3}: ${e3}`);
        }
        case "decimal":
          if (typeof e3 != "number" && typeof e3 != "string" && !qs.Decimal.isDecimal(e3))
            throw new q(`Expected a decimal in column '${t2}', got ${typeof e3}: ${e3}`);
          return { $type: "Decimal", value: e3 };
        case "datetime": {
          if (typeof e3 == "string")
            return { $type: "DateTime", value: Kc(e3) };
          if (typeof e3 == "number" || e3 instanceof Date)
            return { $type: "DateTime", value: e3 };
          throw new q(`Expected a date in column '${t2}', got ${typeof e3}: ${e3}`);
        }
        case "object":
          return { $type: "Json", value: Wt(e3) };
        case "json":
          return { $type: "Json", value: `${e3}` };
        case "bytes": {
          switch (r3.encoding) {
            case "base64":
              if (typeof e3 != "string")
                throw new q(`Expected a base64-encoded byte array in column '${t2}', got ${typeof e3}: ${e3}`);
              return { $type: "Bytes", value: e3 };
            case "hex":
              if (typeof e3 != "string" || !e3.startsWith("\\x"))
                throw new q(`Expected a hex-encoded byte array in column '${t2}', got ${typeof e3}: ${e3}`);
              return { $type: "Bytes", value: y.from(e3.slice(2), "hex").toString("base64") };
            case "array":
              if (Array.isArray(e3))
                return { $type: "Bytes", value: y.from(e3).toString("base64") };
              if (e3 instanceof Uint8Array)
                return { $type: "Bytes", value: y.from(e3).toString("base64") };
              throw new q(`Expected a byte array in column '${t2}', got ${typeof e3}: ${e3}`);
            default:
              L(r3.encoding, `DataMapper: Unknown bytes encoding: ${r3.encoding}`);
          }
          break;
        }
        case "enum": {
          let i = n2[r3.name];
          if (i === void 0)
            throw new q(`Unknown enum '${r3.name}'`);
          let o2 = i[`${e3}`];
          if (o2 === void 0)
            throw new q(`Value '${e3}' not found in enum '${r3.name}'`);
          return o2;
        }
        default:
          L(r3, `DataMapper: Unknown result type: ${r3.type}`);
      }
    }
    var Gc = /\d{2}:\d{2}:\d{2}(?:\.\d+)?(Z|[+-]\d{2}(:?\d{2})?)?$/;
    function Kc(e3) {
      let t2 = Gc.exec(e3);
      if (t2 === null)
        return `${e3}T00:00:00Z`;
      let r3 = e3, [n2, i, o2] = t2;
      if (i !== void 0 && i !== "Z" && o2 === void 0 ? r3 = `${e3}:00` : i === void 0 && (r3 = `${e3}Z`), n2.length === e3.length)
        return `1970-01-01T${r3}`;
      let s3 = t2.index - 1;
      return r3[s3] === " " && (r3 = `${r3.slice(0, s3)}T${r3.slice(s3 + 1)}`), r3;
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function zc(e3) {
      let t2 = Object.entries(e3);
      return t2.length === 0 ? "" : (t2.sort(([n2], [i]) => n2.localeCompare(i)), `/*${t2.map(([n2, i]) => {
        let o2 = encodeURIComponent(n2), s3 = encodeURIComponent(i).replace(/'/g, "\\'");
        return `${o2}='${s3}'`;
      }).join(",")}*/`);
    }
    function Hr(e3, t2) {
      let r3 = {};
      for (let n2 of e3) {
        let i = n2(t2);
        for (let [o2, s3] of Object.entries(i))
          s3 !== void 0 && (r3[o2] = s3);
      }
      return r3;
    }
    function Bs(e3, t2) {
      let r3 = Hr(e3, t2);
      return zc(r3);
    }
    function js(e3, t2) {
      return t2 ? `${e3} ${t2}` : e3;
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var Gt;
    (function(e3) {
      e3[e3.INTERNAL = 0] = "INTERNAL", e3[e3.SERVER = 1] = "SERVER", e3[e3.CLIENT = 2] = "CLIENT", e3[e3.PRODUCER = 3] = "PRODUCER", e3[e3.CONSUMER = 4] = "CONSUMER";
    })(Gt || (Gt = {}));
    function Zc(e3) {
      switch (e3) {
        case "postgresql":
        case "postgres":
        case "prisma+postgres":
          return "postgresql";
        case "sqlserver":
          return "mssql";
        case "mysql":
        case "sqlite":
        case "cockroachdb":
        case "mongodb":
          return e3;
        default:
          L(e3, `Unknown provider: ${e3}`);
      }
    }
    async function Jr({ query: e3, tracingHelper: t2, provider: r3, onQuery: n2, execute: i }) {
      return await t2.runInChildSpan({ name: "db_query", kind: Gt.CLIENT, attributes: { "db.query.text": e3.sql, "db.system.name": Zc(r3) } }, async () => {
        let o2 = /* @__PURE__ */ new Date(), s3 = w.now(), a = await i(), d = w.now();
        return n2?.({ timestamp: o2, duration: d - s3, query: e3.sql, params: e3.args }), a;
      });
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function He(e3, t2) {
      var r3 = "000000000" + e3;
      return r3.substr(r3.length - t2);
    }
    var Qs = Ue(ho(), 1);
    function Yc() {
      try {
        return Qs.default.hostname();
      } catch {
        return g.env._CLUSTER_NETWORK_NAME_ || g.env.COMPUTERNAME || "hostname";
      }
    }
    var Hs = 2;
    var Xc = He(g.pid.toString(36), Hs);
    var Js = Yc();
    var ep = Js.length;
    var tp = He(Js.split("").reduce(function(e3, t2) {
      return +e3 + t2.charCodeAt(0);
    }, +ep + 36).toString(36), Hs);
    function Xn() {
      return Xc + tp;
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function Wr(e3) {
      return typeof e3 == "string" && /^c[a-z0-9]{20,32}$/.test(e3);
    }
    function ei(e3) {
      let n2 = Math.pow(36, 4), i = 0;
      function o2() {
        return He((Math.random() * n2 << 0).toString(36), 4);
      }
      function s3() {
        return i = i < n2 ? i : 0, i++, i - 1;
      }
      function a() {
        var d = "c", f = (/* @__PURE__ */ new Date()).getTime().toString(36), P = He(s3().toString(36), 4), A = e3(), S = o2() + o2();
        return d + f + P + A + S;
      }
      return a.fingerprint = e3, a.isCuid = Wr, a;
    }
    var rp = ei(Xn);
    var Ws = rp;
    var Qa = Ue(Fa());
    l();
    u();
    c2();
    p();
    m();
    Be();
    l();
    u();
    c2();
    p();
    m();
    var Ua = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    var Bp = 128;
    var We;
    var xt;
    function jp(e3) {
      !We || We.length < e3 ? (We = y.allocUnsafe(e3 * Bp), kt.getRandomValues(We), xt = 0) : xt + e3 > We.length && (kt.getRandomValues(We), xt = 0), xt += e3;
    }
    function ui(e3 = 21) {
      jp(e3 |= 0);
      let t2 = "";
      for (let r3 = xt - e3; r3 < xt; r3++)
        t2 += Ua[We[r3] & 63];
      return t2;
    }
    l();
    u();
    c2();
    p();
    m();
    Be();
    var qa = "0123456789ABCDEFGHJKMNPQRSTVWXYZ";
    var er = 32;
    var Qp = 16;
    var Va = 10;
    var $a = 281474976710655;
    var Ge;
    (function(e3) {
      e3.Base32IncorrectEncoding = "B32_ENC_INVALID", e3.DecodeTimeInvalidCharacter = "DEC_TIME_CHAR", e3.DecodeTimeValueMalformed = "DEC_TIME_MALFORMED", e3.EncodeTimeNegative = "ENC_TIME_NEG", e3.EncodeTimeSizeExceeded = "ENC_TIME_SIZE_EXCEED", e3.EncodeTimeValueMalformed = "ENC_TIME_MALFORMED", e3.PRNGDetectFailure = "PRNG_DETECT", e3.ULIDInvalid = "ULID_INVALID", e3.Unexpected = "UNEXPECTED", e3.UUIDInvalid = "UUID_INVALID";
    })(Ge || (Ge = {}));
    var Ke = class extends Error {
      constructor(t2, r3) {
        super(`${r3} (${t2})`), this.name = "ULIDError", this.code = t2;
      }
    };
    function Hp(e3) {
      let t2 = Math.floor(e3() * er);
      return t2 === er && (t2 = er - 1), qa.charAt(t2);
    }
    function Jp(e3) {
      let t2 = Wp(), r3 = t2 && (t2.crypto || t2.msCrypto) || (typeof rt < "u" ? rt : null);
      if (typeof r3?.getRandomValues == "function")
        return () => {
          let n2 = new Uint8Array(1);
          return r3.getRandomValues(n2), n2[0] / 255;
        };
      if (typeof r3?.randomBytes == "function")
        return () => r3.randomBytes(1).readUInt8() / 255;
      if (rt?.randomBytes)
        return () => rt.randomBytes(1).readUInt8() / 255;
      throw new Ke(Ge.PRNGDetectFailure, "Failed to find a reliable PRNG");
    }
    function Wp() {
      return zp() ? self : typeof window < "u" ? window : typeof globalThis < "u" || typeof globalThis < "u" ? globalThis : null;
    }
    function Gp(e3, t2) {
      let r3 = "";
      for (; e3 > 0; e3--)
        r3 = Hp(t2) + r3;
      return r3;
    }
    function Kp(e3, t2 = Va) {
      if (isNaN(e3))
        throw new Ke(Ge.EncodeTimeValueMalformed, `Time must be a number: ${e3}`);
      if (e3 > $a)
        throw new Ke(Ge.EncodeTimeSizeExceeded, `Cannot encode a time larger than ${$a}: ${e3}`);
      if (e3 < 0)
        throw new Ke(Ge.EncodeTimeNegative, `Time must be positive: ${e3}`);
      if (Number.isInteger(e3) === false)
        throw new Ke(Ge.EncodeTimeValueMalformed, `Time must be an integer: ${e3}`);
      let r3, n2 = "";
      for (let i = t2; i > 0; i--)
        r3 = e3 % er, n2 = qa.charAt(r3) + n2, e3 = (e3 - r3) / er;
      return n2;
    }
    function zp() {
      return typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope;
    }
    function Ba(e3, t2) {
      let r3 = t2 || Jp(), n2 = !e3 || isNaN(e3) ? Date.now() : e3;
      return Kp(n2, Va) + Gp(Qp, r3);
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var z = [];
    for (let e3 = 0; e3 < 256; ++e3)
      z.push((e3 + 256).toString(16).slice(1));
    function Zr(e3, t2 = 0) {
      return (z[e3[t2 + 0]] + z[e3[t2 + 1]] + z[e3[t2 + 2]] + z[e3[t2 + 3]] + "-" + z[e3[t2 + 4]] + z[e3[t2 + 5]] + "-" + z[e3[t2 + 6]] + z[e3[t2 + 7]] + "-" + z[e3[t2 + 8]] + z[e3[t2 + 9]] + "-" + z[e3[t2 + 10]] + z[e3[t2 + 11]] + z[e3[t2 + 12]] + z[e3[t2 + 13]] + z[e3[t2 + 14]] + z[e3[t2 + 15]]).toLowerCase();
    }
    l();
    u();
    c2();
    p();
    m();
    Be();
    var Xr = new Uint8Array(256);
    var Yr = Xr.length;
    function Et() {
      return Yr > Xr.length - 16 && (wr(Xr), Yr = 0), Xr.slice(Yr, Yr += 16);
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    Be();
    var ci = { randomUUID: hr };
    function Zp(e3, t2, r3) {
      if (ci.randomUUID && !t2 && !e3)
        return ci.randomUUID();
      e3 = e3 || {};
      let n2 = e3.random ?? e3.rng?.() ?? Et();
      if (n2.length < 16)
        throw new Error("Random bytes length must be >= 16");
      if (n2[6] = n2[6] & 15 | 64, n2[8] = n2[8] & 63 | 128, t2) {
        if (r3 = r3 || 0, r3 < 0 || r3 + 16 > t2.length)
          throw new RangeError(`UUID byte range ${r3}:${r3 + 15} is out of buffer bounds`);
        for (let i = 0; i < 16; ++i)
          t2[r3 + i] = n2[i];
        return t2;
      }
      return Zr(n2);
    }
    var pi = Zp;
    l();
    u();
    c2();
    p();
    m();
    var mi = {};
    function Yp(e3, t2, r3) {
      let n2;
      if (e3)
        n2 = ja(e3.random ?? e3.rng?.() ?? Et(), e3.msecs, e3.seq, t2, r3);
      else {
        let i = Date.now(), o2 = Et();
        Xp(mi, i, o2), n2 = ja(o2, mi.msecs, mi.seq, t2, r3);
      }
      return t2 ?? Zr(n2);
    }
    function Xp(e3, t2, r3) {
      return e3.msecs ??= -1 / 0, e3.seq ??= 0, t2 > e3.msecs ? (e3.seq = r3[6] << 23 | r3[7] << 16 | r3[8] << 8 | r3[9], e3.msecs = t2) : (e3.seq = e3.seq + 1 | 0, e3.seq === 0 && e3.msecs++), e3;
    }
    function ja(e3, t2, r3, n2, i = 0) {
      if (e3.length < 16)
        throw new Error("Random bytes length must be >= 16");
      if (!n2)
        n2 = new Uint8Array(16), i = 0;
      else if (i < 0 || i + 16 > n2.length)
        throw new RangeError(`UUID byte range ${i}:${i + 15} is out of buffer bounds`);
      return t2 ??= Date.now(), r3 ??= e3[6] * 127 << 24 | e3[7] << 16 | e3[8] << 8 | e3[9], n2[i++] = t2 / 1099511627776 & 255, n2[i++] = t2 / 4294967296 & 255, n2[i++] = t2 / 16777216 & 255, n2[i++] = t2 / 65536 & 255, n2[i++] = t2 / 256 & 255, n2[i++] = t2 & 255, n2[i++] = 112 | r3 >>> 28 & 15, n2[i++] = r3 >>> 20 & 255, n2[i++] = 128 | r3 >>> 14 & 63, n2[i++] = r3 >>> 6 & 255, n2[i++] = r3 << 2 & 255 | e3[10] & 3, n2[i++] = e3[11], n2[i++] = e3[12], n2[i++] = e3[13], n2[i++] = e3[14], n2[i++] = e3[15], n2;
    }
    var di = Yp;
    var en = class {
      #t = {};
      constructor() {
        this.register("uuid", new gi()), this.register("cuid", new yi()), this.register("ulid", new hi()), this.register("nanoid", new wi()), this.register("product", new bi());
      }
      snapshot() {
        return Object.create(this.#t, { now: { value: new fi() } });
      }
      register(t2, r3) {
        this.#t[t2] = r3;
      }
    };
    var fi = class {
      #t = /* @__PURE__ */ new Date();
      generate() {
        return this.#t.toISOString();
      }
    };
    var gi = class {
      generate(t2) {
        if (t2 === 4)
          return pi();
        if (t2 === 7)
          return di();
        throw new Error("Invalid UUID generator arguments");
      }
    };
    var yi = class {
      generate(t2) {
        if (t2 === 1)
          return Ws();
        if (t2 === 2)
          return (0, Qa.createId)();
        throw new Error("Invalid CUID generator arguments");
      }
    };
    var hi = class {
      generate() {
        return Ba();
      }
    };
    var wi = class {
      generate(t2) {
        if (typeof t2 == "number")
          return ui(t2);
        if (t2 === void 0)
          return ui();
        throw new Error("Invalid Nanoid generator arguments");
      }
    };
    var bi = class {
      generate(t2, r3) {
        if (t2 === void 0 || r3 === void 0)
          throw new Error("Invalid Product generator arguments");
        return Array.isArray(t2) && Array.isArray(r3) ? t2.flatMap((n2) => r3.map((i) => [n2, i])) : Array.isArray(t2) ? t2.map((n2) => [n2, r3]) : Array.isArray(r3) ? r3.map((n2) => [t2, n2]) : [[t2, r3]];
      }
    };
    l();
    u();
    c2();
    p();
    m();
    function tn(e3, t2) {
      return e3 == null ? e3 : typeof e3 == "string" ? tn(JSON.parse(e3), t2) : Array.isArray(e3) ? tm(e3, t2) : em(e3, t2);
    }
    function em(e3, t2) {
      if (t2.pagination) {
        let { skip: r3, take: n2, cursor: i } = t2.pagination;
        if (r3 !== null && r3 > 0 || n2 === 0 || i !== null && !yt(e3, i))
          return null;
      }
      return Ja(e3, t2.nested);
    }
    function Ja(e3, t2) {
      for (let [r3, n2] of Object.entries(t2))
        e3[r3] = tn(e3[r3], n2);
      return e3;
    }
    function tm(e3, t2) {
      if (t2.distinct !== null) {
        let r3 = t2.linkingFields !== null ? [...t2.distinct, ...t2.linkingFields] : t2.distinct;
        e3 = rm(e3, r3);
      }
      return t2.pagination && (e3 = nm(e3, t2.pagination, t2.linkingFields)), t2.reverse && e3.reverse(), Object.keys(t2.nested).length === 0 ? e3 : e3.map((r3) => Ja(r3, t2.nested));
    }
    function rm(e3, t2) {
      let r3 = /* @__PURE__ */ new Set(), n2 = [];
      for (let i of e3) {
        let o2 = Tt(i, t2);
        r3.has(o2) || (r3.add(o2), n2.push(i));
      }
      return n2;
    }
    function nm(e3, t2, r3) {
      if (r3 === null)
        return Ha(e3, t2);
      let n2 = /* @__PURE__ */ new Map();
      for (let o2 of e3) {
        let s3 = Tt(o2, r3);
        n2.has(s3) || n2.set(s3, []), n2.get(s3).push(o2);
      }
      let i = Array.from(n2.entries());
      return i.sort(([o2], [s3]) => o2 < s3 ? -1 : o2 > s3 ? 1 : 0), i.flatMap(([, o2]) => Ha(o2, t2));
    }
    function Ha(e3, { cursor: t2, skip: r3, take: n2 }) {
      let i = t2 !== null ? e3.findIndex((a) => yt(a, t2)) : 0;
      if (i === -1)
        return [];
      let o2 = i + (r3 ?? 0), s3 = n2 !== null ? o2 + n2 : e3.length;
      return e3.slice(o2, s3);
    }
    function Tt(e3, t2) {
      return JSON.stringify(t2.map((r3) => e3[r3]));
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function xi(e3) {
      return typeof e3 == "object" && e3 !== null && e3.prisma__type === "param";
    }
    function Ei(e3) {
      return typeof e3 == "object" && e3 !== null && e3.prisma__type === "generatorCall";
    }
    function Ai(e3, t2, r3, n2) {
      let i = e3.args.map((o2) => me(o2, t2, r3));
      switch (e3.type) {
        case "rawSql":
          return [sm(e3.sql, i, e3.argTypes)];
        case "templateSql":
          return (e3.chunkable ? lm(e3.fragments, i, n2) : [i]).map((s3) => {
            if (n2 !== void 0 && s3.length > n2)
              throw new te("The query parameter limit supported by your database is exceeded.", "P2029");
            return im(e3.fragments, e3.placeholderFormat, s3, e3.argTypes);
          });
        default:
          L(e3.type, "Invalid query type");
      }
    }
    function me(e3, t2, r3) {
      for (; am(e3); )
        if (xi(e3)) {
          let n2 = t2[e3.prisma__value.name];
          if (n2 === void 0)
            throw new Error(`Missing value for query variable ${e3.prisma__value.name}`);
          e3 = n2;
        } else if (Ei(e3)) {
          let { name: n2, args: i } = e3.prisma__value, o2 = r3[n2];
          if (!o2)
            throw new Error(`Encountered an unknown generator '${n2}'`);
          e3 = o2.generate(...i.map((s3) => me(s3, t2, r3)));
        } else
          L(e3, `Unexpected unevaluated value type: ${e3}`);
      return Array.isArray(e3) && (e3 = e3.map((n2) => me(n2, t2, r3))), e3;
    }
    function im(e3, t2, r3, n2) {
      let i = "", o2 = { placeholderNumber: 1 }, s3 = [], a = [];
      for (let d of Pi(e3, r3, n2)) {
        if (i += om(d, t2, o2), d.type === "stringChunk")
          continue;
        let f = s3.length, P = s3.push(...Wa(d)) - f;
        if (d.argType.arity === "tuple") {
          if (P % d.argType.elements.length !== 0)
            throw new Error(`Malformed query template. Expected the number of parameters to match the tuple arity, but got ${P} parameters for a tuple of arity ${d.argType.elements.length}.`);
          for (let A = 0; A < P / d.argType.elements.length; A++)
            a.push(...d.argType.elements);
        } else
          for (let A = 0; A < P; A++)
            a.push(d.argType);
      }
      return { sql: i, args: s3, argTypes: a };
    }
    function om(e3, t2, r3) {
      let n2 = e3.type;
      switch (n2) {
        case "parameter":
          return Ti(t2, r3.placeholderNumber++);
        case "stringChunk":
          return e3.chunk;
        case "parameterTuple":
          return `(${e3.value.length == 0 ? "NULL" : e3.value.map(() => Ti(t2, r3.placeholderNumber++)).join(",")})`;
        case "parameterTupleList":
          return e3.value.map((i) => {
            let o2 = i.map(() => Ti(t2, r3.placeholderNumber++)).join(e3.itemSeparator);
            return `${e3.itemPrefix}${o2}${e3.itemSuffix}`;
          }).join(e3.groupSeparator);
        default:
          L(n2, "Invalid fragment type");
      }
    }
    function Ti(e3, t2) {
      return e3.hasNumbering ? `${e3.prefix}${t2}` : e3.prefix;
    }
    function sm(e3, t2, r3) {
      return { sql: e3, args: t2, argTypes: r3 };
    }
    function am(e3) {
      return xi(e3) || Ei(e3);
    }
    function* Pi(e3, t2, r3) {
      let n2 = 0;
      for (let i of e3)
        switch (i.type) {
          case "parameter": {
            if (n2 >= t2.length)
              throw new Error(`Malformed query template. Fragments attempt to read over ${t2.length} parameters.`);
            yield { ...i, value: t2[n2], argType: r3?.[n2] }, n2++;
            break;
          }
          case "stringChunk": {
            yield i;
            break;
          }
          case "parameterTuple": {
            if (n2 >= t2.length)
              throw new Error(`Malformed query template. Fragments attempt to read over ${t2.length} parameters.`);
            let o2 = t2[n2];
            yield { ...i, value: Array.isArray(o2) ? o2 : [o2], argType: r3?.[n2] }, n2++;
            break;
          }
          case "parameterTupleList": {
            if (n2 >= t2.length)
              throw new Error(`Malformed query template. Fragments attempt to read over ${t2.length} parameters.`);
            let o2 = t2[n2];
            if (!Array.isArray(o2))
              throw new Error("Malformed query template. Tuple list expected.");
            if (o2.length === 0)
              throw new Error("Malformed query template. Tuple list cannot be empty.");
            for (let s3 of o2)
              if (!Array.isArray(s3))
                throw new Error("Malformed query template. Tuple expected.");
            yield { ...i, value: o2, argType: r3?.[n2] }, n2++;
            break;
          }
        }
    }
    function* Wa(e3) {
      switch (e3.type) {
        case "parameter":
          yield e3.value;
          break;
        case "stringChunk":
          break;
        case "parameterTuple":
          yield* e3.value;
          break;
        case "parameterTupleList":
          for (let t2 of e3.value)
            yield* t2;
          break;
      }
    }
    function lm(e3, t2, r3) {
      let n2 = 0, i = 0;
      for (let s3 of Pi(e3, t2, void 0)) {
        let a = 0;
        for (let d of Wa(s3))
          a++;
        i = Math.max(i, a), n2 += a;
      }
      let o2 = [[]];
      for (let s3 of Pi(e3, t2, void 0))
        switch (s3.type) {
          case "parameter": {
            for (let a of o2)
              a.push(s3.value);
            break;
          }
          case "stringChunk":
            break;
          case "parameterTuple": {
            let a = s3.value.length, d = [];
            if (r3 && o2.length === 1 && a === i && n2 > r3 && n2 - a < r3) {
              let f = r3 - (n2 - a);
              d = um(s3.value, f);
            } else
              d = [s3.value];
            o2 = o2.flatMap((f) => d.map((P) => [...f, P]));
            break;
          }
          case "parameterTupleList": {
            let a = s3.value.reduce((A, S) => A + S.length, 0), d = [], f = [], P = 0;
            for (let A of s3.value)
              r3 && o2.length === 1 && a === i && f.length > 0 && n2 - a + P + A.length > r3 && (d.push(f), f = [], P = 0), f.push(A), P += A.length;
            f.length > 0 && d.push(f), o2 = o2.flatMap((A) => d.map((S) => [...A, S]));
            break;
          }
        }
      return o2;
    }
    function um(e3, t2) {
      let r3 = [];
      for (let n2 = 0; n2 < e3.length; n2 += t2)
        r3.push(e3.slice(n2, n2 + t2));
      return r3;
    }
    l();
    u();
    c2();
    p();
    m();
    function Ga(e3) {
      return e3.rows.map((t2) => t2.reduce((r3, n2, i) => (r3[e3.columnNames[i]] = n2, r3), {}));
    }
    function Ka(e3) {
      return { columns: e3.columnNames, types: e3.columnTypes.map((t2) => cm(t2)), rows: e3.rows.map((t2) => t2.map((r3, n2) => Pt(r3, e3.columnTypes[n2]))) };
    }
    function Pt(e3, t2) {
      if (e3 === null)
        return null;
      switch (t2) {
        case I.Int32:
          switch (typeof e3) {
            case "number":
              return Math.trunc(e3);
            case "string":
              return Math.trunc(Number(e3));
            default:
              throw new Error(`Cannot serialize value of type ${typeof e3} as Int32`);
          }
        case I.Int32Array:
          if (!Array.isArray(e3))
            throw new Error(`Cannot serialize value of type ${typeof e3} as Int32Array`);
          return e3.map((r3) => Pt(r3, I.Int32));
        case I.Int64:
          switch (typeof e3) {
            case "number":
              return BigInt(Math.trunc(e3));
            case "string":
              return e3;
            default:
              throw new Error(`Cannot serialize value of type ${typeof e3} as Int64`);
          }
        case I.Int64Array:
          if (!Array.isArray(e3))
            throw new Error(`Cannot serialize value of type ${typeof e3} as Int64Array`);
          return e3.map((r3) => Pt(r3, I.Int64));
        case I.Json:
          switch (typeof e3) {
            case "string":
              return JSON.parse(e3);
            default:
              throw new Error(`Cannot serialize value of type ${typeof e3} as Json`);
          }
        case I.JsonArray:
          if (!Array.isArray(e3))
            throw new Error(`Cannot serialize value of type ${typeof e3} as JsonArray`);
          return e3.map((r3) => Pt(r3, I.Json));
        case I.Bytes:
          if (Array.isArray(e3))
            return new Uint8Array(e3);
          throw new Error(`Cannot serialize value of type ${typeof e3} as Bytes`);
        case I.BytesArray:
          if (!Array.isArray(e3))
            throw new Error(`Cannot serialize value of type ${typeof e3} as BytesArray`);
          return e3.map((r3) => Pt(r3, I.Bytes));
        case I.Boolean:
          switch (typeof e3) {
            case "boolean":
              return e3;
            case "string":
              return e3 === "true" || e3 === "1";
            case "number":
              return e3 === 1;
            default:
              throw new Error(`Cannot serialize value of type ${typeof e3} as Boolean`);
          }
        case I.BooleanArray:
          if (!Array.isArray(e3))
            throw new Error(`Cannot serialize value of type ${typeof e3} as BooleanArray`);
          return e3.map((r3) => Pt(r3, I.Boolean));
        default:
          return e3;
      }
    }
    function cm(e3) {
      switch (e3) {
        case I.Int32:
          return "int";
        case I.Int64:
          return "bigint";
        case I.Float:
          return "float";
        case I.Double:
          return "double";
        case I.Text:
          return "string";
        case I.Enum:
          return "enum";
        case I.Bytes:
          return "bytes";
        case I.Boolean:
          return "bool";
        case I.Character:
          return "char";
        case I.Numeric:
          return "decimal";
        case I.Json:
          return "json";
        case I.Uuid:
          return "uuid";
        case I.DateTime:
          return "datetime";
        case I.Date:
          return "date";
        case I.Time:
          return "time";
        case I.Int32Array:
          return "int-array";
        case I.Int64Array:
          return "bigint-array";
        case I.FloatArray:
          return "float-array";
        case I.DoubleArray:
          return "double-array";
        case I.TextArray:
          return "string-array";
        case I.EnumArray:
          return "string-array";
        case I.BytesArray:
          return "bytes-array";
        case I.BooleanArray:
          return "bool-array";
        case I.CharacterArray:
          return "char-array";
        case I.NumericArray:
          return "decimal-array";
        case I.JsonArray:
          return "json-array";
        case I.UuidArray:
          return "uuid-array";
        case I.DateTimeArray:
          return "datetime-array";
        case I.DateArray:
          return "date-array";
        case I.TimeArray:
          return "time-array";
        case I.UnknownNumber:
          return "unknown";
        case I.Set:
          return "string";
        default:
          L(e3, `Unexpected column type: ${e3}`);
      }
    }
    l();
    u();
    c2();
    p();
    m();
    function za(e3, t2, r3) {
      if (!t2.every((n2) => vi(e3, n2))) {
        let n2 = pm(e3, r3), i = mm(r3);
        throw new te(n2, i, r3.context);
      }
    }
    function vi(e3, t2) {
      switch (t2.type) {
        case "rowCountEq":
          return Array.isArray(e3) ? e3.length === t2.args : e3 === null ? t2.args === 0 : t2.args === 1;
        case "rowCountNeq":
          return Array.isArray(e3) ? e3.length !== t2.args : e3 === null ? t2.args !== 0 : t2.args !== 1;
        case "affectedRowCountEq":
          return e3 === t2.args;
        case "never":
          return false;
        default:
          L(t2, `Unknown rule type: ${t2.type}`);
      }
    }
    function pm(e3, t2) {
      switch (t2.error_identifier) {
        case "RELATION_VIOLATION":
          return `The change you are trying to make would violate the required relation '${t2.context.relation}' between the \`${t2.context.modelA}\` and \`${t2.context.modelB}\` models.`;
        case "MISSING_RECORD":
          return `An operation failed because it depends on one or more records that were required but not found. No record was found for ${t2.context.operation}.`;
        case "MISSING_RELATED_RECORD": {
          let r3 = t2.context.neededFor ? ` (needed to ${t2.context.neededFor})` : "";
          return `An operation failed because it depends on one or more records that were required but not found. No '${t2.context.model}' record${r3} was found for ${t2.context.operation} on ${t2.context.relationType} relation '${t2.context.relation}'.`;
        }
        case "INCOMPLETE_CONNECT_INPUT":
          return `An operation failed because it depends on one or more records that were required but not found. Expected ${t2.context.expectedRows} records to be connected, found only ${Array.isArray(e3) ? e3.length : e3}.`;
        case "INCOMPLETE_CONNECT_OUTPUT":
          return `The required connected records were not found. Expected ${t2.context.expectedRows} records to be connected after connect operation on ${t2.context.relationType} relation '${t2.context.relation}', found ${Array.isArray(e3) ? e3.length : e3}.`;
        case "RECORDS_NOT_CONNECTED":
          return `The records for relation \`${t2.context.relation}\` between the \`${t2.context.parent}\` and \`${t2.context.child}\` models are not connected.`;
        default:
          L(t2, `Unknown error identifier: ${t2}`);
      }
    }
    function mm(e3) {
      switch (e3.error_identifier) {
        case "RELATION_VIOLATION":
          return "P2014";
        case "RECORDS_NOT_CONNECTED":
          return "P2017";
        case "INCOMPLETE_CONNECT_OUTPUT":
          return "P2018";
        case "MISSING_RECORD":
        case "MISSING_RELATED_RECORD":
        case "INCOMPLETE_CONNECT_INPUT":
          return "P2025";
        default:
          L(e3, `Unknown error identifier: ${e3}`);
      }
    }
    var tr = class e3 {
      #t;
      #e;
      #r;
      #n = new en();
      #l;
      #i;
      #s;
      #o;
      #u;
      #a;
      constructor({ transactionManager: t2, placeholderValues: r3, onQuery: n2, tracingHelper: i, serializer: o2, rawSerializer: s3, provider: a, connectionInfo: d, sqlCommenter: f }) {
        this.#t = t2, this.#e = r3, this.#r = n2, this.#l = i, this.#i = o2, this.#s = s3 ?? o2, this.#o = a, this.#u = d, this.#a = f;
      }
      static forSql(t2) {
        return new e3({ transactionManager: t2.transactionManager, placeholderValues: t2.placeholderValues, onQuery: t2.onQuery, tracingHelper: t2.tracingHelper, serializer: Ga, rawSerializer: Ka, provider: t2.provider, connectionInfo: t2.connectionInfo, sqlCommenter: t2.sqlCommenter });
      }
      async run(t2, r3) {
        let { value: n2 } = await this.interpretNode(t2, r3, this.#e, this.#n.snapshot()).catch((i) => ht(i));
        return n2;
      }
      async interpretNode(t2, r3, n2, i) {
        switch (t2.type) {
          case "value":
            return { value: me(t2.args, n2, i) };
          case "seq": {
            let o2;
            for (let s3 of t2.args)
              o2 = await this.interpretNode(s3, r3, n2, i);
            return o2 ?? { value: void 0 };
          }
          case "get":
            return { value: n2[t2.args.name] };
          case "let": {
            let o2 = Object.create(n2);
            for (let s3 of t2.args.bindings) {
              let { value: a } = await this.interpretNode(s3.expr, r3, o2, i);
              o2[s3.name] = a;
            }
            return this.interpretNode(t2.args.expr, r3, o2, i);
          }
          case "getFirstNonEmpty": {
            for (let o2 of t2.args.names) {
              let s3 = n2[o2];
              if (!Za(s3))
                return { value: s3 };
            }
            return { value: [] };
          }
          case "concat": {
            let o2 = await Promise.all(t2.args.map((s3) => this.interpretNode(s3, r3, n2, i).then((a) => a.value)));
            return { value: o2.length > 0 ? o2.reduce((s3, a) => s3.concat(Ci(a)), []) : [] };
          }
          case "sum": {
            let o2 = await Promise.all(t2.args.map((s3) => this.interpretNode(s3, r3, n2, i).then((a) => a.value)));
            return { value: o2.length > 0 ? o2.reduce((s3, a) => Ee(s3) + Ee(a)) : 0 };
          }
          case "execute": {
            let o2 = Ai(t2.args, n2, i, this.#c()), s3 = 0;
            for (let a of o2) {
              let d = this.#d(a);
              s3 += await this.#m(d, r3, () => r3.executeRaw(d).catch((f) => t2.args.type === "rawSql" ? zn(f) : ht(f)));
            }
            return { value: s3 };
          }
          case "query": {
            let o2 = Ai(t2.args, n2, i, this.#c()), s3;
            for (let a of o2) {
              let d = this.#d(a), f = await this.#m(d, r3, () => r3.queryRaw(d).catch((P) => t2.args.type === "rawSql" ? zn(P) : ht(P)));
              s3 === void 0 ? s3 = f : (s3.rows.push(...f.rows), s3.lastInsertId = f.lastInsertId);
            }
            return { value: t2.args.type === "rawSql" ? this.#s(s3) : this.#i(s3), lastInsertId: s3?.lastInsertId };
          }
          case "reverse": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args, r3, n2, i);
            return { value: Array.isArray(o2) ? o2.reverse() : o2, lastInsertId: s3 };
          }
          case "unique": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args, r3, n2, i);
            if (!Array.isArray(o2))
              return { value: o2, lastInsertId: s3 };
            if (o2.length > 1)
              throw new Error(`Expected zero or one element, got ${o2.length}`);
            return { value: o2[0] ?? null, lastInsertId: s3 };
          }
          case "required": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args, r3, n2, i);
            if (Za(o2))
              throw new Error("Required value is empty");
            return { value: o2, lastInsertId: s3 };
          }
          case "mapField": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args.records, r3, n2, i);
            return { value: Ya(o2, t2.args.field), lastInsertId: s3 };
          }
          case "join": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args.parent, r3, n2, i);
            if (o2 === null)
              return { value: null, lastInsertId: s3 };
            let a = await Promise.all(t2.args.children.map(async (d) => ({ joinExpr: d, childRecords: (await this.interpretNode(d.child, r3, n2, i)).value })));
            return { value: dm(o2, a), lastInsertId: s3 };
          }
          case "transaction": {
            if (!this.#t.enabled)
              return this.interpretNode(t2.args, r3, n2, i);
            let o2 = this.#t.manager, s3 = await o2.startInternalTransaction(), a = await o2.getTransaction(s3, "query");
            try {
              let d = await this.interpretNode(t2.args, a, n2, i);
              return await o2.commitTransaction(s3.id), d;
            } catch (d) {
              throw await o2.rollbackTransaction(s3.id), d;
            }
          }
          case "dataMap": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args.expr, r3, n2, i);
            return { value: Vs(o2, t2.args.structure, t2.args.enums), lastInsertId: s3 };
          }
          case "validate": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args.expr, r3, n2, i);
            return za(o2, t2.args.rules, t2.args), { value: o2, lastInsertId: s3 };
          }
          case "if": {
            let { value: o2 } = await this.interpretNode(t2.args.value, r3, n2, i);
            return vi(o2, t2.args.rule) ? await this.interpretNode(t2.args.then, r3, n2, i) : await this.interpretNode(t2.args.else, r3, n2, i);
          }
          case "unit":
            return { value: void 0 };
          case "diff": {
            let { value: o2 } = await this.interpretNode(t2.args.from, r3, n2, i), { value: s3 } = await this.interpretNode(t2.args.to, r3, n2, i), a = (f) => f !== null ? Tt(rn(f), t2.args.fields) : null, d = new Set(Ci(s3).map(a));
            return { value: Ci(o2).filter((f) => !d.has(a(f))) };
          }
          case "process": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args.expr, r3, n2, i);
            return { value: tn(o2, t2.args.operations), lastInsertId: s3 };
          }
          case "initializeRecord": {
            let { lastInsertId: o2 } = await this.interpretNode(t2.args.expr, r3, n2, i), s3 = {};
            for (let [a, d] of Object.entries(t2.args.fields))
              s3[a] = fm(d, o2, n2, i);
            return { value: s3, lastInsertId: o2 };
          }
          case "mapRecord": {
            let { value: o2, lastInsertId: s3 } = await this.interpretNode(t2.args.expr, r3, n2, i), a = o2 === null ? {} : rn(o2);
            for (let [d, f] of Object.entries(t2.args.fields))
              a[d] = gm(f, a[d], n2, i);
            return { value: a, lastInsertId: s3 };
          }
          default:
            L(t2, `Unexpected node type: ${t2.type}`);
        }
      }
      #c() {
        return this.#u?.maxBindValues !== void 0 ? this.#u.maxBindValues : this.#p();
      }
      #p() {
        if (this.#o !== void 0)
          switch (this.#o) {
            case "cockroachdb":
            case "postgres":
            case "postgresql":
            case "prisma+postgres":
              return 32766;
            case "mysql":
              return 65535;
            case "sqlite":
              return 999;
            case "sqlserver":
              return 2098;
            case "mongodb":
              return;
            default:
              L(this.#o, `Unexpected provider: ${this.#o}`);
          }
      }
      #m(t2, r3, n2) {
        return Jr({ query: t2, execute: n2, provider: this.#o ?? r3.provider, tracingHelper: this.#l, onQuery: this.#r });
      }
      #d(t2) {
        if (!this.#a || this.#a.plugins.length === 0)
          return t2;
        let r3 = Bs(this.#a.plugins, { query: this.#a.queryInfo, sql: t2.sql });
        return r3 ? { ...t2, sql: js(t2.sql, r3) } : t2;
      }
    };
    function Za(e3) {
      return Array.isArray(e3) ? e3.length === 0 : e3 == null;
    }
    function Ci(e3) {
      return Array.isArray(e3) ? e3 : [e3];
    }
    function Ee(e3) {
      if (typeof e3 == "number")
        return e3;
      if (typeof e3 == "string")
        return Number(e3);
      throw new Error(`Expected number, got ${typeof e3}`);
    }
    function rn(e3) {
      if (typeof e3 == "object" && e3 !== null)
        return e3;
      throw new Error(`Expected object, got ${typeof e3}`);
    }
    function Ya(e3, t2) {
      return Array.isArray(e3) ? e3.map((r3) => Ya(r3, t2)) : typeof e3 == "object" && e3 !== null ? e3[t2] ?? null : e3;
    }
    function dm(e3, t2) {
      for (let { joinExpr: r3, childRecords: n2 } of t2) {
        let i = r3.on.map(([a]) => a), o2 = r3.on.map(([, a]) => a), s3 = {};
        for (let a of Array.isArray(e3) ? e3 : [e3]) {
          let d = rn(a), f = Tt(d, i);
          s3[f] || (s3[f] = []), s3[f].push(d), r3.isRelationUnique ? d[r3.parentField] = null : d[r3.parentField] = [];
        }
        for (let a of Array.isArray(n2) ? n2 : [n2]) {
          if (a === null)
            continue;
          let d = Tt(rn(a), o2);
          for (let f of s3[d] ?? [])
            r3.isRelationUnique ? f[r3.parentField] = a : f[r3.parentField].push(a);
        }
      }
      return e3;
    }
    function fm(e3, t2, r3, n2) {
      switch (e3.type) {
        case "value":
          return me(e3.value, r3, n2);
        case "lastInsertId":
          return t2;
        default:
          L(e3, `Unexpected field initializer type: ${e3.type}`);
      }
    }
    function gm(e3, t2, r3, n2) {
      switch (e3.type) {
        case "set":
          return me(e3.value, r3, n2);
        case "add":
          return Ee(t2) + Ee(me(e3.value, r3, n2));
        case "subtract":
          return Ee(t2) - Ee(me(e3.value, r3, n2));
        case "multiply":
          return Ee(t2) * Ee(me(e3.value, r3, n2));
        case "divide": {
          let i = Ee(t2), o2 = Ee(me(e3.value, r3, n2));
          return o2 === 0 ? null : i / o2;
        }
        default:
          L(e3, `Unexpected field operation type: ${e3.type}`);
      }
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    async function ym() {
      return globalThis.crypto ?? await Promise.resolve().then(() => (Be(), In));
    }
    async function Xa() {
      return (await ym()).randomUUID();
    }
    l();
    u();
    c2();
    p();
    m();
    async function el(e3, t2) {
      return new Promise((r3) => {
        e3.addEventListener(t2, r3, { once: true });
      });
    }
    l();
    u();
    c2();
    p();
    m();
    var ue = class extends te {
      name = "TransactionManagerError";
      constructor(t2, r3) {
        super("Transaction API error: " + t2, "P2028", r3);
      }
    };
    var rr = class extends ue {
      constructor() {
        super("Transaction not found. Transaction ID is invalid, refers to an old closed transaction Prisma doesn't have information about anymore, or was obtained before disconnecting.");
      }
    };
    var nn = class extends ue {
      constructor(t2) {
        super(`Transaction already closed: A ${t2} cannot be executed on a committed transaction.`);
      }
    };
    var on = class extends ue {
      constructor(t2) {
        super(`Transaction already closed: A ${t2} cannot be executed on a transaction that was rolled back.`);
      }
    };
    var sn = class extends ue {
      constructor() {
        super("Unable to start a transaction in the given time.");
      }
    };
    var an = class extends ue {
      constructor(t2, { timeout: r3, timeTaken: n2 }) {
        super(`A ${t2} cannot be executed on an expired transaction. The timeout for this transaction was ${r3} ms, however ${n2} ms passed since the start of the transaction. Consider increasing the interactive transaction timeout or doing less work in the transaction.`, { operation: t2, timeout: r3, timeTaken: n2 });
      }
    };
    var At = class extends ue {
      constructor(t2) {
        super(`Internal Consistency Error: ${t2}`);
      }
    };
    var ln = class extends ue {
      constructor(t2) {
        super(`Invalid isolation level: ${t2}`, { isolationLevel: t2 });
      }
    };
    var hm = 100;
    var nr = Y("prisma:client:transactionManager");
    var wm = () => ({ sql: "COMMIT", args: [], argTypes: [] });
    var bm = () => ({ sql: "ROLLBACK", args: [], argTypes: [] });
    var xm = () => ({ sql: '-- Implicit "COMMIT" query via underlying driver', args: [], argTypes: [] });
    var Em = () => ({ sql: '-- Implicit "ROLLBACK" query via underlying driver', args: [], argTypes: [] });
    var ir = class {
      transactions = /* @__PURE__ */ new Map();
      closedTransactions = [];
      driverAdapter;
      transactionOptions;
      tracingHelper;
      #t;
      #e;
      constructor({ driverAdapter: t2, transactionOptions: r3, tracingHelper: n2, onQuery: i, provider: o2 }) {
        this.driverAdapter = t2, this.transactionOptions = r3, this.tracingHelper = n2, this.#t = i, this.#e = o2;
      }
      async startInternalTransaction(t2) {
        let r3 = t2 !== void 0 ? this.#s(t2) : {};
        return await this.tracingHelper.runInChildSpan("start_transaction", () => this.#r(r3));
      }
      async startTransaction(t2) {
        let r3 = t2 !== void 0 ? this.#s(t2) : this.transactionOptions;
        return await this.tracingHelper.runInChildSpan("start_transaction", () => this.#r(r3));
      }
      async #r(t2) {
        let r3 = { id: await Xa(), status: "waiting", timer: void 0, timeout: t2.timeout, startedAt: Date.now(), transaction: void 0 }, n2 = new AbortController(), i = tl(() => n2.abort(), t2.maxWait);
        switch (i?.unref?.(), r3.transaction = await Promise.race([this.driverAdapter.startTransaction(t2.isolationLevel).catch(ht).finally(() => clearTimeout(i)), el(n2.signal, "abort").then(() => {
        })]), this.transactions.set(r3.id, r3), r3.status) {
          case "waiting":
            if (n2.signal.aborted)
              throw await this.#i(r3, "timed_out"), new sn();
            return r3.status = "running", r3.timer = this.#l(r3.id, t2.timeout), { id: r3.id };
          case "timed_out":
          case "running":
          case "committed":
          case "rolled_back":
            throw new At(`Transaction in invalid state ${r3.status} although it just finished startup.`);
          default:
            L(r3.status, "Unknown transaction status.");
        }
      }
      async commitTransaction(t2) {
        return await this.tracingHelper.runInChildSpan("commit_transaction", async () => {
          let r3 = this.#n(t2, "commit");
          await this.#i(r3, "committed");
        });
      }
      async rollbackTransaction(t2) {
        return await this.tracingHelper.runInChildSpan("rollback_transaction", async () => {
          let r3 = this.#n(t2, "rollback");
          await this.#i(r3, "rolled_back");
        });
      }
      async getTransaction(t2, r3) {
        let n2 = this.#n(t2.id, r3);
        if (n2.status === "closing" && (await n2.closing, n2 = this.#n(t2.id, r3)), !n2.transaction)
          throw new rr();
        return n2.transaction;
      }
      #n(t2, r3) {
        let n2 = this.transactions.get(t2);
        if (!n2) {
          let i = this.closedTransactions.find((o2) => o2.id === t2);
          if (i)
            switch (nr("Transaction already closed.", { transactionId: t2, status: i.status }), i.status) {
              case "closing":
              case "waiting":
              case "running":
                throw new At("Active transaction found in closed transactions list.");
              case "committed":
                throw new nn(r3);
              case "rolled_back":
                throw new on(r3);
              case "timed_out":
                throw new an(r3, { timeout: i.timeout, timeTaken: Date.now() - i.startedAt });
            }
          else
            throw nr("Transaction not found.", t2), new rr();
        }
        if (["committed", "rolled_back", "timed_out"].includes(n2.status))
          throw new At("Closed transaction found in active transactions map.");
        return n2;
      }
      async cancelAllTransactions() {
        await Promise.allSettled([...this.transactions.values()].map((t2) => this.#i(t2, "rolled_back")));
      }
      #l(t2, r3) {
        let n2 = Date.now(), i = tl(async () => {
          nr("Transaction timed out.", { transactionId: t2, timeoutStartedAt: n2, timeout: r3 });
          let o2 = this.transactions.get(t2);
          o2 && ["running", "waiting"].includes(o2.status) ? await this.#i(o2, "timed_out") : nr("Transaction already committed or rolled back when timeout happened.", t2);
        }, r3);
        return i?.unref?.(), i;
      }
      async #i(t2, r3) {
        let n2 = async () => {
          nr("Closing transaction.", { transactionId: t2.id, status: r3 });
          try {
            if (t2.transaction && r3 === "committed")
              if (t2.transaction.options.usePhantomQuery)
                await this.#o(xm(), t2.transaction, () => t2.transaction.commit());
              else {
                let i = wm();
                await this.#o(i, t2.transaction, () => t2.transaction.executeRaw(i)).then(() => t2.transaction.commit(), (o2) => {
                  let s3 = () => Promise.reject(o2);
                  return t2.transaction.rollback().then(s3, s3);
                });
              }
            else if (t2.transaction)
              if (t2.transaction.options.usePhantomQuery)
                await this.#o(Em(), t2.transaction, () => t2.transaction.rollback());
              else {
                let i = bm();
                try {
                  await this.#o(i, t2.transaction, () => t2.transaction.executeRaw(i));
                } finally {
                  await t2.transaction.rollback();
                }
              }
          } finally {
            t2.status = r3, clearTimeout(t2.timer), t2.timer = void 0, this.transactions.delete(t2.id), this.closedTransactions.push(t2), this.closedTransactions.length > hm && this.closedTransactions.shift();
          }
        };
        t2.status === "closing" ? (await t2.closing, this.#n(t2.id, r3 === "committed" ? "commit" : "rollback")) : await Object.assign(t2, { status: "closing", reason: r3, closing: n2() }).closing;
      }
      #s(t2) {
        if (!t2.timeout)
          throw new ue("timeout is required");
        if (!t2.maxWait)
          throw new ue("maxWait is required");
        if (t2.isolationLevel === "SNAPSHOT")
          throw new ln(t2.isolationLevel);
        return { ...t2, timeout: t2.timeout, maxWait: t2.maxWait };
      }
      #o(t2, r3, n2) {
        return Jr({ query: t2, execute: n2, provider: this.#e ?? r3.provider, tracingHelper: this.tracingHelper, onQuery: this.#t });
      }
    };
    function tl(e3, t2) {
      return t2 !== void 0 ? setTimeout(e3, t2) : void 0;
    }
    var Z = require_dist();
    var un = "7.1.0";
    l();
    u();
    c2();
    p();
    m();
    function rl(e3, t2) {
      return { batch: e3, transaction: t2?.kind === "batch" ? { isolationLevel: t2.options.isolationLevel } : void 0 };
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    function nl(e3) {
      return e3 ? e3.replace(/".*"/g, '"X"').replace(/[\s:\[]([+-]?([0-9]*[.])?[0-9]+)/g, (t2) => `${t2[0]}5`) : "";
    }
    l();
    u();
    c2();
    p();
    m();
    function il(e3) {
      return e3.split(`
`).map((t2) => t2.replace(/^\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z)\s*/, "").replace(/\+\d+\s*ms$/, "")).join(`
`);
    }
    l();
    u();
    c2();
    p();
    m();
    var ol = Ue(vo());
    function sl({ title: e3, user: t2 = "prisma", repo: r3 = "prisma", template: n2 = "bug_report.yml", body: i }) {
      return (0, ol.default)({ user: t2, repo: r3, template: n2, title: e3, body: i });
    }
    function al({ version: e3, binaryTarget: t2, title: r3, description: n2, engineVersion: i, database: o2, query: s3 }) {
      let a = fo(6e3 - (s3?.length ?? 0)), d = il(nt(a)), f = n2 ? `# Description
\`\`\`
${n2}
\`\`\`` : "", P = nt(`Hi Prisma Team! My Prisma Client just crashed. This is the report:
## Versions

| Name            | Version            |
|-----------------|--------------------|
| Node            | ${g.version?.padEnd(19)}| 
| OS              | ${t2?.padEnd(19)}|
| Prisma Client   | ${e3?.padEnd(19)}|
| Query Engine    | ${i?.padEnd(19)}|
| Database        | ${o2?.padEnd(19)}|

${f}

## Logs
\`\`\`
${d}
\`\`\`

## Client Snippet
\`\`\`ts
// PLEASE FILL YOUR CODE SNIPPET HERE
\`\`\`

## Schema
\`\`\`prisma
// PLEASE ADD YOUR SCHEMA HERE IF POSSIBLE
\`\`\`

## Prisma Engine Query
\`\`\`
${s3 ? nl(s3) : ""}
\`\`\`
`), A = sl({ title: r3, body: P });
      return `${r3}

This is a non-recoverable error which probably happens when the Prisma Query Engine has a panic.

${yr(A)}

If you want the Prisma team to look into it, please open the link above \u{1F64F}
To increase the chance of success, please post your schema and a snippet of
how you used Prisma Client in the issue. 
`;
    }
    l();
    u();
    c2();
    p();
    m();
    var cn = class e3 {
      #t;
      #e;
      #r;
      #n;
      constructor(t2, r3, n2) {
        this.#t = t2, this.#e = r3, this.#r = n2, this.#n = r3.getConnectionInfo?.();
      }
      static async connect(t2) {
        let r3, n2;
        try {
          r3 = await t2.driverAdapterFactory.connect(), n2 = new ir({ driverAdapter: r3, transactionOptions: t2.transactionOptions, tracingHelper: t2.tracingHelper, onQuery: t2.onQuery, provider: t2.provider });
        } catch (i) {
          throw await r3?.dispose(), i;
        }
        return new e3(t2, r3, n2);
      }
      getConnectionInfo() {
        let t2 = this.#n ?? { supportsRelationJoins: false };
        return Promise.resolve({ provider: this.#e.provider, connectionInfo: t2 });
      }
      async execute({ plan: t2, placeholderValues: r3, transaction: n2, batchIndex: i, queryInfo: o2 }) {
        let s3 = n2 ? await this.#r.getTransaction(n2, i !== void 0 ? "batch query" : "query") : this.#e;
        return await tr.forSql({ transactionManager: n2 ? { enabled: false } : { enabled: true, manager: this.#r }, placeholderValues: r3, onQuery: this.#t.onQuery, tracingHelper: this.#t.tracingHelper, provider: this.#t.provider, connectionInfo: this.#n, sqlCommenter: this.#t.sqlCommenters && { plugins: this.#t.sqlCommenters, queryInfo: o2 } }).run(t2, s3);
      }
      async startTransaction(t2) {
        return { ...await this.#r.startTransaction(t2), payload: void 0 };
      }
      async commitTransaction(t2) {
        await this.#r.commitTransaction(t2.id);
      }
      async rollbackTransaction(t2) {
        await this.#r.rollbackTransaction(t2.id);
      }
      async disconnect() {
        try {
          await this.#r.cancelAllTransactions();
        } finally {
          await this.#e.dispose();
        }
      }
      apiKey() {
        return null;
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var dl = require_dist();
    l();
    u();
    c2();
    p();
    m();
    var pn = /^[\u0009\u0020-\u007E\u0080-\u00FF]+$/;
    function ll(e3, t2, r3) {
      let n2 = r3 || {}, i = n2.encode || encodeURIComponent;
      if (typeof i != "function")
        throw new TypeError("option encode is invalid");
      if (!pn.test(e3))
        throw new TypeError("argument name is invalid");
      let o2 = i(t2);
      if (o2 && !pn.test(o2))
        throw new TypeError("argument val is invalid");
      let s3 = e3 + "=" + o2;
      if (n2.maxAge !== void 0 && n2.maxAge !== null) {
        let a = n2.maxAge - 0;
        if (Number.isNaN(a) || !Number.isFinite(a))
          throw new TypeError("option maxAge is invalid");
        s3 += "; Max-Age=" + Math.floor(a);
      }
      if (n2.domain) {
        if (!pn.test(n2.domain))
          throw new TypeError("option domain is invalid");
        s3 += "; Domain=" + n2.domain;
      }
      if (n2.path) {
        if (!pn.test(n2.path))
          throw new TypeError("option path is invalid");
        s3 += "; Path=" + n2.path;
      }
      if (n2.expires) {
        if (!Pm(n2.expires) || Number.isNaN(n2.expires.valueOf()))
          throw new TypeError("option expires is invalid");
        s3 += "; Expires=" + n2.expires.toUTCString();
      }
      if (n2.httpOnly && (s3 += "; HttpOnly"), n2.secure && (s3 += "; Secure"), n2.priority)
        switch (typeof n2.priority == "string" ? n2.priority.toLowerCase() : n2.priority) {
          case "low": {
            s3 += "; Priority=Low";
            break;
          }
          case "medium": {
            s3 += "; Priority=Medium";
            break;
          }
          case "high": {
            s3 += "; Priority=High";
            break;
          }
          default:
            throw new TypeError("option priority is invalid");
        }
      if (n2.sameSite)
        switch (typeof n2.sameSite == "string" ? n2.sameSite.toLowerCase() : n2.sameSite) {
          case true: {
            s3 += "; SameSite=Strict";
            break;
          }
          case "lax": {
            s3 += "; SameSite=Lax";
            break;
          }
          case "strict": {
            s3 += "; SameSite=Strict";
            break;
          }
          case "none": {
            s3 += "; SameSite=None";
            break;
          }
          default:
            throw new TypeError("option sameSite is invalid");
        }
      return n2.partitioned && (s3 += "; Partitioned"), s3;
    }
    function Pm(e3) {
      return Object.prototype.toString.call(e3) === "[object Date]" || e3 instanceof Date;
    }
    function ul(e3, t2) {
      let r3 = (e3 || "").split(";").filter((d) => typeof d == "string" && !!d.trim()), n2 = r3.shift() || "", i = Am(n2), o2 = i.name, s3 = i.value;
      try {
        s3 = t2?.decode === false ? s3 : (t2?.decode || decodeURIComponent)(s3);
      } catch {
      }
      let a = { name: o2, value: s3 };
      for (let d of r3) {
        let f = d.split("="), P = (f.shift() || "").trimStart().toLowerCase(), A = f.join("=");
        switch (P) {
          case "expires": {
            a.expires = new Date(A);
            break;
          }
          case "max-age": {
            a.maxAge = Number.parseInt(A, 10);
            break;
          }
          case "secure": {
            a.secure = true;
            break;
          }
          case "httponly": {
            a.httpOnly = true;
            break;
          }
          case "samesite": {
            a.sameSite = A;
            break;
          }
          default:
            a[P] = A;
        }
      }
      return a;
    }
    function Am(e3) {
      let t2 = "", r3 = "", n2 = e3.split("=");
      return n2.length > 1 ? (t2 = n2.shift(), r3 = n2.join("=")) : r3 = e3, { name: t2, value: r3 };
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var mn = class extends Error {
      clientVersion;
      cause;
      constructor(t2, r3) {
        super(t2), this.clientVersion = r3.clientVersion, this.cause = r3.cause;
      }
      get [Symbol.toStringTag]() {
        return this.name;
      }
    };
    var dn = class extends mn {
      isRetryable;
      constructor(t2, r3) {
        super(t2, r3), this.isRetryable = r3.isRetryable ?? true;
      }
    };
    l();
    u();
    c2();
    p();
    m();
    function cl(e3, t2) {
      return { ...e3, isRetryable: t2 };
    }
    var ze = class extends dn {
      name = "InvalidDatasourceError";
      code = "P6001";
      constructor(t2, r3) {
        super(t2, cl(r3, false));
      }
    };
    Nt(ze, "InvalidDatasourceError");
    function pl(e3) {
      let t2 = { clientVersion: e3.clientVersion }, r3;
      try {
        r3 = new URL(e3.accelerateUrl);
      } catch (d) {
        let f = d.message;
        throw new ze(`Error validating \`accelerateUrl\`, the URL cannot be parsed, reason: ${f}`, t2);
      }
      let { protocol: n2, searchParams: i } = r3;
      if (n2 !== "prisma:" && n2 !== xr)
        throw new ze("Error validating `accelerateUrl`: the URL must start with the protocol `prisma://` or `prisma+postgres://`", t2);
      let o2 = i.get("api_key");
      if (o2 === null || o2.length < 1)
        throw new ze("Error validating `accelerateUrl`: the URL must contain a valid API key", t2);
      let s3 = On(r3) ? "http:" : "https:";
      g.env.TEST_CLIENT_ENGINE_REMOTE_EXECUTOR && r3.searchParams.has("use_http") && (s3 = "http:");
      let a = new URL(r3.href.replace(n2, s3));
      return { apiKey: o2, url: a };
    }
    l();
    u();
    c2();
    p();
    m();
    var ml = Ue(bo());
    var fn = class {
      apiKey;
      tracingHelper;
      logLevel;
      logQueries;
      engineHash;
      constructor({ apiKey: t2, tracingHelper: r3, logLevel: n2, logQueries: i, engineHash: o2 }) {
        this.apiKey = t2, this.tracingHelper = r3, this.logLevel = n2, this.logQueries = i, this.engineHash = o2;
      }
      build({ traceparent: t2, transactionId: r3 } = {}) {
        let n2 = { Accept: "application/json", Authorization: `Bearer ${this.apiKey}`, "Content-Type": "application/json", "Prisma-Engine-Hash": this.engineHash, "Prisma-Engine-Version": ml.enginesVersion };
        this.tracingHelper.isEnabled() && (n2.traceparent = t2 ?? this.tracingHelper.getTraceParent()), r3 && (n2["X-Transaction-Id"] = r3);
        let i = this.#t();
        return i.length > 0 && (n2["X-Capture-Telemetry"] = i.join(", ")), n2;
      }
      #t() {
        let t2 = [];
        return this.tracingHelper.isEnabled() && t2.push("tracing"), this.logLevel && t2.push(this.logLevel), this.logQueries && t2.push("query"), t2;
      }
    };
    l();
    u();
    c2();
    p();
    m();
    function vm(e3) {
      return e3[0] * 1e3 + e3[1] / 1e6;
    }
    function Si(e3) {
      return new Date(vm(e3));
    }
    var fl = Y("prisma:client:clientEngine:remoteExecutor");
    var gn = class {
      #t;
      #e;
      #r;
      #n;
      #l;
      #i;
      constructor(t2) {
        this.#t = t2.clientVersion, this.#n = t2.logEmitter, this.#l = t2.tracingHelper, this.#i = t2.sqlCommenters;
        let { url: r3, apiKey: n2 } = pl({ clientVersion: t2.clientVersion, accelerateUrl: t2.accelerateUrl });
        this.#r = new Ri(r3), this.#e = new fn({ apiKey: n2, engineHash: t2.clientVersion, logLevel: t2.logLevel, logQueries: t2.logQueries, tracingHelper: t2.tracingHelper });
      }
      async getConnectionInfo() {
        return await this.#s({ path: "/connection-info", method: "GET" });
      }
      async execute({ plan: t2, placeholderValues: r3, batchIndex: n2, model: i, operation: o2, transaction: s3, customFetch: a, queryInfo: d }) {
        let f = d && this.#i?.length ? Hr(this.#i, { query: d }) : void 0;
        return (await this.#s({ path: s3 ? `/transaction/${s3.id}/query` : "/query", method: "POST", body: { model: i, operation: o2, plan: t2, params: r3, comments: f && Object.keys(f).length > 0 ? f : void 0 }, batchRequestIdx: n2, fetch: a })).data;
      }
      async startTransaction(t2) {
        return { ...await this.#s({ path: "/transaction/start", method: "POST", body: t2 }), payload: void 0 };
      }
      async commitTransaction(t2) {
        await this.#s({ path: `/transaction/${t2.id}/commit`, method: "POST" });
      }
      async rollbackTransaction(t2) {
        await this.#s({ path: `/transaction/${t2.id}/rollback`, method: "POST" });
      }
      disconnect() {
        return Promise.resolve();
      }
      apiKey() {
        return this.#e.apiKey;
      }
      async #s({ path: t2, method: r3, body: n2, fetch: i = globalThis.fetch, batchRequestIdx: o2 }) {
        let s3 = await this.#r.request({ method: r3, path: t2, headers: this.#e.build(), body: n2, fetch: i });
        s3.ok || await this.#o(s3, o2);
        let a = await s3.json();
        return typeof a.extensions == "object" && a.extensions !== null && this.#u(a.extensions), a;
      }
      async #o(t2, r3) {
        let n2 = t2.headers.get("Prisma-Error-Code"), i = await t2.text(), o2, s3 = i;
        try {
          o2 = JSON.parse(i);
        } catch {
          o2 = {};
        }
        typeof o2.code == "string" && (n2 = o2.code), typeof o2.error == "string" ? s3 = o2.error : typeof o2.message == "string" ? s3 = o2.message : typeof o2.InvalidRequestError == "object" && o2.InvalidRequestError !== null && typeof o2.InvalidRequestError.reason == "string" && (s3 = o2.InvalidRequestError.reason), s3 = s3 || `HTTP ${t2.status}: ${t2.statusText}`;
        let a = typeof o2.meta == "object" && o2.meta !== null ? o2.meta : o2;
        throw new dl.PrismaClientKnownRequestError(s3, { clientVersion: this.#t, code: n2 ?? "P6000", batchRequestIdx: r3, meta: a });
      }
      #u(t2) {
        if (t2.logs)
          for (let r3 of t2.logs)
            this.#a(r3);
        t2.traces && this.#l.dispatchEngineSpans(t2.traces);
      }
      #a(t2) {
        switch (t2.level) {
          case "debug":
          case "trace":
            fl(t2);
            break;
          case "error":
          case "warn":
          case "info": {
            this.#n.emit(t2.level, { timestamp: Si(t2.timestamp), message: t2.attributes.message ?? "", target: t2.target ?? "RemoteExecutor" });
            break;
          }
          case "query": {
            this.#n.emit("query", { query: t2.attributes.query ?? "", timestamp: Si(t2.timestamp), duration: t2.attributes.duration_ms ?? 0, params: t2.attributes.params ?? "", target: t2.target ?? "RemoteExecutor" });
            break;
          }
          default:
            throw new Error(`Unexpected log level: ${t2.level}`);
        }
      }
    };
    var Ri = class {
      #t;
      #e;
      #r;
      constructor(t2) {
        this.#t = t2, this.#e = /* @__PURE__ */ new Map();
      }
      async request({ method: t2, path: r3, headers: n2, body: i, fetch: o2 }) {
        let s3 = new URL(r3, this.#t), a = this.#n(s3);
        a && (n2.Cookie = a), this.#r && (n2["Accelerate-Query-Engine-Jwt"] = this.#r);
        let d = await o2(s3.href, { method: t2, body: i !== void 0 ? JSON.stringify(i) : void 0, headers: n2 });
        return fl(t2, s3, d.status, d.statusText), this.#r = d.headers.get("Accelerate-Query-Engine-Jwt") ?? void 0, this.#l(s3, d), d;
      }
      #n(t2) {
        let r3 = [], n2 = /* @__PURE__ */ new Date();
        for (let [i, o2] of this.#e) {
          if (o2.expires && o2.expires < n2) {
            this.#e.delete(i);
            continue;
          }
          let s3 = o2.domain ?? t2.hostname, a = o2.path ?? "/";
          t2.hostname.endsWith(s3) && t2.pathname.startsWith(a) && r3.push(ll(o2.name, o2.value));
        }
        return r3.length > 0 ? r3.join("; ") : void 0;
      }
      #l(t2, r3) {
        let n2 = r3.headers.getSetCookie?.() || [];
        if (n2.length === 0) {
          let i = r3.headers.get("Set-Cookie");
          i && n2.push(i);
        }
        for (let i of n2) {
          let o2 = ul(i), s3 = o2.domain ?? t2.hostname, a = o2.path ?? "/", d = `${s3}:${a}:${o2.name}`;
          this.#e.set(d, { name: o2.name, value: o2.value, domain: s3, path: a, expires: o2.expires });
        }
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var Oi = require_dist();
    var Ii = {};
    var gl = { async loadQueryCompiler(e3) {
      let { clientVersion: t2, compilerWasm: r3 } = e3;
      if (r3 === void 0)
        throw new Oi.PrismaClientInitializationError("WASM query compiler was unexpectedly `undefined`", t2);
      let n2;
      return e3.activeProvider === void 0 || Ii[e3.activeProvider] === void 0 ? (n2 = (async () => {
        let i = await r3.getRuntime(), o2 = await r3.getQueryCompilerWasmModule();
        if (o2 == null)
          throw new Oi.PrismaClientInitializationError("The loaded wasm module was unexpectedly `undefined` or `null` once loaded", t2);
        let s3 = { "./query_compiler_bg.js": i }, a = new WebAssembly.Instance(o2, s3), d = a.exports.__wbindgen_start;
        return i.__wbg_set_wasm(a.exports), d(), i.QueryCompiler;
      })(), e3.activeProvider !== void 0 && (Ii[e3.activeProvider] = n2)) : n2 = Ii[e3.activeProvider], await n2;
    } };
    var Cm = "P2038";
    var or = Y("prisma:client:clientEngine");
    var hl = globalThis;
    hl.PRISMA_WASM_PANIC_REGISTRY = { set_message(e3) {
      throw new Z.PrismaClientRustPanicError(e3, un);
    } };
    var sr = class {
      name = "ClientEngine";
      #t;
      #e = { type: "disconnected" };
      #r;
      #n;
      config;
      datamodel;
      logEmitter;
      logQueries;
      logLevel;
      tracingHelper;
      #l;
      constructor(t2, r3) {
        if (t2.accelerateUrl !== void 0)
          this.#n = { remote: true, accelerateUrl: t2.accelerateUrl };
        else if (t2.adapter)
          this.#n = { remote: false, driverAdapterFactory: t2.adapter }, or("Using driver adapter: %O", t2.adapter);
        else
          throw new Z.PrismaClientInitializationError("Missing configured driver adapter. Engine type `client` requires an active driver adapter. Please check your PrismaClient initialization code.", t2.clientVersion, Cm);
        this.#r = r3 ?? gl, this.config = t2, this.logQueries = t2.logQueries ?? false, this.logLevel = t2.logLevel ?? "error", this.logEmitter = t2.logEmitter, this.datamodel = t2.inlineSchema, this.tracingHelper = t2.tracingHelper, t2.enableDebugLogs && (this.logLevel = "debug"), this.logQueries && (this.#l = (n2) => {
          this.logEmitter.emit("query", { ...n2, params: Wt(n2.params), target: "ClientEngine" });
        });
      }
      async #i() {
        switch (this.#e.type) {
          case "disconnected": {
            let t2 = this.tracingHelper.runInChildSpan("connect", async () => {
              let r3, n2;
              try {
                r3 = await this.#s(), n2 = await this.#o(r3);
              } catch (o2) {
                throw this.#e = { type: "disconnected" }, n2?.free(), await r3?.disconnect(), o2;
              }
              let i = { executor: r3, queryCompiler: n2 };
              return this.#e = { type: "connected", engine: i }, i;
            });
            return this.#e = { type: "connecting", promise: t2 }, await t2;
          }
          case "connecting":
            return await this.#e.promise;
          case "connected":
            return this.#e.engine;
          case "disconnecting":
            return await this.#e.promise, await this.#i();
        }
      }
      async #s() {
        return this.#n.remote ? new gn({ clientVersion: this.config.clientVersion, accelerateUrl: this.#n.accelerateUrl, logEmitter: this.logEmitter, logLevel: this.logLevel, logQueries: this.logQueries, tracingHelper: this.tracingHelper, sqlCommenters: this.config.sqlCommenters }) : await cn.connect({ driverAdapterFactory: this.#n.driverAdapterFactory, tracingHelper: this.tracingHelper, transactionOptions: { ...this.config.transactionOptions, isolationLevel: this.#m(this.config.transactionOptions.isolationLevel) }, onQuery: this.#l, provider: this.config.activeProvider, sqlCommenters: this.config.sqlCommenters });
      }
      async #o(t2) {
        let r3 = this.#t;
        r3 === void 0 && (r3 = await this.#r.loadQueryCompiler(this.config), this.#t = r3);
        let { provider: n2, connectionInfo: i } = await t2.getConnectionInfo();
        try {
          return this.#p(() => new r3({ datamodel: this.datamodel, provider: n2, connectionInfo: i }), void 0, false);
        } catch (o2) {
          throw this.#u(o2);
        }
      }
      #u(t2) {
        if (t2 instanceof Z.PrismaClientRustPanicError)
          return t2;
        try {
          let r3 = JSON.parse(t2.message);
          return new Z.PrismaClientInitializationError(r3.message, this.config.clientVersion, r3.error_code);
        } catch {
          return t2;
        }
      }
      #a(t2, r3) {
        if (t2 instanceof Z.PrismaClientInitializationError)
          return t2;
        if (t2.code === "GenericFailure" && t2.message?.startsWith("PANIC:"))
          return new Z.PrismaClientRustPanicError(yl(this, t2.message, r3), this.config.clientVersion);
        if (t2 instanceof te)
          return new Z.PrismaClientKnownRequestError(t2.message, { code: t2.code, meta: t2.meta, clientVersion: this.config.clientVersion });
        try {
          let n2 = JSON.parse(t2);
          return new Z.PrismaClientUnknownRequestError(`${n2.message}
${n2.backtrace}`, { clientVersion: this.config.clientVersion });
        } catch {
          return t2;
        }
      }
      #c(t2) {
        return t2 instanceof Z.PrismaClientRustPanicError ? t2 : typeof t2.message == "string" && typeof t2.code == "string" ? new Z.PrismaClientKnownRequestError(t2.message, { code: t2.code, meta: t2.meta, clientVersion: this.config.clientVersion }) : typeof t2.message == "string" ? new Z.PrismaClientUnknownRequestError(t2.message, { clientVersion: this.config.clientVersion }) : t2;
      }
      #p(t2, r3, n2 = true) {
        let i = hl.PRISMA_WASM_PANIC_REGISTRY.set_message, o2;
        globalThis.PRISMA_WASM_PANIC_REGISTRY.set_message = (s3) => {
          o2 = s3;
        };
        try {
          return t2();
        } finally {
          if (globalThis.PRISMA_WASM_PANIC_REGISTRY.set_message = i, o2)
            throw this.#t = void 0, n2 && this.stop().catch((s3) => or("failed to disconnect:", s3)), new Z.PrismaClientRustPanicError(yl(this, o2, r3), this.config.clientVersion);
        }
      }
      onBeforeExit() {
        throw new Error('"beforeExit" hook is not applicable to the client engine, it is only relevant and implemented for the binary engine. Please add your event listener to the `process` object directly instead.');
      }
      async start() {
        await this.#i();
      }
      async stop() {
        switch (this.#e.type) {
          case "disconnected":
            return;
          case "connecting":
            return await this.#e.promise, await this.stop();
          case "connected": {
            let t2 = this.#e.engine, r3 = this.tracingHelper.runInChildSpan("disconnect", async () => {
              try {
                await t2.executor.disconnect(), t2.queryCompiler.free();
              } finally {
                this.#e = { type: "disconnected" };
              }
            });
            return this.#e = { type: "disconnecting", promise: r3 }, await r3;
          }
          case "disconnecting":
            return await this.#e.promise;
        }
      }
      version() {
        return "unknown";
      }
      async transaction(t2, r3, n2) {
        let i, { executor: o2 } = await this.#i();
        try {
          if (t2 === "start") {
            let s3 = n2;
            i = await o2.startTransaction({ ...s3, isolationLevel: this.#m(s3.isolationLevel) });
          } else if (t2 === "commit") {
            let s3 = n2;
            await o2.commitTransaction(s3);
          } else if (t2 === "rollback") {
            let s3 = n2;
            await o2.rollbackTransaction(s3);
          } else
            ve(t2, "Invalid transaction action.");
        } catch (s3) {
          throw this.#a(s3);
        }
        return i ? { id: i.id, payload: void 0 } : void 0;
      }
      async request(t2, { interactiveTransaction: r3, customDataProxyFetch: n2 }) {
        or("sending request");
        let i = JSON.stringify(t2), { executor: o2, queryCompiler: s3 } = await this.#i().catch((d) => {
          throw this.#a(d, i);
        }), a;
        try {
          a = this.#p(() => this.#d({ queries: [t2], execute: () => s3.compile(i) }));
        } catch (d) {
          throw this.#c(d);
        }
        try {
          or("query plan created", a);
          let d = {}, f = await o2.execute({ plan: a, model: t2.modelName, operation: t2.action, placeholderValues: d, transaction: r3, batchIndex: void 0, customFetch: n2?.(globalThis.fetch), queryInfo: { type: "single", modelName: t2.modelName, action: t2.action, query: t2.query } });
          return or("query plan executed"), { data: { [t2.action]: f } };
        } catch (d) {
          throw this.#a(d, i);
        }
      }
      async requestBatch(t2, { transaction: r3, customDataProxyFetch: n2 }) {
        if (t2.length === 0)
          return [];
        let i = t2[0].action, o2 = t2[0].modelName, s3 = JSON.stringify(rl(t2, r3)), { executor: a, queryCompiler: d } = await this.#i().catch((P) => {
          throw this.#a(P, s3);
        }), f;
        try {
          f = this.#p(() => this.#d({ queries: t2, execute: () => d.compileBatch(s3) }));
        } catch (P) {
          throw this.#c(P);
        }
        try {
          let P;
          r3?.kind === "itx" && (P = r3.options);
          let A = {};
          switch (f.type) {
            case "multi": {
              if (r3?.kind !== "itx") {
                let M = r3?.options.isolationLevel ? { ...this.config.transactionOptions, isolationLevel: r3.options.isolationLevel } : this.config.transactionOptions;
                P = await this.transaction("start", {}, M);
              }
              let S = [], C = false;
              for (let [M, R] of f.plans.entries())
                try {
                  let k = await a.execute({ plan: R, placeholderValues: A, model: t2[M].modelName, operation: t2[M].action, batchIndex: M, transaction: P, customFetch: n2?.(globalThis.fetch), queryInfo: { type: "single", ...t2[M] } });
                  S.push({ data: { [t2[M].action]: k } });
                } catch (k) {
                  S.push(k), C = true;
                  break;
                }
              return P !== void 0 && r3?.kind !== "itx" && (C ? await this.transaction("rollback", {}, P) : await this.transaction("commit", {}, P)), S;
            }
            case "compacted": {
              if (!t2.every((M) => M.action === i && M.modelName === o2)) {
                let M = t2.map((k) => k.action).join(", "), R = t2.map((k) => k.modelName).join(", ");
                throw new Error(`Internal error: All queries in a compacted batch must have the same action and model name, but received actions: [${M}] and model names: [${R}]. This indicates a bug in the client. Please report this issue to the Prisma team with your query details.`);
              }
              if (o2 === void 0)
                throw new Error("Internal error: A compacted batch cannot contain raw queries. This indicates a bug in the client. Please report this issue to the Prisma team with your query details.");
              let S = await a.execute({ plan: f.plan, placeholderValues: A, model: o2, operation: i, batchIndex: void 0, transaction: P, customFetch: n2?.(globalThis.fetch), queryInfo: { type: "compacted", action: i, modelName: o2, queries: t2 } });
              return Us(S, f).map((M) => ({ data: { [i]: M } }));
            }
          }
        } catch (P) {
          throw this.#a(P, s3);
        }
      }
      async apiKey() {
        let { executor: t2 } = await this.#i();
        return t2.apiKey();
      }
      #m(t2) {
        switch (t2) {
          case void 0:
            return;
          case "ReadUncommitted":
            return "READ UNCOMMITTED";
          case "ReadCommitted":
            return "READ COMMITTED";
          case "RepeatableRead":
            return "REPEATABLE READ";
          case "Serializable":
            return "SERIALIZABLE";
          case "Snapshot":
            return "SNAPSHOT";
          default:
            throw new Z.PrismaClientKnownRequestError(`Inconsistent column data: Conversion failed: Invalid isolation level \`${t2}\``, { code: "P2023", clientVersion: this.config.clientVersion, meta: { providedIsolationLevel: t2 } });
        }
      }
      #d({ queries: t2, execute: r3 }) {
        return this.tracingHelper.runInChildSpan({ name: "compile", attributes: { models: t2.map((n2) => n2.modelName).filter((n2) => n2 !== void 0), actions: t2.map((n2) => n2.action) } }, r3);
      }
    };
    function yl(e3, t2, r3) {
      return al({ binaryTarget: void 0, title: t2, version: e3.config.clientVersion, engineVersion: "unknown", database: e3.config.activeProvider, query: r3 });
    }
    function wl(e3) {
      return new sr(e3);
    }
    l();
    u();
    c2();
    p();
    m();
    var bl = (e3) => ({ command: e3 });
    l();
    u();
    c2();
    p();
    m();
    var Sl = require_dist();
    l();
    u();
    c2();
    p();
    m();
    var xl = (e3) => e3.strings.reduce((t2, r3, n2) => `${t2}@P${n2}${r3}`);
    l();
    u();
    c2();
    p();
    m();
    var Pl = require_dist();
    function vt(e3) {
      try {
        return El(e3, "fast");
      } catch {
        return El(e3, "slow");
      }
    }
    function El(e3, t2) {
      return JSON.stringify(e3.map((r3) => Al(r3, t2)));
    }
    function Al(e3, t2) {
      if (Array.isArray(e3))
        return e3.map((r3) => Al(r3, t2));
      if (typeof e3 == "bigint")
        return { prisma__type: "bigint", prisma__value: e3.toString() };
      if (it(e3))
        return { prisma__type: "date", prisma__value: e3.toJSON() };
      if (Pl.Decimal.isDecimal(e3))
        return { prisma__type: "decimal", prisma__value: e3.toJSON() };
      if (y.isBuffer(e3))
        return { prisma__type: "bytes", prisma__value: e3.toString("base64") };
      if (Sm(e3))
        return { prisma__type: "bytes", prisma__value: y.from(e3).toString("base64") };
      if (ArrayBuffer.isView(e3)) {
        let { buffer: r3, byteOffset: n2, byteLength: i } = e3;
        return { prisma__type: "bytes", prisma__value: y.from(r3, n2, i).toString("base64") };
      }
      return typeof e3 == "object" && t2 === "slow" ? vl(e3) : e3;
    }
    function Sm(e3) {
      return e3 instanceof ArrayBuffer || e3 instanceof SharedArrayBuffer ? true : typeof e3 == "object" && e3 !== null ? e3[Symbol.toStringTag] === "ArrayBuffer" || e3[Symbol.toStringTag] === "SharedArrayBuffer" : false;
    }
    function vl(e3) {
      if (typeof e3 != "object" || e3 === null)
        return e3;
      if (typeof e3.toJSON == "function")
        return e3.toJSON();
      if (Array.isArray(e3))
        return e3.map(Tl);
      let t2 = {};
      for (let r3 of Object.keys(e3))
        t2[r3] = Tl(e3[r3]);
      return t2;
    }
    function Tl(e3) {
      return typeof e3 == "bigint" ? e3.toString() : vl(e3);
    }
    var Rm = /^(\s*alter\s)/i;
    var Cl = Y("prisma:client");
    function ki(e3, t2, r3, n2) {
      if (!(e3 !== "postgresql" && e3 !== "cockroachdb") && r3.length > 0 && Rm.exec(t2))
        throw new Error(`Running ALTER using ${n2} is not supported
Using the example below you can still execute your query with Prisma, but please note that it is vulnerable to SQL injection attacks and requires you to take care of input sanitization.

Example:
  await prisma.$executeRawUnsafe(\`ALTER USER prisma WITH PASSWORD '\${password}'\`)

More Information: https://pris.ly/d/execute-raw
`);
    }
    var Mi = ({ clientMethod: e3, activeProvider: t2 }) => (r3) => {
      let n2 = "", i;
      if (Ur(r3))
        n2 = r3.sql, i = { values: vt(r3.values), __prismaRawParameters__: true };
      else if (Array.isArray(r3)) {
        let [o2, ...s3] = r3;
        n2 = o2, i = { values: vt(s3 || []), __prismaRawParameters__: true };
      } else
        switch (t2) {
          case "sqlite":
          case "mysql": {
            n2 = r3.sql, i = { values: vt(r3.values), __prismaRawParameters__: true };
            break;
          }
          case "cockroachdb":
          case "postgresql":
          case "postgres": {
            n2 = r3.text, i = { values: vt(r3.values), __prismaRawParameters__: true };
            break;
          }
          case "sqlserver": {
            n2 = xl(r3), i = { values: vt(r3.values), __prismaRawParameters__: true };
            break;
          }
          default:
            throw new Error(`The ${t2} provider does not support ${e3}`);
        }
      return i?.values ? Cl(`prisma.${e3}(${n2}, ${i.values})`) : Cl(`prisma.${e3}(${n2})`), { query: n2, parameters: i };
    };
    var Rl = { requestArgsToMiddlewareArgs(e3) {
      return [e3.strings, ...e3.values];
    }, middlewareArgsToRequestArgs(e3) {
      let [t2, ...r3] = e3;
      return new Sl.Sql(t2, r3);
    } };
    var Il = { requestArgsToMiddlewareArgs(e3) {
      return [e3];
    }, middlewareArgsToRequestArgs(e3) {
      return e3[0];
    } };
    l();
    u();
    c2();
    p();
    m();
    function Di(e3) {
      return function(r3, n2) {
        let i, o2 = (s3 = e3) => {
          try {
            return s3 === void 0 || s3?.kind === "itx" ? i ??= Ol(r3(s3)) : Ol(r3(s3));
          } catch (a) {
            return Promise.reject(a);
          }
        };
        return { get spec() {
          return n2;
        }, then(s3, a) {
          return o2().then(s3, a);
        }, catch(s3) {
          return o2().catch(s3);
        }, finally(s3) {
          return o2().finally(s3);
        }, requestTransaction(s3) {
          let a = o2(s3);
          return a.requestTransaction ? a.requestTransaction(s3) : a;
        }, [Symbol.toStringTag]: "PrismaPromise" };
      };
    }
    function Ol(e3) {
      return typeof e3.then == "function" ? e3 : Promise.resolve(e3);
    }
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    l();
    u();
    c2();
    p();
    m();
    var kl = { name: "@prisma/instrumentation-contract", version: "7.1.0", description: "Shared types and utilities for Prisma instrumentation", main: "dist/index.js", module: "dist/index.mjs", types: "dist/index.d.ts", exports: { ".": { require: { types: "./dist/index.d.ts", default: "./dist/index.js" }, import: { types: "./dist/index.d.mts", default: "./dist/index.mjs" } } }, license: "Apache-2.0", homepage: "https://www.prisma.io", repository: { type: "git", url: "https://github.com/prisma/prisma.git", directory: "packages/instrumentation-contract" }, bugs: "https://github.com/prisma/prisma/issues", scripts: { dev: "DEV=true tsx helpers/build.ts", build: "tsx helpers/build.ts", prepublishOnly: "pnpm run build", test: "vitest run" }, files: ["dist"], sideEffects: false, devDependencies: { "@opentelemetry/api": "1.9.0" }, peerDependencies: { "@opentelemetry/api": "^1.8" } };
    var Om = kl.version.split(".")[0];
    var km = "PRISMA_INSTRUMENTATION";
    var Mm = `V${Om}_PRISMA_INSTRUMENTATION`;
    var Ml = globalThis;
    function Dl() {
      let e3 = Ml[Mm];
      return e3?.helper ? e3.helper : Ml[km]?.helper;
    }
    var Dm = { isEnabled() {
      return false;
    }, getTraceParent() {
      return "00-10-10-00";
    }, dispatchEngineSpans() {
    }, getActiveContext() {
    }, runInChildSpan(e3, t2) {
      return t2();
    } };
    var Ni = class {
      isEnabled() {
        return this.getTracingHelper().isEnabled();
      }
      getTraceParent(t2) {
        return this.getTracingHelper().getTraceParent(t2);
      }
      dispatchEngineSpans(t2) {
        return this.getTracingHelper().dispatchEngineSpans(t2);
      }
      getActiveContext() {
        return this.getTracingHelper().getActiveContext();
      }
      runInChildSpan(t2, r3) {
        return this.getTracingHelper().runInChildSpan(t2, r3);
      }
      getTracingHelper() {
        return Dl() ?? Dm;
      }
    };
    function Nl() {
      return new Ni();
    }
    l();
    u();
    c2();
    p();
    m();
    function Ll(e3, t2 = () => {
    }) {
      let r3, n2 = new Promise((i) => r3 = i);
      return { then(i) {
        return --e3 === 0 && r3(t2()), i?.(n2);
      } };
    }
    l();
    u();
    c2();
    p();
    m();
    function _l(e3) {
      return typeof e3 == "string" ? e3 : e3.reduce((t2, r3) => {
        let n2 = typeof r3 == "string" ? r3 : r3.level;
        return n2 === "query" ? t2 : t2 && (r3 === "info" || t2 === "info") ? "info" : n2;
      }, void 0);
    }
    l();
    u();
    c2();
    p();
    m();
    var $l = require_dist();
    l();
    u();
    c2();
    p();
    m();
    function Fl(e3) {
      if (e3.action !== "findUnique" && e3.action !== "findUniqueOrThrow")
        return;
      let t2 = [];
      return e3.modelName && t2.push(e3.modelName), e3.query.arguments && t2.push(Li(e3.query.arguments)), t2.push(Li(e3.query.selection)), t2.join("");
    }
    function Li(e3) {
      return `(${Object.keys(e3).sort().map((r3) => {
        let n2 = e3[r3];
        return typeof n2 == "object" && n2 !== null ? `(${r3} ${Li(n2)})` : r3;
      }).join(" ")})`;
    }
    l();
    u();
    c2();
    p();
    m();
    var Nm = { aggregate: false, aggregateRaw: false, createMany: true, createManyAndReturn: true, createOne: true, deleteMany: true, deleteOne: true, executeRaw: true, findFirst: false, findFirstOrThrow: false, findMany: false, findRaw: false, findUnique: false, findUniqueOrThrow: false, groupBy: false, queryRaw: false, runCommandRaw: true, updateMany: true, updateManyAndReturn: true, updateOne: true, upsertOne: true };
    function _i(e3) {
      return Nm[e3];
    }
    l();
    u();
    c2();
    p();
    m();
    var yn = class {
      constructor(t2) {
        this.options = t2;
        this.batches = {};
      }
      batches;
      tickActive = false;
      request(t2) {
        let r3 = this.options.batchBy(t2);
        return r3 ? (this.batches[r3] || (this.batches[r3] = [], this.tickActive || (this.tickActive = true, g.nextTick(() => {
          this.dispatchBatches(), this.tickActive = false;
        }))), new Promise((n2, i) => {
          this.batches[r3].push({ request: t2, resolve: n2, reject: i });
        })) : this.options.singleLoader(t2);
      }
      dispatchBatches() {
        for (let t2 in this.batches) {
          let r3 = this.batches[t2];
          delete this.batches[t2], r3.length === 1 ? this.options.singleLoader(r3[0].request).then((n2) => {
            n2 instanceof Error ? r3[0].reject(n2) : r3[0].resolve(n2);
          }).catch((n2) => {
            r3[0].reject(n2);
          }) : (r3.sort((n2, i) => this.options.batchOrder(n2.request, i.request)), this.options.batchLoader(r3.map((n2) => n2.request)).then((n2) => {
            if (n2 instanceof Error)
              for (let i = 0; i < r3.length; i++)
                r3[i].reject(n2);
            else
              for (let i = 0; i < r3.length; i++) {
                let o2 = n2[i];
                o2 instanceof Error ? r3[i].reject(o2) : r3[i].resolve(o2);
              }
          }).catch((n2) => {
            for (let i = 0; i < r3.length; i++)
              r3[i].reject(n2);
          }));
        }
      }
      get [Symbol.toStringTag]() {
        return "DataLoader";
      }
    };
    l();
    u();
    c2();
    p();
    m();
    var Ul = require_dist();
    function Ze(e3, t2) {
      if (t2 === null)
        return t2;
      switch (e3) {
        case "bigint":
          return BigInt(t2);
        case "bytes": {
          let { buffer: r3, byteOffset: n2, byteLength: i } = y.from(t2, "base64");
          return new Uint8Array(r3, n2, i);
        }
        case "decimal":
          return new Ul.Decimal(t2);
        case "datetime":
        case "date":
          return new Date(t2);
        case "time":
          return /* @__PURE__ */ new Date(`1970-01-01T${t2}Z`);
        case "bigint-array":
          return t2.map((r3) => Ze("bigint", r3));
        case "bytes-array":
          return t2.map((r3) => Ze("bytes", r3));
        case "decimal-array":
          return t2.map((r3) => Ze("decimal", r3));
        case "datetime-array":
          return t2.map((r3) => Ze("datetime", r3));
        case "date-array":
          return t2.map((r3) => Ze("date", r3));
        case "time-array":
          return t2.map((r3) => Ze("time", r3));
        default:
          return t2;
      }
    }
    function hn(e3) {
      let t2 = [], r3 = Lm(e3);
      for (let n2 = 0; n2 < e3.rows.length; n2++) {
        let i = e3.rows[n2], o2 = { ...r3 };
        for (let s3 = 0; s3 < i.length; s3++)
          o2[e3.columns[s3]] = Ze(e3.types[s3], i[s3]);
        t2.push(o2);
      }
      return t2;
    }
    function Lm(e3) {
      let t2 = {};
      for (let r3 = 0; r3 < e3.columns.length; r3++)
        t2[e3.columns[r3]] = null;
      return t2;
    }
    var _m = Y("prisma:client:request_handler");
    var wn = class {
      client;
      dataloader;
      logEmitter;
      constructor(t2, r3) {
        this.logEmitter = r3, this.client = t2, this.dataloader = new yn({ batchLoader: Rs(async ({ requests: n2, customDataProxyFetch: i }) => {
          let { transaction: o2, otelParentCtx: s3 } = n2[0], a = n2.map((A) => A.protocolQuery), d = this.client._tracingHelper.getTraceParent(s3), f = n2.some((A) => _i(A.protocolQuery.action));
          return (await this.client._engine.requestBatch(a, { traceparent: d, transaction: Fm(o2), containsWrite: f, customDataProxyFetch: i })).map((A, S) => {
            if (A instanceof Error)
              return A;
            try {
              return this.mapQueryEngineResult(n2[S], A);
            } catch (C) {
              return C;
            }
          });
        }), singleLoader: async (n2) => {
          let i = n2.transaction?.kind === "itx" ? ql(n2.transaction) : void 0, o2 = await this.client._engine.request(n2.protocolQuery, { traceparent: this.client._tracingHelper.getTraceParent(), interactiveTransaction: i, isWrite: _i(n2.protocolQuery.action), customDataProxyFetch: n2.customDataProxyFetch });
          return this.mapQueryEngineResult(n2, o2);
        }, batchBy: (n2) => n2.transaction?.id ? `transaction-${n2.transaction.id}` : Fl(n2.protocolQuery), batchOrder(n2, i) {
          return n2.transaction?.kind === "batch" && i.transaction?.kind === "batch" ? n2.transaction.index - i.transaction.index : 0;
        } });
      }
      async request(t2) {
        try {
          return await this.dataloader.request(t2);
        } catch (r3) {
          let { clientMethod: n2, callsite: i, transaction: o2, args: s3, modelName: a } = t2;
          this.handleAndLogRequestError({ error: r3, clientMethod: n2, callsite: i, transaction: o2, args: s3, modelName: a, globalOmit: t2.globalOmit });
        }
      }
      mapQueryEngineResult({ dataPath: t2, unpacker: r3 }, n2) {
        let i = n2?.data, o2 = this.unpack(i, t2, r3);
        return g.env.PRISMA_CLIENT_GET_TIME ? { data: o2 } : o2;
      }
      handleAndLogRequestError(t2) {
        try {
          this.handleRequestError(t2);
        } catch (r3) {
          throw this.logEmitter && this.logEmitter.emit("error", { message: r3.message, target: t2.clientMethod, timestamp: /* @__PURE__ */ new Date() }), r3;
        }
      }
      handleRequestError({ error: t2, clientMethod: r3, callsite: n2, transaction: i, args: o2, modelName: s3, globalOmit: a }) {
        if (_m(t2), Um(t2, i))
          throw t2;
        if (t2 instanceof D.PrismaClientKnownRequestError && $m(t2)) {
          let f = Vl(t2.meta);
          Mr({ args: o2, errors: [f], callsite: n2, errorFormat: this.client._errorFormat, originalMethod: r3, clientVersion: this.client._clientVersion, globalOmit: a });
        }
        let d = t2.message;
        if (n2 && (d = Ar({ callsite: n2, originalMethod: r3, isPanic: t2.isPanic, showColors: this.client._errorFormat === "pretty", message: d })), d = this.sanitizeMessage(d), t2.code) {
          let f = s3 ? { modelName: s3, ...t2.meta } : t2.meta;
          throw new D.PrismaClientKnownRequestError(d, { code: t2.code, clientVersion: this.client._clientVersion, meta: f, batchRequestIdx: t2.batchRequestIdx });
        } else {
          if (t2.isPanic)
            throw new D.PrismaClientRustPanicError(d, this.client._clientVersion);
          if (t2 instanceof D.PrismaClientUnknownRequestError)
            throw new D.PrismaClientUnknownRequestError(d, { clientVersion: this.client._clientVersion, batchRequestIdx: t2.batchRequestIdx });
          if (t2 instanceof D.PrismaClientInitializationError)
            throw new D.PrismaClientInitializationError(d, this.client._clientVersion);
          if (t2 instanceof D.PrismaClientRustPanicError)
            throw new D.PrismaClientRustPanicError(d, this.client._clientVersion);
        }
        throw t2.clientVersion = this.client._clientVersion, t2;
      }
      sanitizeMessage(t2) {
        return this.client._errorFormat && this.client._errorFormat !== "pretty" ? nt(t2) : t2;
      }
      unpack(t2, r3, n2) {
        if (!t2 || (t2.data && (t2 = t2.data), !t2))
          return t2;
        let i = Object.keys(t2)[0], o2 = Object.values(t2)[0], s3 = r3.filter((f) => f !== "select" && f !== "include"), a = Qn(o2, s3), d = i === "queryRaw" ? hn(a) : De(a);
        return n2 ? n2(d) : d;
      }
      get [Symbol.toStringTag]() {
        return "RequestHandler";
      }
    };
    function Fm(e3) {
      if (e3) {
        if (e3.kind === "batch")
          return { kind: "batch", options: { isolationLevel: e3.isolationLevel } };
        if (e3.kind === "itx")
          return { kind: "itx", options: ql(e3) };
        ve(e3, "Unknown transaction kind");
      }
    }
    function ql(e3) {
      return { id: e3.id, payload: e3.payload };
    }
    function Um(e3, t2) {
      return (0, $l.hasBatchIndex)(e3) && t2?.kind === "batch" && e3.batchRequestIdx !== t2.index;
    }
    function $m(e3) {
      return e3.code === "P2009" || e3.code === "P2012";
    }
    function Vl(e3) {
      if (e3.kind === "Union")
        return { kind: "Union", errors: e3.errors.map(Vl) };
      if (Array.isArray(e3.selectionPath)) {
        let [, ...t2] = e3.selectionPath;
        return { ...e3, selectionPath: t2 };
      }
      return e3;
    }
    l();
    u();
    c2();
    p();
    m();
    var Fi = un;
    l();
    u();
    c2();
    p();
    m();
    var Jl = Ue(_n());
    l();
    u();
    c2();
    p();
    m();
    var j = class extends Error {
      constructor(t2) {
        super(t2 + `
Read more at https://pris.ly/d/client-constructor`), this.name = "PrismaClientConstructorValidationError";
      }
      get [Symbol.toStringTag]() {
        return "PrismaClientConstructorValidationError";
      }
    };
    Nt(j, "PrismaClientConstructorValidationError");
    var Bl = ["errorFormat", "adapter", "accelerateUrl", "log", "transactionOptions", "omit", "comments", "__internal"];
    var jl = ["pretty", "colorless", "minimal"];
    var Ql = ["info", "query", "warn", "error"];
    var qm = { adapter: () => {
    }, accelerateUrl: (e3) => {
      if (e3 !== void 0) {
        if (typeof e3 != "string")
          throw new j(`Invalid value ${JSON.stringify(e3)} for "accelerateUrl" provided to PrismaClient constructor.`);
        if (e3.trim().length === 0)
          throw new j('"accelerateUrl" provided to PrismaClient constructor must be a non-empty string.');
      }
    }, errorFormat: (e3) => {
      if (e3) {
        if (typeof e3 != "string")
          throw new j(`Invalid value ${JSON.stringify(e3)} for "errorFormat" provided to PrismaClient constructor.`);
        if (!jl.includes(e3)) {
          let t2 = ar(e3, jl);
          throw new j(`Invalid errorFormat ${e3} provided to PrismaClient constructor.${t2}`);
        }
      }
    }, log: (e3) => {
      if (!e3)
        return;
      if (!Array.isArray(e3))
        throw new j(`Invalid value ${JSON.stringify(e3)} for "log" provided to PrismaClient constructor.`);
      function t2(r3) {
        if (typeof r3 == "string" && !Ql.includes(r3)) {
          let n2 = ar(r3, Ql);
          throw new j(`Invalid log level "${r3}" provided to PrismaClient constructor.${n2}`);
        }
      }
      for (let r3 of e3) {
        t2(r3);
        let n2 = { level: t2, emit: (i) => {
          let o2 = ["stdout", "event"];
          if (!o2.includes(i)) {
            let s3 = ar(i, o2);
            throw new j(`Invalid value ${JSON.stringify(i)} for "emit" in logLevel provided to PrismaClient constructor.${s3}`);
          }
        } };
        if (r3 && typeof r3 == "object")
          for (let [i, o2] of Object.entries(r3))
            if (n2[i])
              n2[i](o2);
            else
              throw new j(`Invalid property ${i} for "log" provided to PrismaClient constructor`);
      }
    }, transactionOptions: (e3) => {
      if (!e3)
        return;
      let t2 = e3.maxWait;
      if (t2 != null && t2 <= 0)
        throw new j(`Invalid value ${t2} for maxWait in "transactionOptions" provided to PrismaClient constructor. maxWait needs to be greater than 0`);
      let r3 = e3.timeout;
      if (r3 != null && r3 <= 0)
        throw new j(`Invalid value ${r3} for timeout in "transactionOptions" provided to PrismaClient constructor. timeout needs to be greater than 0`);
    }, omit: (e3, t2) => {
      if (typeof e3 != "object")
        throw new j('"omit" option is expected to be an object.');
      if (e3 === null)
        throw new j('"omit" option can not be `null`');
      let r3 = [];
      for (let [n2, i] of Object.entries(e3)) {
        let o2 = jm(n2, t2.runtimeDataModel);
        if (!o2) {
          r3.push({ kind: "UnknownModel", modelKey: n2 });
          continue;
        }
        for (let [s3, a] of Object.entries(i)) {
          let d = o2.fields.find((f) => f.name === s3);
          if (!d) {
            r3.push({ kind: "UnknownField", modelKey: n2, fieldName: s3 });
            continue;
          }
          if (d.relationName) {
            r3.push({ kind: "RelationInOmit", modelKey: n2, fieldName: s3 });
            continue;
          }
          typeof a != "boolean" && r3.push({ kind: "InvalidFieldValue", modelKey: n2, fieldName: s3 });
        }
      }
      if (r3.length > 0)
        throw new j(Qm(e3, r3));
    }, comments: (e3) => {
      if (e3 !== void 0) {
        if (!Array.isArray(e3))
          throw new j(`Invalid value ${JSON.stringify(e3)} for "comments" provided to PrismaClient constructor. Expected an array of SQL commenter plugins.`);
        for (let t2 = 0; t2 < e3.length; t2++)
          if (typeof e3[t2] != "function")
            throw new j(`Invalid value at index ${t2} for "comments" provided to PrismaClient constructor. Each plugin must be a function.`);
      }
    }, __internal: (e3) => {
      if (!e3)
        return;
      let t2 = ["debug", "engine", "configOverride"];
      if (typeof e3 != "object")
        throw new j(`Invalid value ${JSON.stringify(e3)} for "__internal" to PrismaClient constructor`);
      for (let [r3] of Object.entries(e3))
        if (!t2.includes(r3)) {
          let n2 = ar(r3, t2);
          throw new j(`Invalid property ${JSON.stringify(r3)} for "__internal" provided to PrismaClient constructor.${n2}`);
        }
    } };
    function Vm(e3) {
      let t2 = e3.adapter !== void 0, r3 = e3.accelerateUrl !== void 0;
      if (t2 && r3)
        throw new j('The "adapter" and "accelerateUrl" options are mutually exclusive. Please provide only one of them.');
      if (!t2 && !r3)
        throw new j('Using engine type "client" requires either "adapter" or "accelerateUrl" to be provided to PrismaClient constructor.');
    }
    function Wl(e3, t2) {
      for (let [r3, n2] of Object.entries(e3)) {
        if (!Bl.includes(r3)) {
          let i = ar(r3, Bl);
          throw new j(`Unknown property ${r3} provided to PrismaClient constructor.${i}`);
        }
        qm[r3](n2, t2);
      }
      Vm(e3);
    }
    function ar(e3, t2) {
      if (t2.length === 0 || typeof e3 != "string")
        return "";
      let r3 = Bm(e3, t2);
      return r3 ? ` Did you mean "${r3}"?` : "";
    }
    function Bm(e3, t2) {
      if (t2.length === 0)
        return null;
      let r3 = t2.map((i) => ({ value: i, distance: (0, Jl.default)(e3, i) }));
      r3.sort((i, o2) => i.distance < o2.distance ? -1 : 1);
      let n2 = r3[0];
      return n2.distance < 3 ? n2.value : null;
    }
    function jm(e3, t2) {
      return Hl(t2.models, e3) ?? Hl(t2.types, e3);
    }
    function Hl(e3, t2) {
      let r3 = Object.keys(e3).find((n2) => Ie(n2) === t2);
      if (r3)
        return e3[r3];
    }
    function Qm(e3, t2) {
      let r3 = mt(e3);
      for (let o2 of t2)
        switch (o2.kind) {
          case "UnknownModel":
            r3.arguments.getField(o2.modelKey)?.markAsError(), r3.addErrorMessage(() => `Unknown model name: ${o2.modelKey}.`);
            break;
          case "UnknownField":
            r3.arguments.getDeepField([o2.modelKey, o2.fieldName])?.markAsError(), r3.addErrorMessage(() => `Model "${o2.modelKey}" does not have a field named "${o2.fieldName}".`);
            break;
          case "RelationInOmit":
            r3.arguments.getDeepField([o2.modelKey, o2.fieldName])?.markAsError(), r3.addErrorMessage(() => 'Relations are already excluded by default and can not be specified in "omit".');
            break;
          case "InvalidFieldValue":
            r3.arguments.getDeepFieldValue([o2.modelKey, o2.fieldName])?.markAsError(), r3.addErrorMessage(() => "Omit field option value must be a boolean.");
            break;
        }
      let { message: n2, args: i } = kr(r3, "colorless");
      return `Error validating "omit" option:

${i}

${n2}`;
    }
    l();
    u();
    c2();
    p();
    m();
    var Gl = require_dist();
    function Kl(e3) {
      return e3.length === 0 ? Promise.resolve([]) : new Promise((t2, r3) => {
        let n2 = new Array(e3.length), i = null, o2 = false, s3 = 0, a = () => {
          o2 || (s3++, s3 === e3.length && (o2 = true, i ? r3(i) : t2(n2)));
        }, d = (f) => {
          o2 || (o2 = true, r3(f));
        };
        for (let f = 0; f < e3.length; f++)
          e3[f].then((P) => {
            n2[f] = P, a();
          }, (P) => {
            if (!(0, Gl.hasBatchIndex)(P)) {
              d(P);
              return;
            }
            P.batchRequestIdx === f ? d(P) : (i || (i = P), a());
          });
      });
    }
    var lr = Y("prisma:client");
    typeof globalThis == "object" && (globalThis.NODE_CLIENT = true);
    var Hm = { requestArgsToMiddlewareArgs: (e3) => e3, middlewareArgsToRequestArgs: (e3) => e3 };
    var Jm = Symbol.for("prisma.client.transaction.id");
    var Wm = { id: 0, nextId() {
      return ++this.id;
    } };
    function Yl(e3) {
      class t2 {
        _originalClient = this;
        _runtimeDataModel;
        _requestHandler;
        _connectionPromise;
        _disconnectionPromise;
        _engineConfig;
        _accelerateEngineConfig;
        _clientVersion;
        _errorFormat;
        _tracingHelper;
        _previewFeatures;
        _activeProvider;
        _globalOmit;
        _extensions;
        _engine;
        _appliedParent;
        _createPrismaPromise = Di();
        constructor(n2) {
          if (!n2)
            throw new D.PrismaClientInitializationError("`PrismaClient` needs to be constructed with a non-empty, valid `PrismaClientOptions`:\n\n```\nnew PrismaClient({\n  ...\n})\n```\n\nor\n\n```\nconstructor() {\n  super({ ... });\n}\n```\n          ", Fi);
          e3 = n2.__internal?.configOverride?.(e3) ?? e3, Wl(n2, e3);
          let i = new $r().on("error", () => {
          });
          this._extensions = dt.empty(), this._previewFeatures = e3.previewFeatures, this._clientVersion = e3.clientVersion ?? Fi, this._activeProvider = e3.activeProvider, this._globalOmit = n2?.omit, this._tracingHelper = Nl();
          let o2;
          if (n2.adapter) {
            o2 = n2.adapter;
            let s3 = e3.activeProvider === "postgresql" || e3.activeProvider === "cockroachdb" ? "postgres" : e3.activeProvider;
            if (o2.provider !== s3)
              throw new D.PrismaClientInitializationError(`The Driver Adapter \`${o2.adapterName}\`, based on \`${o2.provider}\`, is not compatible with the provider \`${s3}\` specified in the Prisma schema.`, this._clientVersion);
          }
          try {
            let s3 = n2 ?? {}, d = (s3.__internal ?? {}).debug === true;
            if (d && Y.enable("prisma:client"), s3.errorFormat ? this._errorFormat = s3.errorFormat : g.env.NODE_ENV === "production" ? this._errorFormat = "minimal" : g.env.NO_COLOR ? this._errorFormat = "colorless" : this._errorFormat = "colorless", this._runtimeDataModel = e3.runtimeDataModel, this._engineConfig = { enableDebugLogs: d, logLevel: s3.log && _l(s3.log), logQueries: s3.log && !!(typeof s3.log == "string" ? s3.log === "query" : s3.log.find((f) => typeof f == "string" ? f === "query" : f.level === "query")), compilerWasm: e3.compilerWasm, clientVersion: e3.clientVersion, previewFeatures: this._previewFeatures, activeProvider: e3.activeProvider, inlineSchema: e3.inlineSchema, tracingHelper: this._tracingHelper, transactionOptions: { maxWait: s3.transactionOptions?.maxWait ?? 2e3, timeout: s3.transactionOptions?.timeout ?? 5e3, isolationLevel: s3.transactionOptions?.isolationLevel }, logEmitter: i, adapter: o2, accelerateUrl: s3.accelerateUrl, sqlCommenters: s3.comments }, this._accelerateEngineConfig = Object.create(this._engineConfig), this._accelerateEngineConfig.accelerateUtils = { resolveDatasourceUrl: () => {
              if (s3.accelerateUrl)
                return s3.accelerateUrl;
              throw new D.PrismaClientInitializationError(`\`accelerateUrl\` is required when using \`@prisma/extension-accelerate\`:

new PrismaClient({
  accelerateUrl: "prisma://...",
}).$extends(withAccelerate())
`, e3.clientVersion);
            } }, lr("clientVersion", e3.clientVersion), this._engine = wl(this._engineConfig), this._requestHandler = new wn(this, i), s3.log)
              for (let f of s3.log) {
                let P = typeof f == "string" ? f : f.emit === "stdout" ? f.level : null;
                P && this.$on(P, (A) => {
                  Dt.log(`${Dt.tags[P] ?? ""}`, A.message || A.query);
                });
              }
          } catch (s3) {
            throw s3.clientVersion = this._clientVersion, s3;
          }
          return this._appliedParent = Qt(this);
        }
        get [Symbol.toStringTag]() {
          return "PrismaClient";
        }
        $on(n2, i) {
          return n2 === "beforeExit" ? this._engine.onBeforeExit(i) : n2 && this._engineConfig.logEmitter.on(n2, i), this;
        }
        $connect() {
          try {
            return this._engine.start();
          } catch (n2) {
            throw n2.clientVersion = this._clientVersion, n2;
          }
        }
        async $disconnect() {
          try {
            await this._engine.stop();
          } catch (n2) {
            throw n2.clientVersion = this._clientVersion, n2;
          } finally {
            go();
          }
        }
        $executeRawInternal(n2, i, o2, s3) {
          let a = this._activeProvider;
          return this._request({ action: "executeRaw", args: o2, transaction: n2, clientMethod: i, argsMapper: Mi({ clientMethod: i, activeProvider: a }), callsite: Me(this._errorFormat), dataPath: [], middlewareArgsMapper: s3 });
        }
        $executeRaw(n2, ...i) {
          return this._createPrismaPromise((o2) => {
            if (n2.raw !== void 0 || n2.sql !== void 0) {
              let [s3, a] = zl(n2, i);
              return ki(this._activeProvider, s3.text, s3.values, Array.isArray(n2) ? "prisma.$executeRaw`<SQL>`" : "prisma.$executeRaw(sql`<SQL>`)"), this.$executeRawInternal(o2, "$executeRaw", s3, a);
            }
            throw new D.PrismaClientValidationError("`$executeRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#executeraw\n", { clientVersion: this._clientVersion });
          });
        }
        $executeRawUnsafe(n2, ...i) {
          return this._createPrismaPromise((o2) => (ki(this._activeProvider, n2, i, "prisma.$executeRawUnsafe(<SQL>, [...values])"), this.$executeRawInternal(o2, "$executeRawUnsafe", [n2, ...i])));
        }
        $runCommandRaw(n2) {
          if (e3.activeProvider !== "mongodb")
            throw new D.PrismaClientValidationError(`The ${e3.activeProvider} provider does not support $runCommandRaw. Use the mongodb provider.`, { clientVersion: this._clientVersion });
          return this._createPrismaPromise((i) => this._request({ args: n2, clientMethod: "$runCommandRaw", dataPath: [], action: "runCommandRaw", argsMapper: bl, callsite: Me(this._errorFormat), transaction: i }));
        }
        async $queryRawInternal(n2, i, o2, s3) {
          let a = this._activeProvider;
          return this._request({ action: "queryRaw", args: o2, transaction: n2, clientMethod: i, argsMapper: Mi({ clientMethod: i, activeProvider: a }), callsite: Me(this._errorFormat), dataPath: [], middlewareArgsMapper: s3 });
        }
        $queryRaw(n2, ...i) {
          return this._createPrismaPromise((o2) => {
            if (n2.raw !== void 0 || n2.sql !== void 0)
              return this.$queryRawInternal(o2, "$queryRaw", ...zl(n2, i));
            throw new D.PrismaClientValidationError("`$queryRaw` is a tag function, please use it like the following:\n```\nconst result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n```\n\nOr read our docs at https://www.prisma.io/docs/concepts/components/prisma-client/raw-database-access#queryraw\n", { clientVersion: this._clientVersion });
          });
        }
        $queryRawTyped(n2) {
          return this._createPrismaPromise((i) => {
            if (!this._hasPreviewFlag("typedSql"))
              throw new D.PrismaClientValidationError("`typedSql` preview feature must be enabled in order to access $queryRawTyped API", { clientVersion: this._clientVersion });
            return this.$queryRawInternal(i, "$queryRawTyped", n2);
          });
        }
        $queryRawUnsafe(n2, ...i) {
          return this._createPrismaPromise((o2) => this.$queryRawInternal(o2, "$queryRawUnsafe", [n2, ...i]));
        }
        _transactionWithArray({ promises: n2, options: i }) {
          let o2 = Wm.nextId(), s3 = Ll(n2.length), a = n2.map((d, f) => {
            if (d?.[Symbol.toStringTag] !== "PrismaPromise")
              throw new Error("All elements of the array need to be Prisma Client promises. Hint: Please make sure you are not awaiting the Prisma client calls you intended to pass in the $transaction function.");
            let P = i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel, A = { kind: "batch", id: o2, index: f, isolationLevel: P, lock: s3 };
            return d.requestTransaction?.(A) ?? d;
          });
          return Kl(a);
        }
        async _transactionWithCallback({ callback: n2, options: i }) {
          let o2 = { traceparent: this._tracingHelper.getTraceParent() }, s3 = { maxWait: i?.maxWait ?? this._engineConfig.transactionOptions.maxWait, timeout: i?.timeout ?? this._engineConfig.transactionOptions.timeout, isolationLevel: i?.isolationLevel ?? this._engineConfig.transactionOptions.isolationLevel }, a = await this._engine.transaction("start", o2, s3), d;
          try {
            let f = { kind: "itx", ...a };
            d = await n2(this._createItxClient(f)), await this._engine.transaction("commit", o2, a);
          } catch (f) {
            throw await this._engine.transaction("rollback", o2, a).catch(() => {
            }), f;
          }
          return d;
        }
        _createItxClient(n2) {
          return pe(Qt(pe(ws(this), [ee("_appliedParent", () => this._appliedParent._createItxClient(n2)), ee("_createPrismaPromise", () => Di(n2)), ee(Jm, () => n2.id)])), [ft(Ps)]);
        }
        $transaction(n2, i) {
          let o2;
          typeof n2 == "function" ? this._engineConfig.adapter?.adapterName === "@prisma/adapter-d1" ? o2 = () => {
            throw new Error("Cloudflare D1 does not support interactive transactions. We recommend you to refactor your queries with that limitation in mind, and use batch transactions with `prisma.$transactions([])` where applicable.");
          } : o2 = () => this._transactionWithCallback({ callback: n2, options: i }) : o2 = () => this._transactionWithArray({ promises: n2, options: i });
          let s3 = { name: "transaction", attributes: { method: "$transaction" } };
          return this._tracingHelper.runInChildSpan(s3, o2);
        }
        _request(n2) {
          n2.otelParentCtx = this._tracingHelper.getActiveContext();
          let i = n2.middlewareArgsMapper ?? Hm, o2 = { args: i.requestArgsToMiddlewareArgs(n2.args), dataPath: n2.dataPath, runInTransaction: !!n2.transaction, action: n2.action, model: n2.model }, s3 = { operation: { name: "operation", attributes: { method: o2.action, model: o2.model, name: o2.model ? `${o2.model}.${o2.action}` : o2.action } } }, a = async (d) => {
            let { runInTransaction: f, args: P, ...A } = d, S = { ...n2, ...A };
            P && (S.args = i.middlewareArgsToRequestArgs(P)), n2.transaction !== void 0 && f === false && delete S.transaction;
            let C = await Ss(this, S);
            return S.model ? Ts({ result: C, modelName: S.model, args: S.args, extensions: this._extensions, runtimeDataModel: this._runtimeDataModel, globalOmit: this._globalOmit }) : C;
          };
          return this._tracingHelper.runInChildSpan(s3.operation, () => a(o2));
        }
        async _executeRequest({ args: n2, clientMethod: i, dataPath: o2, callsite: s3, action: a, model: d, argsMapper: f, transaction: P, unpacker: A, otelParentCtx: S, customDataProxyFetch: C }) {
          try {
            n2 = f ? f(n2) : n2;
            let M = { name: "serialize" }, R = this._tracingHelper.runInChildSpan(M, () => _r({ modelName: d, runtimeDataModel: this._runtimeDataModel, action: a, args: n2, clientMethod: i, callsite: s3, extensions: this._extensions, errorFormat: this._errorFormat, clientVersion: this._clientVersion, previewFeatures: this._previewFeatures, globalOmit: this._globalOmit }));
            return Y.enabled("prisma:client") && (lr("Prisma Client call:"), lr(`prisma.${i}(${ls(n2)})`), lr("Generated request:"), lr(JSON.stringify(R, null, 2) + `
`)), P?.kind === "batch" && await P.lock, this._requestHandler.request({ protocolQuery: R, modelName: d, action: a, clientMethod: i, dataPath: o2, callsite: s3, args: n2, extensions: this._extensions, transaction: P, unpacker: A, otelParentCtx: S, otelChildCtx: this._tracingHelper.getActiveContext(), globalOmit: this._globalOmit, customDataProxyFetch: C });
          } catch (M) {
            throw M.clientVersion = this._clientVersion, M;
          }
        }
        _hasPreviewFlag(n2) {
          return !!this._engineConfig.previewFeatures?.includes(n2);
        }
        $extends = bs;
      }
      return t2;
    }
    function zl(e3, t2) {
      return Gm(e3) ? [new Zl.Sql(e3, t2), Rl] : [e3, Il];
    }
    function Gm(e3) {
      return Array.isArray(e3) && Array.isArray(e3.raw);
    }
    l();
    u();
    c2();
    p();
    m();
    var Km = /* @__PURE__ */ new Set(["toJSON", "$$typeof", "asymmetricMatch", Symbol.iterator, Symbol.toStringTag, Symbol.isConcatSpreadable, Symbol.toPrimitive]);
    function Xl(e3) {
      return new Proxy(e3, { get(t2, r3) {
        if (r3 in t2)
          return t2[r3];
        if (!Km.has(r3))
          throw new TypeError(`Invalid enum value: ${String(r3)}`);
      } });
    }
    l();
    u();
    c2();
    p();
    m();
    var zm = () => globalThis.process?.release?.name === "node";
    var Zm = () => !!globalThis.Bun || !!globalThis.process?.versions?.bun;
    var Ym = () => !!globalThis.Deno;
    var Xm = () => typeof globalThis.Netlify == "object";
    var ed = () => typeof globalThis.EdgeRuntime == "object";
    var td = () => globalThis.navigator?.userAgent === "Cloudflare-Workers";
    function rd() {
      return [[Xm, "netlify"], [ed, "edge-light"], [td, "workerd"], [Ym, "deno"], [Zm, "bun"], [zm, "node"]].flatMap((r3) => r3[0]() ? [r3[1]] : []).at(0) ?? "";
    }
    var nd = { node: "Node.js", workerd: "Cloudflare Workers", deno: "Deno and Deno Deploy", netlify: "Netlify Edge Functions", "edge-light": "Edge Runtime (Vercel Edge Functions, Vercel Edge Middleware, Next.js (Pages Router) Edge API Routes, Next.js (App Router) Edge Route Handlers or Next.js Middleware)" };
    function eu() {
      let e3 = rd();
      return { id: e3, prettyName: nd[e3] || e3, isEdge: ["workerd", "deno", "netlify", "edge-light"].includes(e3) };
    }
    var D = require_dist();
    var Te = require_dist();
    var X = require_dist();
    var tu = require_dist();
  }
});

// node_modules/.prisma/client/query_compiler_bg.js
var require_query_compiler_bg = __commonJS({
  "node_modules/.prisma/client/query_compiler_bg.js"(exports, module) {
    "use strict";
    var h = Object.defineProperty;
    var T = Object.getOwnPropertyDescriptor;
    var M = Object.getOwnPropertyNames;
    var j = Object.prototype.hasOwnProperty;
    var D = (e3, t2) => {
      for (var n2 in t2)
        h(e3, n2, { get: t2[n2], enumerable: true });
    };
    var O = (e3, t2, n2, _) => {
      if (t2 && typeof t2 == "object" || typeof t2 == "function")
        for (let r3 of M(t2))
          !j.call(e3, r3) && r3 !== n2 && h(e3, r3, { get: () => t2[r3], enumerable: !(_ = T(t2, r3)) || _.enumerable });
      return e3;
    };
    var B = (e3) => O(h({}, "__esModule", { value: true }), e3);
    var xe = {};
    D(xe, { QueryCompiler: () => F, __wbg_Error_e83987f665cf5504: () => q, __wbg_Number_bb48ca12f395cd08: () => C, __wbg_String_8f0eb39a4a4c2f66: () => k, __wbg___wbindgen_boolean_get_6d5a1ee65bab5f68: () => W, __wbg___wbindgen_debug_string_df47ffb5e35e6763: () => V, __wbg___wbindgen_in_bb933bd9e1b3bc0f: () => z, __wbg___wbindgen_is_object_c818261d21f283a4: () => L, __wbg___wbindgen_is_string_fbb76cb2940daafd: () => P, __wbg___wbindgen_is_undefined_2d472862bd29a478: () => Q, __wbg___wbindgen_jsval_loose_eq_b664b38a2f582147: () => Y, __wbg___wbindgen_number_get_a20bf9b85341449d: () => G, __wbg___wbindgen_string_get_e4f06c90489ad01b: () => J, __wbg___wbindgen_throw_b855445ff6a94295: () => X, __wbg_entries_e171b586f8f6bdbf: () => H, __wbg_getTime_14776bfb48a1bff9: () => K, __wbg_get_7bed016f185add81: () => Z, __wbg_get_with_ref_key_1dc361bd10053bfe: () => v, __wbg_instanceof_ArrayBuffer_70beb1189ca63b38: () => ee, __wbg_instanceof_Uint8Array_20c8e73002f7af98: () => te, __wbg_isSafeInteger_d216eda7911dde36: () => ne, __wbg_length_69bca3cb64fc8748: () => re, __wbg_length_cdd215e10d9dd507: () => _e, __wbg_new_0_f9740686d739025c: () => oe, __wbg_new_1acc0b6eea89d040: () => ce, __wbg_new_5a79be3ab53b8aa5: () => ie, __wbg_new_68651c719dcda04e: () => se, __wbg_new_e17d9f43105b08be: () => ue, __wbg_prototypesetcall_2a6620b6922694b2: () => fe, __wbg_set_3f1d0b984ed272ed: () => be, __wbg_set_907fb406c34a251d: () => de, __wbg_set_c213c871859d6500: () => ae, __wbg_set_message_82ae475bb413aa5c: () => ge, __wbg_set_wasm: () => N, __wbindgen_cast_2241b6af4c4b2941: () => le, __wbindgen_cast_4625c577ab2ec9ee: () => we, __wbindgen_cast_9ae0607507abb057: () => pe, __wbindgen_cast_d6cd19b81560fd6e: () => ye, __wbindgen_init_externref_table: () => me });
    module.exports = B(xe);
    var A = () => {
    };
    A.prototype = A;
    var o2;
    function N(e3) {
      o2 = e3;
    }
    var p = null;
    function a() {
      return (p === null || p.byteLength === 0) && (p = new Uint8Array(o2.memory.buffer)), p;
    }
    var y = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true });
    y.decode();
    var U = 2146435072;
    var S = 0;
    function R(e3, t2) {
      return S += t2, S >= U && (y = new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }), y.decode(), S = t2), y.decode(a().subarray(e3, e3 + t2));
    }
    function m(e3, t2) {
      return e3 = e3 >>> 0, R(e3, t2);
    }
    var f = 0;
    var g = new TextEncoder();
    "encodeInto" in g || (g.encodeInto = function(e3, t2) {
      const n2 = g.encode(e3);
      return t2.set(n2), { read: e3.length, written: n2.length };
    });
    function l(e3, t2, n2) {
      if (n2 === void 0) {
        const i = g.encode(e3), d = t2(i.length, 1) >>> 0;
        return a().subarray(d, d + i.length).set(i), f = i.length, d;
      }
      let _ = e3.length, r3 = t2(_, 1) >>> 0;
      const s3 = a();
      let c2 = 0;
      for (; c2 < _; c2++) {
        const i = e3.charCodeAt(c2);
        if (i > 127)
          break;
        s3[r3 + c2] = i;
      }
      if (c2 !== _) {
        c2 !== 0 && (e3 = e3.slice(c2)), r3 = n2(r3, _, _ = c2 + e3.length * 3, 1) >>> 0;
        const i = a().subarray(r3 + c2, r3 + _), d = g.encodeInto(e3, i);
        c2 += d.written, r3 = n2(r3, _, c2, 1) >>> 0;
      }
      return f = c2, r3;
    }
    var b = null;
    function u() {
      return (b === null || b.buffer.detached === true || b.buffer.detached === void 0 && b.buffer !== o2.memory.buffer) && (b = new DataView(o2.memory.buffer)), b;
    }
    function x(e3) {
      return e3 == null;
    }
    function I(e3) {
      const t2 = typeof e3;
      if (t2 == "number" || t2 == "boolean" || e3 == null)
        return `${e3}`;
      if (t2 == "string")
        return `"${e3}"`;
      if (t2 == "symbol") {
        const r3 = e3.description;
        return r3 == null ? "Symbol" : `Symbol(${r3})`;
      }
      if (t2 == "function") {
        const r3 = e3.name;
        return typeof r3 == "string" && r3.length > 0 ? `Function(${r3})` : "Function";
      }
      if (Array.isArray(e3)) {
        const r3 = e3.length;
        let s3 = "[";
        r3 > 0 && (s3 += I(e3[0]));
        for (let c2 = 1; c2 < r3; c2++)
          s3 += ", " + I(e3[c2]);
        return s3 += "]", s3;
      }
      const n2 = /\[object ([^\]]+)\]/.exec(toString.call(e3));
      let _;
      if (n2 && n2.length > 1)
        _ = n2[1];
      else
        return toString.call(e3);
      if (_ == "Object")
        try {
          return "Object(" + JSON.stringify(e3) + ")";
        } catch {
          return "Object";
        }
      return e3 instanceof Error ? `${e3.name}: ${e3.message}
${e3.stack}` : _;
    }
    function $(e3, t2) {
      return e3 = e3 >>> 0, a().subarray(e3 / 1, e3 / 1 + t2);
    }
    function w(e3) {
      const t2 = o2.__wbindgen_externrefs.get(e3);
      return o2.__externref_table_dealloc(e3), t2;
    }
    var E = typeof FinalizationRegistry > "u" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((e3) => o2.__wbg_querycompiler_free(e3 >>> 0, 1));
    var F = class {
      __destroy_into_raw() {
        const t2 = this.__wbg_ptr;
        return this.__wbg_ptr = 0, E.unregister(this), t2;
      }
      free() {
        const t2 = this.__destroy_into_raw();
        o2.__wbg_querycompiler_free(t2, 0);
      }
      compileBatch(t2) {
        const n2 = l(t2, o2.__wbindgen_malloc, o2.__wbindgen_realloc), _ = f, r3 = o2.querycompiler_compileBatch(this.__wbg_ptr, n2, _);
        if (r3[2])
          throw w(r3[1]);
        return w(r3[0]);
      }
      constructor(t2) {
        const n2 = o2.querycompiler_new(t2);
        if (n2[2])
          throw w(n2[1]);
        return this.__wbg_ptr = n2[0] >>> 0, E.register(this, this.__wbg_ptr, this), this;
      }
      compile(t2) {
        const n2 = l(t2, o2.__wbindgen_malloc, o2.__wbindgen_realloc), _ = f, r3 = o2.querycompiler_compile(this.__wbg_ptr, n2, _);
        if (r3[2])
          throw w(r3[1]);
        return w(r3[0]);
      }
    };
    Symbol.dispose && (F.prototype[Symbol.dispose] = F.prototype.free);
    function q(e3, t2) {
      return Error(m(e3, t2));
    }
    function C(e3) {
      return Number(e3);
    }
    function k(e3, t2) {
      const n2 = String(t2), _ = l(n2, o2.__wbindgen_malloc, o2.__wbindgen_realloc), r3 = f;
      u().setInt32(e3 + 4 * 1, r3, true), u().setInt32(e3 + 4 * 0, _, true);
    }
    function W(e3) {
      const t2 = e3, n2 = typeof t2 == "boolean" ? t2 : void 0;
      return x(n2) ? 16777215 : n2 ? 1 : 0;
    }
    function V(e3, t2) {
      const n2 = I(t2), _ = l(n2, o2.__wbindgen_malloc, o2.__wbindgen_realloc), r3 = f;
      u().setInt32(e3 + 4 * 1, r3, true), u().setInt32(e3 + 4 * 0, _, true);
    }
    function z(e3, t2) {
      return e3 in t2;
    }
    function L(e3) {
      const t2 = e3;
      return typeof t2 == "object" && t2 !== null;
    }
    function P(e3) {
      return typeof e3 == "string";
    }
    function Q(e3) {
      return e3 === void 0;
    }
    function Y(e3, t2) {
      return e3 == t2;
    }
    function G(e3, t2) {
      const n2 = t2, _ = typeof n2 == "number" ? n2 : void 0;
      u().setFloat64(e3 + 8 * 1, x(_) ? 0 : _, true), u().setInt32(e3 + 4 * 0, !x(_), true);
    }
    function J(e3, t2) {
      const n2 = t2, _ = typeof n2 == "string" ? n2 : void 0;
      var r3 = x(_) ? 0 : l(_, o2.__wbindgen_malloc, o2.__wbindgen_realloc), s3 = f;
      u().setInt32(e3 + 4 * 1, s3, true), u().setInt32(e3 + 4 * 0, r3, true);
    }
    function X(e3, t2) {
      throw new Error(m(e3, t2));
    }
    function H(e3) {
      return Object.entries(e3);
    }
    function K(e3) {
      return e3.getTime();
    }
    function Z(e3, t2) {
      return e3[t2 >>> 0];
    }
    function v(e3, t2) {
      return e3[t2];
    }
    function ee(e3) {
      let t2;
      try {
        t2 = e3 instanceof ArrayBuffer;
      } catch {
        t2 = false;
      }
      return t2;
    }
    function te(e3) {
      let t2;
      try {
        t2 = e3 instanceof Uint8Array;
      } catch {
        t2 = false;
      }
      return t2;
    }
    function ne(e3) {
      return Number.isSafeInteger(e3);
    }
    function re(e3) {
      return e3.length;
    }
    function _e(e3) {
      return e3.length;
    }
    function oe() {
      return /* @__PURE__ */ new Date();
    }
    function ce() {
      return new Object();
    }
    function ie(e3) {
      return new Uint8Array(e3);
    }
    function se() {
      return /* @__PURE__ */ new Map();
    }
    function ue() {
      return new Array();
    }
    function fe(e3, t2, n2) {
      Uint8Array.prototype.set.call($(e3, t2), n2);
    }
    function be(e3, t2, n2) {
      e3[t2] = n2;
    }
    function de(e3, t2, n2) {
      return e3.set(t2, n2);
    }
    function ae(e3, t2, n2) {
      e3[t2 >>> 0] = n2;
    }
    function ge(e3, t2) {
      global.PRISMA_WASM_PANIC_REGISTRY.set_message(m(e3, t2));
    }
    function le(e3, t2) {
      return m(e3, t2);
    }
    function we(e3) {
      return BigInt.asUintN(64, e3);
    }
    function pe(e3) {
      return e3;
    }
    function ye(e3) {
      return e3;
    }
    function me() {
      const e3 = o2.__wbindgen_externrefs, t2 = e3.grow(4);
      e3.set(0, void 0), e3.set(t2 + 0, void 0), e3.set(t2 + 1, null), e3.set(t2 + 2, true), e3.set(t2 + 3, false);
    }
  }
});

// node_modules/.prisma/client/wasm-worker-loader.mjs
var wasm_worker_loader_exports = {};
__export(wasm_worker_loader_exports, {
  default: () => wasm_worker_loader_default
});
var wasm_worker_loader_default;
var init_wasm_worker_loader = __esm({
  "node_modules/.prisma/client/wasm-worker-loader.mjs"() {
    wasm_worker_loader_default = import("./query_compiler_bg-YL6VPJVB.wasm");
  }
});

// node_modules/.prisma/client/edge.js
var require_edge = __commonJS({
  "node_modules/.prisma/client/edge.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var {
      PrismaClientKnownRequestError: PrismaClientKnownRequestError2,
      PrismaClientUnknownRequestError: PrismaClientUnknownRequestError2,
      PrismaClientRustPanicError: PrismaClientRustPanicError2,
      PrismaClientInitializationError: PrismaClientInitializationError2,
      PrismaClientValidationError: PrismaClientValidationError2,
      getPrismaClient: getPrismaClient2,
      sqltag: sqltag2,
      empty: empty2,
      join: join2,
      raw: raw2,
      skip: skip2,
      Decimal: Decimal2,
      Debug: Debug2,
      DbNull: DbNull2,
      JsonNull: JsonNull2,
      AnyNull: AnyNull2,
      NullTypes: NullTypes2,
      makeStrictEnum: makeStrictEnum2,
      Extensions: Extensions2,
      warnOnce: warnOnce2,
      defineDmmfProperty: defineDmmfProperty2,
      Public: Public2,
      getRuntime: getRuntime2,
      createParam: createParam2
    } = require_wasm_compiler_edge();
    var Prisma = {};
    exports.Prisma = Prisma;
    exports.$Enums = {};
    Prisma.prismaVersion = {
      client: "7.1.0",
      engine: "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba"
    };
    Prisma.PrismaClientKnownRequestError = PrismaClientKnownRequestError2;
    Prisma.PrismaClientUnknownRequestError = PrismaClientUnknownRequestError2;
    Prisma.PrismaClientRustPanicError = PrismaClientRustPanicError2;
    Prisma.PrismaClientInitializationError = PrismaClientInitializationError2;
    Prisma.PrismaClientValidationError = PrismaClientValidationError2;
    Prisma.Decimal = Decimal2;
    Prisma.sql = sqltag2;
    Prisma.empty = empty2;
    Prisma.join = join2;
    Prisma.raw = raw2;
    Prisma.validator = Public2.validator;
    Prisma.getExtensionContext = Extensions2.getExtensionContext;
    Prisma.defineExtension = Extensions2.defineExtension;
    Prisma.DbNull = DbNull2;
    Prisma.JsonNull = JsonNull2;
    Prisma.AnyNull = AnyNull2;
    Prisma.NullTypes = NullTypes2;
    exports.Prisma.TransactionIsolationLevel = makeStrictEnum2({
      ReadUncommitted: "ReadUncommitted",
      ReadCommitted: "ReadCommitted",
      RepeatableRead: "RepeatableRead",
      Serializable: "Serializable"
    });
    exports.Prisma.AssetScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      type: "type",
      status: "status",
      purchaseDate: "purchaseDate",
      warrantyExpiry: "warrantyExpiry",
      lastMaintenance: "lastMaintenance",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      siteId: "siteId",
      unitId: "unitId"
    };
    exports.Prisma.AuditLogScalarFieldEnum = {
      id: "id",
      action: "action",
      details: "details",
      createdAt: "createdAt",
      userId: "userId"
    };
    exports.Prisma.BuildingScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      address: "address",
      city: "city",
      state: "state",
      zipCode: "zipCode",
      country: "country",
      yearBuilt: "yearBuilt",
      floors: "floors",
      squareFeet: "squareFeet",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      siteId: "siteId"
    };
    exports.Prisma.IPBlockScalarFieldEnum = {
      id: "id",
      ipAddress: "ipAddress",
      reason: "reason",
      severity: "severity",
      violationCount: "violationCount",
      blockedBy: "blockedBy",
      blockedAt: "blockedAt",
      expiresAt: "expiresAt",
      organizationId: "organizationId",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.OrganizationScalarFieldEnum = {
      id: "id",
      name: "name",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.OrganizationInviteScalarFieldEnum = {
      id: "id",
      email: "email",
      token: "token",
      status: "status",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      expiresAt: "expiresAt",
      organizationId: "organizationId",
      invitedByUserId: "invitedByUserId"
    };
    exports.Prisma.SecurityLogScalarFieldEnum = {
      id: "id",
      ipAddress: "ipAddress",
      userAgent: "userAgent",
      action: "action",
      details: "details",
      severity: "severity",
      userId: "userId",
      createdAt: "createdAt"
    };
    exports.Prisma.SessionScalarFieldEnum = {
      id: "id",
      token: "token",
      expiresAt: "expiresAt",
      userId: "userId"
    };
    exports.Prisma.SiteScalarFieldEnum = {
      id: "id",
      name: "name",
      address: "address",
      city: "city",
      state: "state",
      zipCode: "zipCode",
      country: "country",
      phoneNumber: "phoneNumber",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      organizationId: "organizationId"
    };
    exports.Prisma.UnitScalarFieldEnum = {
      id: "id",
      roomNumber: "roomNumber",
      name: "name",
      floor: "floor",
      squareFeet: "squareFeet",
      description: "description",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      siteId: "siteId",
      buildingId: "buildingId"
    };
    exports.Prisma.UserScalarFieldEnum = {
      id: "id",
      email: "email",
      password: "password",
      recoveryPassphrase: "recoveryPassphrase",
      passwordResetToken: "passwordResetToken",
      passwordResetExpiresAt: "passwordResetExpiresAt",
      firstName: "firstName",
      lastName: "lastName",
      phoneNumber: "phoneNumber",
      role: "role",
      isActive: "isActive",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      organizationId: "organizationId"
    };
    exports.Prisma.WaitlistScalarFieldEnum = {
      id: "id",
      email: "email",
      name: "name",
      company: "company",
      role: "role",
      phone: "phone",
      createdAt: "createdAt"
    };
    exports.Prisma.WorkOrderScalarFieldEnum = {
      id: "id",
      title: "title",
      description: "description",
      priority: "priority",
      status: "status",
      dueDate: "dueDate",
      completedAt: "completedAt",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      assetId: "assetId",
      unitId: "unitId",
      buildingId: "buildingId",
      siteId: "siteId",
      createdById: "createdById",
      assignedToId: "assignedToId",
      organizationId: "organizationId"
    };
    exports.Prisma.WorkOrderEventScalarFieldEnum = {
      id: "id",
      event: "event",
      description: "description",
      createdAt: "createdAt",
      workOrderId: "workOrderId",
      userId: "userId"
    };
    exports.Prisma.WorkOrderCommentScalarFieldEnum = {
      id: "id",
      content: "content",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      isEdited: "isEdited",
      isDeleted: "isDeleted",
      editedAt: "editedAt",
      workOrderId: "workOrderId",
      userId: "userId",
      parentId: "parentId"
    };
    exports.Prisma.CommentEditScalarFieldEnum = {
      id: "id",
      content: "content",
      editedAt: "editedAt",
      commentId: "commentId",
      userId: "userId"
    };
    exports.Prisma.CommentMentionScalarFieldEnum = {
      id: "id",
      commentId: "commentId",
      mentionedUserId: "mentionedUserId"
    };
    exports.Prisma.WorkOrderStatusHistoryScalarFieldEnum = {
      id: "id",
      fromStatus: "fromStatus",
      toStatus: "toStatus",
      reason: "reason",
      createdAt: "createdAt",
      workOrderId: "workOrderId",
      userId: "userId"
    };
    exports.Prisma.WorkOrderChecklistItemScalarFieldEnum = {
      id: "id",
      title: "title",
      isCompleted: "isCompleted",
      position: "position",
      workOrderId: "workOrderId",
      createdAt: "createdAt",
      updatedAt: "updatedAt"
    };
    exports.Prisma.WorkOrderTemplateScalarFieldEnum = {
      id: "id",
      name: "name",
      description: "description",
      title: "title",
      workDescription: "workDescription",
      priority: "priority",
      isGlobal: "isGlobal",
      organizationId: "organizationId",
      isActive: "isActive",
      usageCount: "usageCount",
      createdAt: "createdAt",
      updatedAt: "updatedAt",
      createdBy: "createdBy"
    };
    exports.Prisma.WorkOrderTemplateItemScalarFieldEnum = {
      id: "id",
      title: "title",
      position: "position",
      templateId: "templateId"
    };
    exports.Prisma.SortOrder = {
      asc: "asc",
      desc: "desc"
    };
    exports.Prisma.NullableJsonNullValueInput = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull
    };
    exports.Prisma.QueryMode = {
      default: "default",
      insensitive: "insensitive"
    };
    exports.Prisma.NullsOrder = {
      first: "first",
      last: "last"
    };
    exports.Prisma.JsonNullValueFilter = {
      DbNull: Prisma.DbNull,
      JsonNull: Prisma.JsonNull,
      AnyNull: Prisma.AnyNull
    };
    exports.AssetStatus = exports.$Enums.AssetStatus = {
      OPERATIONAL: "OPERATIONAL",
      NEEDS_MAINTENANCE: "NEEDS_MAINTENANCE",
      OUT_OF_SERVICE: "OUT_OF_SERVICE"
    };
    exports.AssetType = exports.$Enums.AssetType = {
      HVAC: "HVAC",
      ELECTRICAL: "ELECTRICAL",
      PLUMBING: "PLUMBING",
      FIRE_SAFETY: "FIRE_SAFETY",
      ELEVATOR: "ELEVATOR",
      SECURITY_SYSTEM: "SECURITY_SYSTEM",
      OTHER: "OTHER"
    };
    exports.InviteStatus = exports.$Enums.InviteStatus = {
      PENDING: "PENDING",
      ACCEPTED: "ACCEPTED",
      EXPIRED: "EXPIRED",
      CANCELLED: "CANCELLED"
    };
    exports.Priority = exports.$Enums.Priority = {
      LOW: "LOW",
      MEDIUM: "MEDIUM",
      HIGH: "HIGH",
      EMERGENCY: "EMERGENCY"
    };
    exports.UserRole = exports.$Enums.UserRole = {
      ADMIN: "ADMIN",
      MANAGER: "MANAGER",
      TECHNICIAN: "TECHNICIAN"
    };
    exports.WorkOrderStatus = exports.$Enums.WorkOrderStatus = {
      PENDING: "PENDING",
      IN_PROGRESS: "IN_PROGRESS",
      COMPLETED: "COMPLETED",
      ON_HOLD: "ON_HOLD",
      CANCELLED: "CANCELLED"
    };
    exports.Prisma.ModelName = {
      Asset: "Asset",
      AuditLog: "AuditLog",
      Building: "Building",
      IPBlock: "IPBlock",
      Organization: "Organization",
      OrganizationInvite: "OrganizationInvite",
      SecurityLog: "SecurityLog",
      Session: "Session",
      Site: "Site",
      Unit: "Unit",
      User: "User",
      Waitlist: "Waitlist",
      WorkOrder: "WorkOrder",
      WorkOrderEvent: "WorkOrderEvent",
      WorkOrderComment: "WorkOrderComment",
      CommentEdit: "CommentEdit",
      CommentMention: "CommentMention",
      WorkOrderStatusHistory: "WorkOrderStatusHistory",
      WorkOrderChecklistItem: "WorkOrderChecklistItem",
      WorkOrderTemplate: "WorkOrderTemplate",
      WorkOrderTemplateItem: "WorkOrderTemplateItem"
    };
    var config2 = {
      "previewFeatures": [],
      "clientVersion": "7.1.0",
      "engineVersion": "ab635e6b9d606fa5c8fb8b1a7f909c3c3c1c98ba",
      "activeProvider": "postgresql",
      "inlineSchema": 'generator client {\n  provider   = "prisma-client-js"\n  output     = "../node_modules/.prisma/client"\n  engineType = "library"\n}\n\ndatasource db {\n  provider = "postgresql"\n}\n\nmodel Asset {\n  id              String      @id @default(dbgenerated("gen_random_uuid()"))\n  name            String\n  description     String?\n  type            AssetType\n  status          AssetStatus @default(OPERATIONAL)\n  purchaseDate    DateTime?\n  warrantyExpiry  DateTime?\n  lastMaintenance DateTime?\n  createdAt       DateTime    @default(now())\n  updatedAt       DateTime\n  siteId          String\n  unitId          String\n  Site            Site        @relation(fields: [siteId], references: [id], onDelete: Cascade)\n  Unit            Unit        @relation(fields: [unitId], references: [id], onDelete: Cascade)\n  WorkOrder       WorkOrder[]\n\n  @@index([name])\n  @@index([siteId])\n  @@index([status])\n  @@index([type])\n  @@index([unitId])\n}\n\nmodel AuditLog {\n  id        String   @id @default(dbgenerated("gen_random_uuid()"))\n  action    String\n  details   Json?\n  createdAt DateTime @default(now())\n  userId    String\n  User      User     @relation(fields: [userId], references: [id])\n\n  @@index([createdAt])\n  @@index([userId])\n}\n\nmodel Building {\n  id          String      @id @default(dbgenerated("gen_random_uuid()"))\n  name        String\n  description String?\n  address     String?\n  city        String?\n  state       String?\n  zipCode     String?\n  country     String?\n  yearBuilt   Int?\n  floors      Int?\n  squareFeet  Int?\n  createdAt   DateTime    @default(now())\n  updatedAt   DateTime\n  siteId      String\n  Site        Site        @relation(fields: [siteId], references: [id], onDelete: Cascade)\n  Unit        Unit[]\n  WorkOrder   WorkOrder[]\n\n  @@index([name])\n  @@index([siteId])\n}\n\nmodel IPBlock {\n  id             String        @id @default(dbgenerated("gen_random_uuid()"))\n  ipAddress      String        @unique\n  reason         String\n  severity       String\n  violationCount Int           @default(1)\n  blockedBy      String?\n  blockedAt      DateTime      @default(now())\n  expiresAt      DateTime?\n  organizationId String?\n  createdAt      DateTime      @default(now())\n  updatedAt      DateTime\n  User           User?         @relation(fields: [blockedBy], references: [id])\n  Organization   Organization? @relation(fields: [organizationId], references: [id], onDelete: Cascade)\n\n  @@index([expiresAt])\n  @@index([ipAddress])\n  @@index([organizationId])\n  @@index([severity])\n}\n\nmodel Organization {\n  id                 String               @id @default(dbgenerated("gen_random_uuid()"))\n  name               String               @unique\n  createdAt          DateTime             @default(now())\n  updatedAt          DateTime\n  IPBlock            IPBlock[]\n  OrganizationInvite OrganizationInvite[]\n  Site               Site[]\n  User               User[]\n  WorkOrder          WorkOrder[]\n  WorkOrderTemplate  WorkOrderTemplate[]\n\n  @@index([name])\n}\n\nmodel OrganizationInvite {\n  id              String       @id @default(dbgenerated("gen_random_uuid()"))\n  email           String\n  token           String       @unique\n  status          InviteStatus @default(PENDING)\n  createdAt       DateTime     @default(now())\n  updatedAt       DateTime\n  expiresAt       DateTime\n  organizationId  String\n  invitedByUserId String\n  User            User         @relation(fields: [invitedByUserId], references: [id], onDelete: Cascade)\n  Organization    Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)\n\n  @@index([email])\n  @@index([expiresAt])\n  @@index([token])\n}\n\nmodel SecurityLog {\n  id        String   @id @default(dbgenerated("gen_random_uuid()"))\n  ipAddress String\n  userAgent String?\n  action    String\n  details   Json?\n  severity  String   @default("INFO")\n  userId    String?\n  createdAt DateTime @default(now())\n  User      User?    @relation(fields: [userId], references: [id])\n\n  @@index([createdAt])\n  @@index([ipAddress])\n  @@index([severity])\n}\n\nmodel Session {\n  id        String   @id @default(dbgenerated("gen_random_uuid()"))\n  token     String   @unique\n  expiresAt DateTime\n  userId    String\n  User      User     @relation(fields: [userId], references: [id], onDelete: Cascade)\n\n  @@index([expiresAt])\n  @@index([token])\n  @@index([userId])\n}\n\nmodel Site {\n  id             String       @id @default(dbgenerated("gen_random_uuid()"))\n  name           String\n  address        String?\n  city           String?\n  state          String?\n  zipCode        String?\n  country        String?\n  phoneNumber    String?\n  createdAt      DateTime     @default(now())\n  updatedAt      DateTime\n  organizationId String\n  Asset          Asset[]\n  Building       Building[]\n  Organization   Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)\n  Unit           Unit[]\n  WorkOrder      WorkOrder[]\n\n  @@index([name])\n  @@index([organizationId])\n}\n\nmodel Unit {\n  id          String      @id @default(dbgenerated("gen_random_uuid()"))\n  roomNumber  String\n  name        String?\n  floor       Int?\n  squareFeet  Int?\n  description String?\n  createdAt   DateTime    @default(now())\n  updatedAt   DateTime\n  siteId      String\n  buildingId  String?\n  Asset       Asset[]\n  Building    Building?   @relation(fields: [buildingId], references: [id], onDelete: Cascade)\n  Site        Site        @relation(fields: [siteId], references: [id], onDelete: Cascade)\n  WorkOrder   WorkOrder[]\n\n  @@index([buildingId])\n  @@index([roomNumber])\n  @@index([siteId])\n}\n\nmodel User {\n  id                                     String                   @id @default(dbgenerated("gen_random_uuid()"))\n  email                                  String                   @unique\n  password                               String\n  recoveryPassphrase                     String? // For emergency password recovery\n  passwordResetToken                     String?                  @unique // One-time reset token\n  passwordResetExpiresAt                 DateTime? // Token expiration\n  firstName                              String?\n  lastName                               String?\n  phoneNumber                            String?\n  role                                   UserRole                 @default(TECHNICIAN)\n  isActive                               Boolean                  @default(true)\n  createdAt                              DateTime                 @default(now())\n  updatedAt                              DateTime\n  organizationId                         String?\n  AuditLog                               AuditLog[]\n  IPBlock                                IPBlock[]\n  OrganizationInvite                     OrganizationInvite[]\n  SecurityLog                            SecurityLog[]\n  Session                                Session[]\n  Organization                           Organization?            @relation(fields: [organizationId], references: [id], onDelete: Cascade)\n  WorkOrder_WorkOrder_assignedToIdToUser WorkOrder[]              @relation("WorkOrder_assignedToIdToUser")\n  WorkOrder_WorkOrder_createdByIdToUser  WorkOrder[]              @relation("WorkOrder_createdByIdToUser")\n  WorkOrderEvent                         WorkOrderEvent[]\n  WorkOrderComment                       WorkOrderComment[]       @relation("UserComments")\n  CommentEdit                            CommentEdit[]            @relation("CommentEditUser")\n  CommentMentionReceived                 CommentMention[]         @relation("MentionedUser")\n  WorkOrderStatusHistory                 WorkOrderStatusHistory[] @relation("StatusHistoryUser")\n  WorkOrderTemplate                      WorkOrderTemplate[]      @relation("TemplateCreator")\n\n  @@index([email])\n  @@index([organizationId])\n  @@index([passwordResetToken])\n  @@index([passwordResetExpiresAt])\n}\n\nmodel Waitlist {\n  id        String   @id @default(dbgenerated("gen_random_uuid()"))\n  email     String   @unique\n  name      String?\n  company   String?\n  role      String?\n  phone     String?\n  createdAt DateTime @default(now())\n}\n\nmodel WorkOrder {\n  id                                String                   @id @default(dbgenerated("gen_random_uuid()"))\n  title                             String\n  description                       String?\n  priority                          Priority                 @default(MEDIUM)\n  status                            WorkOrderStatus          @default(PENDING)\n  dueDate                           DateTime?\n  completedAt                       DateTime?\n  createdAt                         DateTime                 @default(now())\n  updatedAt                         DateTime\n  assetId                           String?\n  unitId                            String?\n  buildingId                        String?\n  siteId                            String?\n  createdById                       String\n  assignedToId                      String?\n  organizationId                    String\n  Asset                             Asset?                   @relation(fields: [assetId], references: [id], onDelete: Cascade)\n  User_WorkOrder_assignedToIdToUser User?                    @relation("WorkOrder_assignedToIdToUser", fields: [assignedToId], references: [id])\n  Building                          Building?                @relation(fields: [buildingId], references: [id], onDelete: Cascade)\n  User_WorkOrder_createdByIdToUser  User                     @relation("WorkOrder_createdByIdToUser", fields: [createdById], references: [id], onDelete: Cascade)\n  Organization                      Organization             @relation(fields: [organizationId], references: [id], onDelete: Cascade)\n  Site                              Site?                    @relation(fields: [siteId], references: [id], onDelete: Cascade)\n  Unit                              Unit?                    @relation(fields: [unitId], references: [id], onDelete: Cascade)\n  WorkOrderEvent                    WorkOrderEvent[]\n  WorkOrderComment                  WorkOrderComment[]\n  WorkOrderStatusHistory            WorkOrderStatusHistory[]\n  WorkOrderChecklistItem            WorkOrderChecklistItem[]\n\n  @@index([assetId])\n  @@index([assignedToId])\n  @@index([createdById])\n  @@index([dueDate])\n  @@index([organizationId])\n  @@index([priority])\n  @@index([status])\n  @@index([unitId])\n}\n\nmodel WorkOrderEvent {\n  id          String    @id @default(dbgenerated("gen_random_uuid()"))\n  event       String\n  description String?\n  createdAt   DateTime  @default(now())\n  workOrderId String\n  userId      String?\n  User        User?     @relation(fields: [userId], references: [id])\n  WorkOrder   WorkOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)\n\n  @@index([createdAt])\n  @@index([workOrderId])\n}\n\nmodel WorkOrderComment {\n  id          String             @id @default(dbgenerated("gen_random_uuid()"))\n  content     String             @db.Text\n  createdAt   DateTime           @default(now())\n  updatedAt   DateTime           @updatedAt\n  isEdited    Boolean            @default(false)\n  isDeleted   Boolean            @default(false)\n  editedAt    DateTime?\n  workOrderId String\n  userId      String\n  parentId    String?\n  workOrder   WorkOrder          @relation(fields: [workOrderId], references: [id], onDelete: Cascade)\n  user        User               @relation("UserComments", fields: [userId], references: [id], onDelete: Cascade)\n  parent      WorkOrderComment?  @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)\n  replies     WorkOrderComment[] @relation("CommentReplies")\n  mentions    CommentMention[]\n  editHistory CommentEdit[]\n\n  @@index([workOrderId])\n  @@index([userId])\n  @@index([parentId])\n  @@index([createdAt])\n  @@index([isDeleted])\n}\n\nmodel CommentEdit {\n  id        String           @id @default(dbgenerated("gen_random_uuid()"))\n  content   String           @db.Text\n  editedAt  DateTime         @default(now())\n  commentId String\n  userId    String\n  comment   WorkOrderComment @relation(fields: [commentId], references: [id], onDelete: Cascade)\n  user      User             @relation("CommentEditUser", fields: [userId], references: [id])\n\n  @@index([commentId])\n  @@index([editedAt])\n}\n\nmodel CommentMention {\n  id              String           @id @default(dbgenerated("gen_random_uuid()"))\n  commentId       String\n  mentionedUserId String\n  comment         WorkOrderComment @relation(fields: [commentId], references: [id], onDelete: Cascade)\n  mentionedUser   User             @relation("MentionedUser", fields: [mentionedUserId], references: [id], onDelete: Cascade)\n\n  @@index([commentId])\n  @@index([mentionedUserId])\n}\n\nmodel WorkOrderStatusHistory {\n  id          String          @id @default(dbgenerated("gen_random_uuid()"))\n  fromStatus  WorkOrderStatus\n  toStatus    WorkOrderStatus\n  reason      String?\n  createdAt   DateTime        @default(now())\n  workOrderId String\n  userId      String?\n  workOrder   WorkOrder       @relation(fields: [workOrderId], references: [id], onDelete: Cascade)\n  user        User?           @relation("StatusHistoryUser", fields: [userId], references: [id])\n\n  @@index([workOrderId])\n  @@index([createdAt])\n}\n\nmodel WorkOrderChecklistItem {\n  id          String    @id @default(dbgenerated("gen_random_uuid()"))\n  title       String\n  isCompleted Boolean   @default(false)\n  position    Int       @default(0)\n  workOrderId String\n  createdAt   DateTime  @default(now())\n  updatedAt   DateTime  @updatedAt\n  workOrder   WorkOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)\n\n  @@index([workOrderId])\n  @@index([position])\n}\n\nmodel WorkOrderTemplate {\n  id              String   @id @default(dbgenerated("gen_random_uuid()"))\n  name            String\n  description     String?  @db.Text\n  title           String? // Default title for work orders from this template\n  workDescription String?  @db.Text // Default description\n  priority        Priority @default(MEDIUM)\n  isGlobal        Boolean  @default(false) // System-wide templates\n  organizationId  String? // Null for global, set for org-specific\n  isActive        Boolean  @default(true)\n  usageCount      Int      @default(0) // Track how many times used\n  createdAt       DateTime @default(now())\n  updatedAt       DateTime @updatedAt\n  createdBy       String\n\n  Organization  Organization?           @relation(fields: [organizationId], references: [id], onDelete: Cascade)\n  Creator       User                    @relation("TemplateCreator", fields: [createdBy], references: [id])\n  TemplateItems WorkOrderTemplateItem[]\n\n  @@index([organizationId])\n  @@index([isGlobal])\n  @@index([isActive])\n  @@index([organizationId, isActive])\n}\n\nmodel WorkOrderTemplateItem {\n  id         String            @id @default(dbgenerated("gen_random_uuid()"))\n  title      String\n  position   Int               @default(0)\n  templateId String\n  template   WorkOrderTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)\n\n  @@index([templateId])\n  @@index([position])\n}\n\nenum AssetStatus {\n  OPERATIONAL\n  NEEDS_MAINTENANCE\n  OUT_OF_SERVICE\n}\n\nenum AssetType {\n  HVAC\n  ELECTRICAL\n  PLUMBING\n  FIRE_SAFETY\n  ELEVATOR\n  SECURITY_SYSTEM\n  OTHER\n}\n\nenum InviteStatus {\n  PENDING\n  ACCEPTED\n  EXPIRED\n  CANCELLED\n}\n\nenum Priority {\n  LOW\n  MEDIUM\n  HIGH\n  EMERGENCY\n}\n\nenum UserRole {\n  ADMIN\n  MANAGER\n  TECHNICIAN\n}\n\nenum WorkOrderStatus {\n  PENDING\n  IN_PROGRESS\n  COMPLETED\n  ON_HOLD\n  CANCELLED\n}\n'
    };
    config2.runtimeDataModel = JSON.parse('{"models":{"Asset":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"type","kind":"enum","type":"AssetType"},{"name":"status","kind":"enum","type":"AssetStatus"},{"name":"purchaseDate","kind":"scalar","type":"DateTime"},{"name":"warrantyExpiry","kind":"scalar","type":"DateTime"},{"name":"lastMaintenance","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"siteId","kind":"scalar","type":"String"},{"name":"unitId","kind":"scalar","type":"String"},{"name":"Site","kind":"object","type":"Site","relationName":"AssetToSite"},{"name":"Unit","kind":"object","type":"Unit","relationName":"AssetToUnit"},{"name":"WorkOrder","kind":"object","type":"WorkOrder","relationName":"AssetToWorkOrder"}],"dbName":null},"AuditLog":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"action","kind":"scalar","type":"String"},{"name":"details","kind":"scalar","type":"Json"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"userId","kind":"scalar","type":"String"},{"name":"User","kind":"object","type":"User","relationName":"AuditLogToUser"}],"dbName":null},"Building":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"address","kind":"scalar","type":"String"},{"name":"city","kind":"scalar","type":"String"},{"name":"state","kind":"scalar","type":"String"},{"name":"zipCode","kind":"scalar","type":"String"},{"name":"country","kind":"scalar","type":"String"},{"name":"yearBuilt","kind":"scalar","type":"Int"},{"name":"floors","kind":"scalar","type":"Int"},{"name":"squareFeet","kind":"scalar","type":"Int"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"siteId","kind":"scalar","type":"String"},{"name":"Site","kind":"object","type":"Site","relationName":"BuildingToSite"},{"name":"Unit","kind":"object","type":"Unit","relationName":"BuildingToUnit"},{"name":"WorkOrder","kind":"object","type":"WorkOrder","relationName":"BuildingToWorkOrder"}],"dbName":null},"IPBlock":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"ipAddress","kind":"scalar","type":"String"},{"name":"reason","kind":"scalar","type":"String"},{"name":"severity","kind":"scalar","type":"String"},{"name":"violationCount","kind":"scalar","type":"Int"},{"name":"blockedBy","kind":"scalar","type":"String"},{"name":"blockedAt","kind":"scalar","type":"DateTime"},{"name":"expiresAt","kind":"scalar","type":"DateTime"},{"name":"organizationId","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"User","kind":"object","type":"User","relationName":"IPBlockToUser"},{"name":"Organization","kind":"object","type":"Organization","relationName":"IPBlockToOrganization"}],"dbName":null},"Organization":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"IPBlock","kind":"object","type":"IPBlock","relationName":"IPBlockToOrganization"},{"name":"OrganizationInvite","kind":"object","type":"OrganizationInvite","relationName":"OrganizationToOrganizationInvite"},{"name":"Site","kind":"object","type":"Site","relationName":"OrganizationToSite"},{"name":"User","kind":"object","type":"User","relationName":"OrganizationToUser"},{"name":"WorkOrder","kind":"object","type":"WorkOrder","relationName":"OrganizationToWorkOrder"},{"name":"WorkOrderTemplate","kind":"object","type":"WorkOrderTemplate","relationName":"OrganizationToWorkOrderTemplate"}],"dbName":null},"OrganizationInvite":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"token","kind":"scalar","type":"String"},{"name":"status","kind":"enum","type":"InviteStatus"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"expiresAt","kind":"scalar","type":"DateTime"},{"name":"organizationId","kind":"scalar","type":"String"},{"name":"invitedByUserId","kind":"scalar","type":"String"},{"name":"User","kind":"object","type":"User","relationName":"OrganizationInviteToUser"},{"name":"Organization","kind":"object","type":"Organization","relationName":"OrganizationToOrganizationInvite"}],"dbName":null},"SecurityLog":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"ipAddress","kind":"scalar","type":"String"},{"name":"userAgent","kind":"scalar","type":"String"},{"name":"action","kind":"scalar","type":"String"},{"name":"details","kind":"scalar","type":"Json"},{"name":"severity","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"User","kind":"object","type":"User","relationName":"SecurityLogToUser"}],"dbName":null},"Session":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"token","kind":"scalar","type":"String"},{"name":"expiresAt","kind":"scalar","type":"DateTime"},{"name":"userId","kind":"scalar","type":"String"},{"name":"User","kind":"object","type":"User","relationName":"SessionToUser"}],"dbName":null},"Site":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"address","kind":"scalar","type":"String"},{"name":"city","kind":"scalar","type":"String"},{"name":"state","kind":"scalar","type":"String"},{"name":"zipCode","kind":"scalar","type":"String"},{"name":"country","kind":"scalar","type":"String"},{"name":"phoneNumber","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"organizationId","kind":"scalar","type":"String"},{"name":"Asset","kind":"object","type":"Asset","relationName":"AssetToSite"},{"name":"Building","kind":"object","type":"Building","relationName":"BuildingToSite"},{"name":"Organization","kind":"object","type":"Organization","relationName":"OrganizationToSite"},{"name":"Unit","kind":"object","type":"Unit","relationName":"SiteToUnit"},{"name":"WorkOrder","kind":"object","type":"WorkOrder","relationName":"SiteToWorkOrder"}],"dbName":null},"Unit":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"roomNumber","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"floor","kind":"scalar","type":"Int"},{"name":"squareFeet","kind":"scalar","type":"Int"},{"name":"description","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"siteId","kind":"scalar","type":"String"},{"name":"buildingId","kind":"scalar","type":"String"},{"name":"Asset","kind":"object","type":"Asset","relationName":"AssetToUnit"},{"name":"Building","kind":"object","type":"Building","relationName":"BuildingToUnit"},{"name":"Site","kind":"object","type":"Site","relationName":"SiteToUnit"},{"name":"WorkOrder","kind":"object","type":"WorkOrder","relationName":"UnitToWorkOrder"}],"dbName":null},"User":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"password","kind":"scalar","type":"String"},{"name":"recoveryPassphrase","kind":"scalar","type":"String"},{"name":"passwordResetToken","kind":"scalar","type":"String"},{"name":"passwordResetExpiresAt","kind":"scalar","type":"DateTime"},{"name":"firstName","kind":"scalar","type":"String"},{"name":"lastName","kind":"scalar","type":"String"},{"name":"phoneNumber","kind":"scalar","type":"String"},{"name":"role","kind":"enum","type":"UserRole"},{"name":"isActive","kind":"scalar","type":"Boolean"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"organizationId","kind":"scalar","type":"String"},{"name":"AuditLog","kind":"object","type":"AuditLog","relationName":"AuditLogToUser"},{"name":"IPBlock","kind":"object","type":"IPBlock","relationName":"IPBlockToUser"},{"name":"OrganizationInvite","kind":"object","type":"OrganizationInvite","relationName":"OrganizationInviteToUser"},{"name":"SecurityLog","kind":"object","type":"SecurityLog","relationName":"SecurityLogToUser"},{"name":"Session","kind":"object","type":"Session","relationName":"SessionToUser"},{"name":"Organization","kind":"object","type":"Organization","relationName":"OrganizationToUser"},{"name":"WorkOrder_WorkOrder_assignedToIdToUser","kind":"object","type":"WorkOrder","relationName":"WorkOrder_assignedToIdToUser"},{"name":"WorkOrder_WorkOrder_createdByIdToUser","kind":"object","type":"WorkOrder","relationName":"WorkOrder_createdByIdToUser"},{"name":"WorkOrderEvent","kind":"object","type":"WorkOrderEvent","relationName":"UserToWorkOrderEvent"},{"name":"WorkOrderComment","kind":"object","type":"WorkOrderComment","relationName":"UserComments"},{"name":"CommentEdit","kind":"object","type":"CommentEdit","relationName":"CommentEditUser"},{"name":"CommentMentionReceived","kind":"object","type":"CommentMention","relationName":"MentionedUser"},{"name":"WorkOrderStatusHistory","kind":"object","type":"WorkOrderStatusHistory","relationName":"StatusHistoryUser"},{"name":"WorkOrderTemplate","kind":"object","type":"WorkOrderTemplate","relationName":"TemplateCreator"}],"dbName":null},"Waitlist":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"email","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"company","kind":"scalar","type":"String"},{"name":"role","kind":"scalar","type":"String"},{"name":"phone","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"}],"dbName":null},"WorkOrder":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"title","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"priority","kind":"enum","type":"Priority"},{"name":"status","kind":"enum","type":"WorkOrderStatus"},{"name":"dueDate","kind":"scalar","type":"DateTime"},{"name":"completedAt","kind":"scalar","type":"DateTime"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"assetId","kind":"scalar","type":"String"},{"name":"unitId","kind":"scalar","type":"String"},{"name":"buildingId","kind":"scalar","type":"String"},{"name":"siteId","kind":"scalar","type":"String"},{"name":"createdById","kind":"scalar","type":"String"},{"name":"assignedToId","kind":"scalar","type":"String"},{"name":"organizationId","kind":"scalar","type":"String"},{"name":"Asset","kind":"object","type":"Asset","relationName":"AssetToWorkOrder"},{"name":"User_WorkOrder_assignedToIdToUser","kind":"object","type":"User","relationName":"WorkOrder_assignedToIdToUser"},{"name":"Building","kind":"object","type":"Building","relationName":"BuildingToWorkOrder"},{"name":"User_WorkOrder_createdByIdToUser","kind":"object","type":"User","relationName":"WorkOrder_createdByIdToUser"},{"name":"Organization","kind":"object","type":"Organization","relationName":"OrganizationToWorkOrder"},{"name":"Site","kind":"object","type":"Site","relationName":"SiteToWorkOrder"},{"name":"Unit","kind":"object","type":"Unit","relationName":"UnitToWorkOrder"},{"name":"WorkOrderEvent","kind":"object","type":"WorkOrderEvent","relationName":"WorkOrderToWorkOrderEvent"},{"name":"WorkOrderComment","kind":"object","type":"WorkOrderComment","relationName":"WorkOrderToWorkOrderComment"},{"name":"WorkOrderStatusHistory","kind":"object","type":"WorkOrderStatusHistory","relationName":"WorkOrderToWorkOrderStatusHistory"},{"name":"WorkOrderChecklistItem","kind":"object","type":"WorkOrderChecklistItem","relationName":"WorkOrderToWorkOrderChecklistItem"}],"dbName":null},"WorkOrderEvent":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"event","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"workOrderId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"User","kind":"object","type":"User","relationName":"UserToWorkOrderEvent"},{"name":"WorkOrder","kind":"object","type":"WorkOrder","relationName":"WorkOrderToWorkOrderEvent"}],"dbName":null},"WorkOrderComment":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"content","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"isEdited","kind":"scalar","type":"Boolean"},{"name":"isDeleted","kind":"scalar","type":"Boolean"},{"name":"editedAt","kind":"scalar","type":"DateTime"},{"name":"workOrderId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"parentId","kind":"scalar","type":"String"},{"name":"workOrder","kind":"object","type":"WorkOrder","relationName":"WorkOrderToWorkOrderComment"},{"name":"user","kind":"object","type":"User","relationName":"UserComments"},{"name":"parent","kind":"object","type":"WorkOrderComment","relationName":"CommentReplies"},{"name":"replies","kind":"object","type":"WorkOrderComment","relationName":"CommentReplies"},{"name":"mentions","kind":"object","type":"CommentMention","relationName":"CommentMentionToWorkOrderComment"},{"name":"editHistory","kind":"object","type":"CommentEdit","relationName":"CommentEditToWorkOrderComment"}],"dbName":null},"CommentEdit":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"content","kind":"scalar","type":"String"},{"name":"editedAt","kind":"scalar","type":"DateTime"},{"name":"commentId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"comment","kind":"object","type":"WorkOrderComment","relationName":"CommentEditToWorkOrderComment"},{"name":"user","kind":"object","type":"User","relationName":"CommentEditUser"}],"dbName":null},"CommentMention":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"commentId","kind":"scalar","type":"String"},{"name":"mentionedUserId","kind":"scalar","type":"String"},{"name":"comment","kind":"object","type":"WorkOrderComment","relationName":"CommentMentionToWorkOrderComment"},{"name":"mentionedUser","kind":"object","type":"User","relationName":"MentionedUser"}],"dbName":null},"WorkOrderStatusHistory":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"fromStatus","kind":"enum","type":"WorkOrderStatus"},{"name":"toStatus","kind":"enum","type":"WorkOrderStatus"},{"name":"reason","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"workOrderId","kind":"scalar","type":"String"},{"name":"userId","kind":"scalar","type":"String"},{"name":"workOrder","kind":"object","type":"WorkOrder","relationName":"WorkOrderToWorkOrderStatusHistory"},{"name":"user","kind":"object","type":"User","relationName":"StatusHistoryUser"}],"dbName":null},"WorkOrderChecklistItem":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"title","kind":"scalar","type":"String"},{"name":"isCompleted","kind":"scalar","type":"Boolean"},{"name":"position","kind":"scalar","type":"Int"},{"name":"workOrderId","kind":"scalar","type":"String"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"workOrder","kind":"object","type":"WorkOrder","relationName":"WorkOrderToWorkOrderChecklistItem"}],"dbName":null},"WorkOrderTemplate":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"name","kind":"scalar","type":"String"},{"name":"description","kind":"scalar","type":"String"},{"name":"title","kind":"scalar","type":"String"},{"name":"workDescription","kind":"scalar","type":"String"},{"name":"priority","kind":"enum","type":"Priority"},{"name":"isGlobal","kind":"scalar","type":"Boolean"},{"name":"organizationId","kind":"scalar","type":"String"},{"name":"isActive","kind":"scalar","type":"Boolean"},{"name":"usageCount","kind":"scalar","type":"Int"},{"name":"createdAt","kind":"scalar","type":"DateTime"},{"name":"updatedAt","kind":"scalar","type":"DateTime"},{"name":"createdBy","kind":"scalar","type":"String"},{"name":"Organization","kind":"object","type":"Organization","relationName":"OrganizationToWorkOrderTemplate"},{"name":"Creator","kind":"object","type":"User","relationName":"TemplateCreator"},{"name":"TemplateItems","kind":"object","type":"WorkOrderTemplateItem","relationName":"WorkOrderTemplateToWorkOrderTemplateItem"}],"dbName":null},"WorkOrderTemplateItem":{"fields":[{"name":"id","kind":"scalar","type":"String"},{"name":"title","kind":"scalar","type":"String"},{"name":"position","kind":"scalar","type":"Int"},{"name":"templateId","kind":"scalar","type":"String"},{"name":"template","kind":"object","type":"WorkOrderTemplate","relationName":"WorkOrderTemplateToWorkOrderTemplateItem"}],"dbName":null}},"enums":{},"types":{}}');
    defineDmmfProperty2(exports.Prisma, config2.runtimeDataModel);
    config2.compilerWasm = {
      getRuntime: async () => require_query_compiler_bg(),
      getQueryCompilerWasmModule: async () => {
        const loader = (await Promise.resolve().then(() => (init_wasm_worker_loader(), wasm_worker_loader_exports))).default;
        const compiler = (await loader).default;
        return compiler;
      }
    };
    if (typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0) {
      Debug2.enable(typeof globalThis !== "undefined" && globalThis["DEBUG"] || typeof process !== "undefined" && process.env && process.env.DEBUG || void 0);
    }
    var PrismaClient = getPrismaClient2(config2);
    exports.PrismaClient = PrismaClient;
    Object.assign(exports, Prisma);
  }
});

// node_modules/@prisma/client/edge.js
var require_edge2 = __commonJS({
  "node_modules/@prisma/client/edge.js"(exports, module) {
    module.exports = {
      // https://github.com/prisma/prisma/pull/12907
      ...require_edge()
    };
  }
});

// node_modules/.prisma/client/default.js
var require_default = __commonJS({
  "node_modules/.prisma/client/default.js"(exports, module) {
    module.exports = { ...require_edge() };
  }
});

// node_modules/@prisma/client/default.js
var require_default2 = __commonJS({
  "node_modules/@prisma/client/default.js"(exports, module) {
    module.exports = {
      ...require_default()
    };
  }
});

// .svelte-kit/output/server/chunks/prisma.js
function isCloudflareWorker() {
  const g = globalThis;
  if (g.process?.env?.CF_PAGES || g.CF_PAGES) {
    return true;
  }
  return !g.process?.versions?.node && typeof g.fetch === "function" && !g.Buffer;
}
function initEnvFromEvent(event) {
  if (event.platform?.env) {
    cachedEnvVars = event.platform.env;
  }
}
function getEnvVar(key2) {
  const g = globalThis;
  if (cachedEnvVars && cachedEnvVars[key2]) {
    return cachedEnvVars[key2];
  }
  if (g[key2]) {
    return g[key2];
  }
  if (g.platform?.env?.[key2]) {
    return g.platform.env[key2];
  }
  return g.process?.env?.[key2];
}
async function createBasePrismaClient() {
  const databaseUrl = getEnvVar("DATABASE_URL");
  const accelerateUrl = getEnvVar("ACCELERATE_URL");
  const directUrl = getEnvVar("DIRECT_URL");
  const effectiveUrl = accelerateUrl || databaseUrl || directUrl;
  if (!effectiveUrl) {
    if (typeof globalThis !== "undefined" && globalThis.__SVELTEKIT__) {
      console.warn("Prisma client not available during build/SSR generation");
      return null;
    }
    throw new Error("DATABASE_URL, ACCELERATE_URL, or DIRECT_URL environment variable is required");
  }
  const nodeEnv = getEnvVar("NODE_ENV") || "development";
  const logLevel = nodeEnv === "development" ? ["query", "info", "warn", "error"] : ["warn", "error"];
  const { withAccelerate: withAccelerate2 } = await Promise.resolve().then(() => (init_entry_fetch(), entry_fetch_exports));
  if (isCloudflareWorker()) {
    const { PrismaClient: EdgePrismaClient } = await Promise.resolve().then(() => __toESM(require_edge2(), 1));
    const client = new EdgePrismaClient({
      log: logLevel,
      accelerateUrl: effectiveUrl
    });
    return client.$extends(withAccelerate2());
  } else {
    const { PrismaClient: NodePrismaClient } = await Promise.resolve().then(() => __toESM(require_default2(), 1));
    const client = new NodePrismaClient({
      // @ts-ignore - types might conflict but datasources is supported for Node client
      datasources: {
        db: {
          url: effectiveUrl
        }
      },
      log: logLevel
    });
    return client.$extends(withAccelerate2());
  }
}
async function getPrismaSingleton() {
  if (globalForPrisma.prisma) {
    return globalForPrisma.prisma;
  }
  if (!globalForPrisma.prismaPromise) {
    globalForPrisma.prismaPromise = createBasePrismaClient();
  }
  const client = await globalForPrisma.prismaPromise;
  if (!client) {
    throw new Error("Prisma client not available. This may occur during build/SSR generation.");
  }
  if (!globalForPrisma.prisma) {
    globalForPrisma.prisma = client;
  }
  return client;
}
async function createPrismaClient(organizationId) {
  const baseClient = await getPrismaSingleton();
  if (!organizationId) {
    return baseClient;
  }
  return baseClient.$extends({
    query: {
      $allModels: {
        async findMany({ model, args, query }) {
          if (orgModels.includes(model)) {
            args.where = { ...args.where, organizationId };
          }
          return query(args);
        },
        async findFirst({ model, args, query }) {
          if (orgModels.includes(model)) {
            args.where = { ...args.where, organizationId };
          }
          return query(args);
        },
        async findUnique({ model, args, query }) {
          const result = await query(args);
          if (result && orgModels.includes(model) && result.organizationId !== organizationId) {
            return null;
          }
          return result;
        },
        async update({ model, args, query }) {
          if (orgModels.includes(model)) {
            args.where = { ...args.where, organizationId };
          }
          return query(args);
        },
        async delete({ model, args, query }) {
          if (orgModels.includes(model)) {
            args.where = { ...args.where, organizationId };
          }
          return query(args);
        },
        async create({ model, args, query }) {
          if (orgModels.includes(model)) {
            args.data = { ...args.data, organizationId };
          }
          return query(args);
        }
      }
    }
  });
}
async function createRequestPrisma(event) {
  const organizationId = event.locals.user?.organizationId ?? void 0;
  if (isCloudflareWorker() && event.platform?.env) {
    return createPrismaClient(organizationId);
  }
  return createPrismaClient(organizationId);
}
async function getPrisma() {
  return getPrismaSingleton();
}
var cachedEnvVars, globalForPrisma, orgModels;
var init_prisma = __esm({
  ".svelte-kit/output/server/chunks/prisma.js"() {
    globalForPrisma = globalThis;
    orgModels = ["WorkOrder", "User", "Site"];
  }
});

// .svelte-kit/output/server/chunks/environment.js
var dev;
var init_environment = __esm({
  ".svelte-kit/output/server/chunks/environment.js"() {
    init_true();
    dev = DEV;
  }
});

// .svelte-kit/output/server/chunks/auth.js
async function hashPassword(password) {
  return bcryptjs_default.hash(password, 12);
}
async function verifyPassword(password, hash4) {
  return bcryptjs_default.compare(password, hash4);
}
async function createSession(userId) {
  try {
    const expiresAt = /* @__PURE__ */ new Date();
    expiresAt.setDate(expiresAt.getDate() + SESSION_EXPIRY_DAYS);
    const client = await getPrisma();
    const session = await client.session.create({
      data: {
        userId,
        expiresAt,
        token: crypto.randomUUID()
      }
    });
    return session.id;
  } catch (error47) {
    console.error("Failed to create session:", error47);
    throw new Error("Failed to create session");
  }
}
async function validateSessionWithOrg(cookies) {
  const sessionId = cookies.get(SESSION_COOKIE);
  if (!sessionId) {
    return { user: null, state: "unauthenticated" };
  }
  const client = await getPrisma();
  const session = await client.session.findUnique({
    where: { id: sessionId },
    include: {
      User: {
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
          organizationId: true,
          Organization: {
            select: {
              id: true,
              name: true
            }
          }
        }
      }
    }
  });
  if (!session) {
    return { user: null, state: "unauthenticated" };
  }
  if (session.expiresAt < /* @__PURE__ */ new Date()) {
    await client.session.delete({ where: { id: sessionId } });
    return { user: null, state: "unauthenticated" };
  }
  const user = session.User;
  if (!user.organizationId) {
    return { user, state: "lobby" };
  }
  const userOrgs = await client.organization.findMany({
    where: {
      User: {
        some: {
          id: user.id
        }
      }
    },
    select: {
      id: true,
      name: true
    }
  });
  return {
    user,
    state: "org_member",
    organizations: userOrgs,
    currentOrganization: user.Organization
  };
}
function setSessionCookie(cookies, sessionId) {
  cookies.set(SESSION_COOKIE, sessionId, {
    path: "/",
    httpOnly: true,
    sameSite: "strict",
    // Upgrade from 'lax' for better security
    secure: !dev,
    // Always secure in production (Cloudflare Pages enforces HTTPS)
    maxAge: 60 * 60 * 24 * SESSION_EXPIRY_DAYS
  });
}
function canManageUsers(role) {
  return role === "ADMIN";
}
async function validateResetToken(token) {
  const client = await getPrisma();
  const user = await client.user.findFirst({
    where: {
      passwordResetToken: token,
      passwordResetExpiresAt: {
        gt: /* @__PURE__ */ new Date()
      }
    },
    select: {
      id: true,
      email: true
    }
  });
  return user;
}
async function resetPassword(token, newPassword) {
  const client = await getPrisma();
  const user = await validateResetToken(token);
  if (!user) {
    throw new Error("Invalid or expired reset token");
  }
  const hashedPassword = await hashPassword(newPassword);
  await client.user.update({
    where: { id: user.id },
    data: {
      password: hashedPassword,
      passwordResetToken: null,
      passwordResetExpiresAt: null
    }
  });
  return user;
}
var SESSION_COOKIE, SESSION_EXPIRY_DAYS;
var init_auth = __esm({
  ".svelte-kit/output/server/chunks/auth.js"() {
    init_bcryptjs();
    init_prisma();
    init_environment();
    SESSION_COOKIE = "spore_session";
    SESSION_EXPIRY_DAYS = 30;
  }
});

// .svelte-kit/output/server/chunks/hooks.server.js
var hooks_server_exports = {};
__export(hooks_server_exports, {
  handle: () => handle,
  handleError: () => handleError
});
var publicRoutes, orgRoutes, lobbyRoutes, handle, handleError;
var init_hooks_server = __esm({
  ".svelte-kit/output/server/chunks/hooks.server.js"() {
    init_chunks();
    init_auth();
    init_internal();
    init_prisma();
    publicRoutes = ["/auth/login", "/auth/register", "/auth/forgot-password", "/auth/reset-password", "/", "/favicon.ico", "/favicon.png"];
    orgRoutes = ["/dashboard", "/work-orders", "/sites", "/assets", "/users", "/audit-log"];
    lobbyRoutes = ["/onboarding", "/join-organization"];
    handle = async ({ event, resolve: resolve2 }) => {
      initEnvFromEvent(event);
      if (building) {
        return resolve2(event);
      }
      if (event.url.pathname === "/favicon.ico" || event.url.pathname === "/favicon.png") {
        return resolve2(event);
      }
      try {
        console.log("[Auth] Checking cookies:", event.cookies.get("spore_session") ? "Found" : "Missing");
        const authResult = await validateSessionWithOrg(event.cookies);
        console.log("[Auth] Result:", authResult.state, authResult.user?.email);
        event.locals.user = authResult.user;
        event.locals.authState = authResult.state;
        event.locals.organizations = authResult.organizations || [];
        event.locals.currentOrganization = authResult.currentOrganization || null;
      } catch (err) {
        console.error("Auth validation error:", err);
        event.locals.user = null;
        event.locals.authState = "unauthenticated";
        event.locals.organizations = [];
        event.locals.currentOrganization = null;
        event.locals.authError = true;
      }
      const isPublicRoute = publicRoutes.some((route) => event.url.pathname.startsWith(route));
      const isOrgRoute = orgRoutes.some((route) => event.url.pathname.startsWith(route));
      const isLobbyRoute = lobbyRoutes.some((route) => event.url.pathname.startsWith(route));
      if (event.locals.authState === "unauthenticated" && !isPublicRoute) {
        throw redirect(303, "/auth/login");
      }
      if (event.locals.user && event.url.pathname.startsWith("/auth/")) {
        if (event.locals.authState === "lobby") {
          throw redirect(303, "/onboarding");
        }
        throw redirect(303, "/dashboard");
      }
      if (event.locals.authState === "lobby" && !isLobbyRoute && !isPublicRoute) {
        throw redirect(303, "/onboarding");
      }
      if (event.locals.authState === "org_member" && isLobbyRoute) {
        throw redirect(303, "/dashboard");
      }
      if (event.locals.authState === "org_member" && isOrgRoute) {
        if (!event.locals.currentOrganization) {
          throw redirect(303, "/select-organization");
        }
      }
      const response = await resolve2(event);
      if (event.platform?.env?.NODE_ENV === "production" || event.url.hostname.includes("pages.dev")) {
        response.headers.set("X-Frame-Options", "DENY");
        response.headers.set("X-Content-Type-Options", "nosniff");
        response.headers.set("Referrer-Policy", "strict-origin-when-cross-origin");
        response.headers.set("Permissions-Policy", "camera=(), microphone=(), geolocation=(), payment=()");
        response.headers.set("Strict-Transport-Security", "max-age=31536000; includeSubDomains; preload");
        const csp = [
          "default-src 'self'",
          "script-src 'self' 'unsafe-eval' 'unsafe-inline' https://static.cloudflareinsights.com",
          // unsafe-inline needed for use:enhance form handling
          "style-src 'self' 'unsafe-inline'",
          // unsafe-inline needed for Svelte styling
          "img-src 'self' data: https:",
          "font-src 'self'",
          "connect-src 'self' https://*.prisma-data.net https://cloudflareinsights.com",
          // Allow Prisma Accelerate and Cloudflare Analytics
          "frame-ancestors 'none'",
          "base-uri 'self'",
          "form-action 'self'"
        ].join("; ");
        response.headers.set("Content-Security-Policy", csp);
      }
      return response;
    };
    handleError = async ({ error: err, event }) => {
      const isProduction = event.platform?.env?.NODE_ENV === "production" || event.url.hostname.includes("pages.dev");
      if (isProduction) {
        const statusCode = err instanceof Error && "status" in err ? err.status : 500;
        const message = statusCode === 500 ? "Something went wrong" : err.message;
        return {
          message,
          code: "INTERNAL_ERROR"
        };
      }
    };
  }
});

// .svelte-kit/output/server/chunks/internal.js
function reset() {
  base = initial.base;
  assets = initial.assets;
}
function set_private_env(environment) {
}
function set_public_env(environment) {
  public_env = environment;
}
function afterUpdate() {
}
function get_hooks() {
  return Promise.resolve().then(() => (init_hooks_server(), hooks_server_exports));
}
var base, assets, initial, public_env, fix_stack_trace, building, Root, options;
var init_internal = __esm({
  ".svelte-kit/output/server/chunks/internal.js"() {
    init_ssr();
    base = "";
    assets = base;
    initial = { base, assets };
    public_env = {};
    fix_stack_trace = (error47) => error47?.stack;
    building = false;
    Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { stores } = $$props;
      let { page: page2 } = $$props;
      let { constructors } = $$props;
      let { components = [] } = $$props;
      let { form } = $$props;
      let { data_0 = null } = $$props;
      let { data_1 = null } = $$props;
      {
        setContext("__svelte__", stores);
      }
      afterUpdate(stores.page.notify);
      if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
        $$bindings.stores(stores);
      if ($$props.page === void 0 && $$bindings.page && page2 !== void 0)
        $$bindings.page(page2);
      if ($$props.constructors === void 0 && $$bindings.constructors && constructors !== void 0)
        $$bindings.constructors(constructors);
      if ($$props.components === void 0 && $$bindings.components && components !== void 0)
        $$bindings.components(components);
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      if ($$props.data_0 === void 0 && $$bindings.data_0 && data_0 !== void 0)
        $$bindings.data_0(data_0);
      if ($$props.data_1 === void 0 && $$bindings.data_1 && data_1 !== void 0)
        $$bindings.data_1(data_1);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        {
          stores.page.set(page2);
        }
        $$rendered = `  ${constructors[1] ? `${validate_component(constructors[0] || missing_component, "svelte:component").$$render(
          $$result,
          { data: data_0, this: components[0] },
          {
            this: ($$value) => {
              components[0] = $$value;
              $$settled = false;
            }
          },
          {
            default: () => {
              return `${validate_component(constructors[1] || missing_component, "svelte:component").$$render(
                $$result,
                { data: data_1, form, this: components[1] },
                {
                  this: ($$value) => {
                    components[1] = $$value;
                    $$settled = false;
                  }
                },
                {}
              )}`;
            }
          }
        )}` : `${validate_component(constructors[0] || missing_component, "svelte:component").$$render(
          $$result,
          { data: data_0, form, this: components[0] },
          {
            this: ($$value) => {
              components[0] = $$value;
              $$settled = false;
            }
          },
          {}
        )}`} ${``}`;
      } while (!$$settled);
      return $$rendered;
    });
    options = {
      app_template_contains_nonce: false,
      csp: { "mode": "auto", "directives": { "upgrade-insecure-requests": false, "block-all-mixed-content": false }, "reportOnly": { "upgrade-insecure-requests": false, "block-all-mixed-content": false } },
      csrf_check_origin: true,
      track_server_fetches: false,
      embedded: false,
      env_public_prefix: "PUBLIC_",
      env_private_prefix: "",
      hooks: null,
      // added lazily, via `get_hooks`
      preload_strategy: "modulepreload",
      root: Root,
      service_worker: false,
      templates: {
        app: ({ head, body, assets: assets2, nonce, env }) => '<!DOCTYPE html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<link rel="icon" href="' + assets2 + '/favicon.png" />\n		<meta name="viewport" content="width=device-width, initial-scale=1.0" />\n		<!-- CSP will be handled by Cloudflare Pages headers -->\n		' + head + '\n	</head>\n	<body data-sveltekit-preload-data="hover">\n		<div style="display: contents">' + body + "</div>\n	</body>\n</html>",
        error: ({ status, message }) => '<!doctype html>\n<html lang="en">\n	<head>\n		<meta charset="utf-8" />\n		<title>' + message + `</title>

		<style>
			body {
				--bg: white;
				--fg: #222;
				--divider: #ccc;
				background: var(--bg);
				color: var(--fg);
				font-family:
					system-ui,
					-apple-system,
					BlinkMacSystemFont,
					'Segoe UI',
					Roboto,
					Oxygen,
					Ubuntu,
					Cantarell,
					'Open Sans',
					'Helvetica Neue',
					sans-serif;
				display: flex;
				align-items: center;
				justify-content: center;
				height: 100vh;
				margin: 0;
			}

			.error {
				display: flex;
				align-items: center;
				max-width: 32rem;
				margin: 0 1rem;
			}

			.status {
				font-weight: 200;
				font-size: 3rem;
				line-height: 1;
				position: relative;
				top: -0.05rem;
			}

			.message {
				border-left: 1px solid var(--divider);
				padding: 0 0 0 1rem;
				margin: 0 0 0 1rem;
				min-height: 2.5rem;
				display: flex;
				align-items: center;
			}

			.message h1 {
				font-weight: 400;
				font-size: 1em;
				margin: 0;
			}

			@media (prefers-color-scheme: dark) {
				body {
					--bg: #222;
					--fg: #ddd;
					--divider: #666;
				}
			}
		</style>
	</head>
	<body>
		<div class="error">
			<span class="status">` + status + '</span>\n			<div class="message">\n				<h1>' + message + "</h1>\n			</div>\n		</div>\n	</body>\n</html>\n"
      },
      version_hash: "wmz03a"
    };
  }
});

// node_modules/devalue/src/utils.js
function is_primitive(thing) {
  return Object(thing) !== thing;
}
function is_plain_object(thing) {
  const proto = Object.getPrototypeOf(thing);
  return proto === Object.prototype || proto === null || Object.getOwnPropertyNames(proto).sort().join("\0") === object_proto_names;
}
function get_type(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function get_escaped_char(char) {
  switch (char) {
    case '"':
      return '\\"';
    case "<":
      return "\\u003C";
    case "\\":
      return "\\\\";
    case "\n":
      return "\\n";
    case "\r":
      return "\\r";
    case "	":
      return "\\t";
    case "\b":
      return "\\b";
    case "\f":
      return "\\f";
    case "\u2028":
      return "\\u2028";
    case "\u2029":
      return "\\u2029";
    default:
      return char < " " ? `\\u${char.charCodeAt(0).toString(16).padStart(4, "0")}` : "";
  }
}
function stringify_string(str) {
  let result = "";
  let last_pos = 0;
  const len = str.length;
  for (let i = 0; i < len; i += 1) {
    const char = str[i];
    const replacement = get_escaped_char(char);
    if (replacement) {
      result += str.slice(last_pos, i) + replacement;
      last_pos = i + 1;
    }
  }
  return `"${last_pos === 0 ? str : result + str.slice(last_pos)}"`;
}
var escaped, DevalueError, object_proto_names;
var init_utils = __esm({
  "node_modules/devalue/src/utils.js"() {
    escaped = {
      "<": "\\u003C",
      "\\": "\\\\",
      "\b": "\\b",
      "\f": "\\f",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "\u2028": "\\u2028",
      "\u2029": "\\u2029"
    };
    DevalueError = class extends Error {
      /**
       * @param {string} message
       * @param {string[]} keys
       */
      constructor(message, keys) {
        super(message);
        this.name = "DevalueError";
        this.path = keys.join("");
      }
    };
    object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(
      Object.prototype
    ).sort().join("\0");
  }
});

// node_modules/devalue/src/uneval.js
function uneval(value, replacer) {
  const counts = /* @__PURE__ */ new Map();
  const keys = [];
  const custom2 = /* @__PURE__ */ new Map();
  function walk(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (!is_primitive(thing)) {
      if (counts.has(thing)) {
        counts.set(thing, counts.get(thing) + 1);
        return;
      }
      counts.set(thing, 1);
      if (replacer) {
        const str2 = replacer(thing);
        if (typeof str2 === "string") {
          custom2.set(thing, str2);
          return;
        }
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "BigInt":
        case "String":
        case "Boolean":
        case "Date":
        case "RegExp":
          return;
        case "Array":
          thing.forEach((value2, i) => {
            keys.push(`[${i}]`);
            walk(value2);
            keys.pop();
          });
          break;
        case "Set":
          Array.from(thing).forEach(walk);
          break;
        case "Map":
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive(key2) : "..."})`
            );
            walk(value2);
            keys.pop();
          }
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          for (const key2 in thing) {
            keys.push(`.${key2}`);
            walk(thing[key2]);
            keys.pop();
          }
      }
    }
  }
  walk(value);
  const names = /* @__PURE__ */ new Map();
  Array.from(counts).filter((entry) => entry[1] > 1).sort((a, b) => b[1] - a[1]).forEach((entry, i) => {
    names.set(entry[0], get_name(i));
  });
  function stringify2(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (is_primitive(thing)) {
      return stringify_primitive(thing);
    }
    if (custom2.has(thing)) {
      return custom2.get(thing);
    }
    const type = get_type(thing);
    switch (type) {
      case "Number":
      case "String":
      case "Boolean":
        return `Object(${stringify2(thing.valueOf())})`;
      case "RegExp":
        return `new RegExp(${stringify_string(thing.source)}, "${thing.flags}")`;
      case "Date":
        return `new Date(${thing.getTime()})`;
      case "Array":
        const members = (
          /** @type {any[]} */
          thing.map(
            (v, i) => i in thing ? stringify2(v) : ""
          )
        );
        const tail = thing.length === 0 || thing.length - 1 in thing ? "" : ",";
        return `[${members.join(",")}${tail}]`;
      case "Set":
      case "Map":
        return `new ${type}([${Array.from(thing).map(stringify2).join(",")}])`;
      default:
        const obj = `{${Object.keys(thing).map((key2) => `${safe_key(key2)}:${stringify2(thing[key2])}`).join(",")}}`;
        const proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? `Object.assign(Object.create(null),${obj})` : `Object.create(null)`;
        }
        return obj;
    }
  }
  const str = stringify2(value);
  if (names.size) {
    const params = [];
    const statements = [];
    const values = [];
    names.forEach((name, thing) => {
      params.push(name);
      if (custom2.has(thing)) {
        values.push(
          /** @type {string} */
          custom2.get(thing)
        );
        return;
      }
      if (is_primitive(thing)) {
        values.push(stringify_primitive(thing));
        return;
      }
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          values.push(`Object(${stringify2(thing.valueOf())})`);
          break;
        case "RegExp":
          values.push(thing.toString());
          break;
        case "Date":
          values.push(`new Date(${thing.getTime()})`);
          break;
        case "Array":
          values.push(`Array(${thing.length})`);
          thing.forEach((v, i) => {
            statements.push(`${name}[${i}]=${stringify2(v)}`);
          });
          break;
        case "Set":
          values.push(`new Set`);
          statements.push(
            `${name}.${Array.from(thing).map((v) => `add(${stringify2(v)})`).join(".")}`
          );
          break;
        case "Map":
          values.push(`new Map`);
          statements.push(
            `${name}.${Array.from(thing).map(([k, v]) => `set(${stringify2(k)}, ${stringify2(v)})`).join(".")}`
          );
          break;
        default:
          values.push(
            Object.getPrototypeOf(thing) === null ? "Object.create(null)" : "{}"
          );
          Object.keys(thing).forEach((key2) => {
            statements.push(
              `${name}${safe_prop(key2)}=${stringify2(thing[key2])}`
            );
          });
      }
    });
    statements.push(`return ${str}`);
    return `(function(${params.join(",")}){${statements.join(
      ";"
    )}}(${values.join(",")}))`;
  } else {
    return str;
  }
}
function get_name(num) {
  let name = "";
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? `${name}0` : name;
}
function escape_unsafe_char(c2) {
  return escaped[c2] || c2;
}
function escape_unsafe_chars(str) {
  return str.replace(unsafe_chars, escape_unsafe_char);
}
function safe_key(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? key2 : escape_unsafe_chars(JSON.stringify(key2));
}
function safe_prop(key2) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key2) ? `.${key2}` : `[${escape_unsafe_chars(JSON.stringify(key2))}]`;
}
function stringify_primitive(thing) {
  if (typeof thing === "string")
    return stringify_string(thing);
  if (thing === void 0)
    return "void 0";
  if (thing === 0 && 1 / thing < 0)
    return "-0";
  const str = String(thing);
  if (typeof thing === "number")
    return str.replace(/^(-)?0\./, "$1.");
  if (typeof thing === "bigint")
    return thing + "n";
  return str;
}
var chars, unsafe_chars, reserved;
var init_uneval = __esm({
  "node_modules/devalue/src/uneval.js"() {
    init_utils();
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$";
    unsafe_chars = /[<\b\f\n\r\t\0\u2028\u2029]/g;
    reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
  }
});

// node_modules/devalue/src/constants.js
var UNDEFINED, HOLE, NAN, POSITIVE_INFINITY, NEGATIVE_INFINITY, NEGATIVE_ZERO;
var init_constants = __esm({
  "node_modules/devalue/src/constants.js"() {
    UNDEFINED = -1;
    HOLE = -2;
    NAN = -3;
    POSITIVE_INFINITY = -4;
    NEGATIVE_INFINITY = -5;
    NEGATIVE_ZERO = -6;
  }
});

// node_modules/devalue/src/parse.js
var init_parse = __esm({
  "node_modules/devalue/src/parse.js"() {
    init_constants();
  }
});

// node_modules/devalue/src/stringify.js
function stringify(value, reducers) {
  const stringified = [];
  const indexes = /* @__PURE__ */ new Map();
  const custom2 = [];
  for (const key2 in reducers) {
    custom2.push({ key: key2, fn: reducers[key2] });
  }
  const keys = [];
  let p = 0;
  function flatten(thing) {
    if (typeof thing === "function") {
      throw new DevalueError(`Cannot stringify a function`, keys);
    }
    if (indexes.has(thing))
      return indexes.get(thing);
    if (thing === void 0)
      return UNDEFINED;
    if (Number.isNaN(thing))
      return NAN;
    if (thing === Infinity)
      return POSITIVE_INFINITY;
    if (thing === -Infinity)
      return NEGATIVE_INFINITY;
    if (thing === 0 && 1 / thing < 0)
      return NEGATIVE_ZERO;
    const index25 = p++;
    indexes.set(thing, index25);
    for (const { key: key2, fn } of custom2) {
      const value2 = fn(thing);
      if (value2) {
        stringified[index25] = `["${key2}",${flatten(value2)}]`;
        return index25;
      }
    }
    let str = "";
    if (is_primitive(thing)) {
      str = stringify_primitive2(thing);
    } else {
      const type = get_type(thing);
      switch (type) {
        case "Number":
        case "String":
        case "Boolean":
          str = `["Object",${stringify_primitive2(thing)}]`;
          break;
        case "BigInt":
          str = `["BigInt",${thing}]`;
          break;
        case "Date":
          const valid = !isNaN(thing.getDate());
          str = `["Date","${valid ? thing.toISOString() : ""}"]`;
          break;
        case "RegExp":
          const { source, flags } = thing;
          str = flags ? `["RegExp",${stringify_string(source)},"${flags}"]` : `["RegExp",${stringify_string(source)}]`;
          break;
        case "Array":
          str = "[";
          for (let i = 0; i < thing.length; i += 1) {
            if (i > 0)
              str += ",";
            if (i in thing) {
              keys.push(`[${i}]`);
              str += flatten(thing[i]);
              keys.pop();
            } else {
              str += HOLE;
            }
          }
          str += "]";
          break;
        case "Set":
          str = '["Set"';
          for (const value2 of thing) {
            str += `,${flatten(value2)}`;
          }
          str += "]";
          break;
        case "Map":
          str = '["Map"';
          for (const [key2, value2] of thing) {
            keys.push(
              `.get(${is_primitive(key2) ? stringify_primitive2(key2) : "..."})`
            );
            str += `,${flatten(key2)},${flatten(value2)}`;
            keys.pop();
          }
          str += "]";
          break;
        default:
          if (!is_plain_object(thing)) {
            throw new DevalueError(
              `Cannot stringify arbitrary non-POJOs`,
              keys
            );
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new DevalueError(
              `Cannot stringify POJOs with symbolic keys`,
              keys
            );
          }
          if (Object.getPrototypeOf(thing) === null) {
            str = '["null"';
            for (const key2 in thing) {
              keys.push(`.${key2}`);
              str += `,${stringify_string(key2)},${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "]";
          } else {
            str = "{";
            let started = false;
            for (const key2 in thing) {
              if (started)
                str += ",";
              started = true;
              keys.push(`.${key2}`);
              str += `${stringify_string(key2)}:${flatten(thing[key2])}`;
              keys.pop();
            }
            str += "}";
          }
      }
    }
    stringified[index25] = str;
    return index25;
  }
  const index24 = flatten(value);
  if (index24 < 0)
    return `${index24}`;
  return `[${stringified.join(",")}]`;
}
function stringify_primitive2(thing) {
  const type = typeof thing;
  if (type === "string")
    return stringify_string(thing);
  if (thing instanceof String)
    return stringify_string(thing.toString());
  if (thing === void 0)
    return UNDEFINED.toString();
  if (thing === 0 && 1 / thing < 0)
    return NEGATIVE_ZERO.toString();
  if (type === "bigint")
    return `["BigInt","${thing}"]`;
  return String(thing);
}
var init_stringify = __esm({
  "node_modules/devalue/src/stringify.js"() {
    init_utils();
    init_constants();
  }
});

// node_modules/devalue/index.js
var init_devalue = __esm({
  "node_modules/devalue/index.js"() {
    init_uneval();
    init_parse();
    init_stringify();
  }
});

// .svelte-kit/output/server/chunks/index2.js
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update(fn) {
    set2(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update, subscribe: subscribe2 };
}
var subscriber_queue;
var init_index2 = __esm({
  ".svelte-kit/output/server/chunks/index2.js"() {
    init_ssr();
    subscriber_queue = [];
  }
});

// node_modules/cookie/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/cookie/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = parse5;
    exports.serialize = serialize2;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C = function() {
      };
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parse5(str, options2) {
      const obj = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj;
      const dec = options2?.decode || decode3;
      let index24 = 0;
      do {
        const eqIdx = str.indexOf("=", index24);
        if (eqIdx === -1)
          break;
        const colonIdx = str.indexOf(";", index24);
        const endIdx = colonIdx === -1 ? len : colonIdx;
        if (eqIdx > endIdx) {
          index24 = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const keyStartIdx = startIndex(str, index24, eqIdx);
        const keyEndIdx = endIndex(str, eqIdx, keyStartIdx);
        const key2 = str.slice(keyStartIdx, keyEndIdx);
        if (obj[key2] === void 0) {
          let valStartIdx = startIndex(str, eqIdx + 1, endIdx);
          let valEndIdx = endIndex(str, endIdx, valStartIdx);
          const value = dec(str.slice(valStartIdx, valEndIdx));
          obj[key2] = value;
        }
        index24 = endIdx + 1;
      } while (index24 < len);
      return obj;
    }
    function startIndex(str, index24, max) {
      do {
        const code = str.charCodeAt(index24);
        if (code !== 32 && code !== 9)
          return index24;
      } while (++index24 < max);
      return max;
    }
    function endIndex(str, index24, min) {
      while (index24 > min) {
        const code = str.charCodeAt(--index24);
        if (code !== 32 && code !== 9)
          return index24 + 1;
      }
      return min;
    }
    function serialize2(name, val, options2) {
      const enc = options2?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(name)) {
        throw new TypeError(`argument name is invalid: ${name}`);
      }
      const value = enc(val);
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${val}`);
      }
      let str = name + "=" + value;
      if (!options2)
        return str;
      if (options2.maxAge !== void 0) {
        if (!Number.isInteger(options2.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${options2.maxAge}`);
        }
        str += "; Max-Age=" + options2.maxAge;
      }
      if (options2.domain) {
        if (!domainValueRegExp.test(options2.domain)) {
          throw new TypeError(`option domain is invalid: ${options2.domain}`);
        }
        str += "; Domain=" + options2.domain;
      }
      if (options2.path) {
        if (!pathValueRegExp.test(options2.path)) {
          throw new TypeError(`option path is invalid: ${options2.path}`);
        }
        str += "; Path=" + options2.path;
      }
      if (options2.expires) {
        if (!isDate(options2.expires) || !Number.isFinite(options2.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${options2.expires}`);
        }
        str += "; Expires=" + options2.expires.toUTCString();
      }
      if (options2.httpOnly) {
        str += "; HttpOnly";
      }
      if (options2.secure) {
        str += "; Secure";
      }
      if (options2.partitioned) {
        str += "; Partitioned";
      }
      if (options2.priority) {
        const priority = typeof options2.priority === "string" ? options2.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${options2.priority}`);
        }
      }
      if (options2.sameSite) {
        const sameSite = typeof options2.sameSite === "string" ? options2.sameSite.toLowerCase() : options2.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${options2.sameSite}`);
        }
      }
      return str;
    }
    function decode3(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e3) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// node_modules/set-cookie-parser/lib/set-cookie.js
var require_set_cookie = __commonJS({
  "node_modules/set-cookie-parser/lib/set-cookie.js"(exports, module) {
    "use strict";
    var defaultParseOptions = {
      decodeValues: true,
      map: false,
      silent: false
    };
    function isForbiddenKey(key2) {
      return typeof key2 !== "string" || key2 in {};
    }
    function createNullObj() {
      return /* @__PURE__ */ Object.create(null);
    }
    function isNonEmptyString(str) {
      return typeof str === "string" && !!str.trim();
    }
    function parseString2(setCookieValue, options2) {
      var parts = setCookieValue.split(";").filter(isNonEmptyString);
      var nameValuePairStr = parts.shift();
      var parsed = parseNameValuePair(nameValuePairStr);
      var name = parsed.name;
      var value = parsed.value;
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (isForbiddenKey(name)) {
        return null;
      }
      try {
        value = options2.decodeValues ? decodeURIComponent(value) : value;
      } catch (e3) {
        console.error(
          "set-cookie-parser: failed to decode cookie value. Set options.decodeValues=false to disable decoding.",
          e3
        );
      }
      var cookie = createNullObj();
      cookie.name = name;
      cookie.value = value;
      parts.forEach(function(part) {
        var sides = part.split("=");
        var key2 = sides.shift().trimLeft().toLowerCase();
        if (isForbiddenKey(key2)) {
          return;
        }
        var value2 = sides.join("=");
        if (key2 === "expires") {
          cookie.expires = new Date(value2);
        } else if (key2 === "max-age") {
          var n2 = parseInt(value2, 10);
          if (!Number.isNaN(n2))
            cookie.maxAge = n2;
        } else if (key2 === "secure") {
          cookie.secure = true;
        } else if (key2 === "httponly") {
          cookie.httpOnly = true;
        } else if (key2 === "samesite") {
          cookie.sameSite = value2;
        } else if (key2 === "partitioned") {
          cookie.partitioned = true;
        } else if (key2) {
          cookie[key2] = value2;
        }
      });
      return cookie;
    }
    function parseNameValuePair(nameValuePairStr) {
      var name = "";
      var value = "";
      var nameValueArr = nameValuePairStr.split("=");
      if (nameValueArr.length > 1) {
        name = nameValueArr.shift();
        value = nameValueArr.join("=");
      } else {
        value = nameValuePairStr;
      }
      return { name, value };
    }
    function parse5(input, options2) {
      options2 = options2 ? Object.assign({}, defaultParseOptions, options2) : defaultParseOptions;
      if (!input) {
        if (!options2.map) {
          return [];
        } else {
          return createNullObj();
        }
      }
      if (input.headers) {
        if (typeof input.headers.getSetCookie === "function") {
          input = input.headers.getSetCookie();
        } else if (input.headers["set-cookie"]) {
          input = input.headers["set-cookie"];
        } else {
          var sch = input.headers[Object.keys(input.headers).find(function(key2) {
            return key2.toLowerCase() === "set-cookie";
          })];
          if (!sch && input.headers.cookie && !options2.silent) {
            console.warn(
              "Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning."
            );
          }
          input = sch;
        }
      }
      if (!Array.isArray(input)) {
        input = [input];
      }
      if (!options2.map) {
        return input.filter(isNonEmptyString).map(function(str) {
          return parseString2(str, options2);
        }).filter(Boolean);
      } else {
        var cookies = createNullObj();
        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {
          var cookie = parseString2(str, options2);
          if (cookie && !isForbiddenKey(cookie.name)) {
            cookies2[cookie.name] = cookie;
          }
          return cookies2;
        }, cookies);
      }
    }
    function splitCookiesString2(cookiesString) {
      if (Array.isArray(cookiesString)) {
        return cookiesString;
      }
      if (typeof cookiesString !== "string") {
        return [];
      }
      var cookiesStrings = [];
      var pos = 0;
      var start;
      var ch;
      var lastComma;
      var nextStart;
      var cookiesSeparatorFound;
      function skipWhitespace() {
        while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
          pos += 1;
        }
        return pos < cookiesString.length;
      }
      function notSpecialChar() {
        ch = cookiesString.charAt(pos);
        return ch !== "=" && ch !== ";" && ch !== ",";
      }
      while (pos < cookiesString.length) {
        start = pos;
        cookiesSeparatorFound = false;
        while (skipWhitespace()) {
          ch = cookiesString.charAt(pos);
          if (ch === ",") {
            lastComma = pos;
            pos += 1;
            skipWhitespace();
            nextStart = pos;
            while (pos < cookiesString.length && notSpecialChar()) {
              pos += 1;
            }
            if (pos < cookiesString.length && cookiesString.charAt(pos) === "=") {
              cookiesSeparatorFound = true;
              pos = nextStart;
              cookiesStrings.push(cookiesString.substring(start, lastComma));
              start = pos;
            } else {
              pos = lastComma + 1;
            }
          } else {
            pos += 1;
          }
        }
        if (!cookiesSeparatorFound || pos >= cookiesString.length) {
          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
        }
      }
      return cookiesStrings;
    }
    module.exports = parse5;
    module.exports.parse = parse5;
    module.exports.parseString = parseString2;
    module.exports.splitCookiesString = splitCookiesString2;
  }
});

// .svelte-kit/output/server/chunks/logger.js
function log(level, message, context) {
  const logEntry = {
    level,
    message,
    ...context,
    timestamp: (/* @__PURE__ */ new Date()).toISOString()
  };
  switch (level) {
    case "error":
      console.error(JSON.stringify(logEntry));
      break;
    case "warn":
      console.warn(JSON.stringify(logEntry));
      break;
    default:
      console.log(JSON.stringify(logEntry));
  }
}
function logError(message, error47, context) {
  log("error", message, { ...context, error: error47 instanceof Error ? error47.message : String(error47) });
}
var init_logger = __esm({
  ".svelte-kit/output/server/chunks/logger.js"() {
  }
});

// .svelte-kit/output/server/chunks/security.js
var SecurityManager, SECURITY_RATE_LIMITS;
var init_security = __esm({
  ".svelte-kit/output/server/chunks/security.js"() {
    init_prisma();
    SecurityManager = class _SecurityManager {
      constructor() {
        this.ipBlockCache = /* @__PURE__ */ new Map();
        this.lastCacheCleanup = 0;
        this.CACHE_CLEANUP_INTERVAL = 6e4;
        this.rateLimitMap = /* @__PURE__ */ new Map();
      }
      // 1 minute
      static getInstance() {
        if (!_SecurityManager.instance) {
          _SecurityManager.instance = new _SecurityManager();
        }
        return _SecurityManager.instance;
      }
      // Clean expired entries from cache
      cleanupCache() {
        const now = Date.now();
        if (now - this.lastCacheCleanup < this.CACHE_CLEANUP_INTERVAL)
          return;
        for (const [ip, block] of this.ipBlockCache.entries()) {
          if (block.expiresAt && now > block.expiresAt) {
            this.ipBlockCache.delete(ip);
          }
        }
        this.lastCacheCleanup = now;
      }
      // Check if IP is blocked
      async isIPBlocked(ip) {
        this.cleanupCache();
        const cached2 = this.ipBlockCache.get(ip);
        if (cached2) {
          if (!cached2.expiresAt || Date.now() < cached2.expiresAt) {
            return { blocked: true, reason: cached2.reason };
          }
          this.ipBlockCache.delete(ip);
        }
        const prisma = await getPrisma();
        const block = await prisma.iPBlock.findFirst({
          where: {
            ipAddress: ip,
            OR: [
              { expiresAt: null },
              // Permanent block
              { expiresAt: { gte: /* @__PURE__ */ new Date() } }
              // Temporary block not expired
            ]
          }
        });
        if (block) {
          const expiresAt = block.expiresAt ? block.expiresAt.getTime() : void 0;
          this.ipBlockCache.set(ip, {
            blocked: true,
            expiresAt,
            reason: block.reason
          });
          return {
            blocked: true,
            reason: block.reason,
            expiresAt: block.expiresAt || void 0
          };
        }
        return { blocked: false };
      }
      // Block an IP address
      async blockIP(ip, reason, severity = "TEMPORARY", blockedBy, organizationId) {
        const prisma = await getPrisma();
        const now = /* @__PURE__ */ new Date();
        let expiresAt;
        if (severity === "TEMPORARY") {
          expiresAt = new Date(now.getTime() + 15 * 60 * 1e3);
        }
        const isSystemBlock = !blockedBy;
        if (!isSystemBlock && !organizationId) {
          throw new Error("organizationId is required for manual IP blocks");
        }
        const updateData = {
          reason,
          severity,
          blockedAt: now,
          expiresAt,
          violationCount: { increment: 1 }
        };
        if (organizationId)
          updateData.organizationId = organizationId;
        if (blockedBy !== void 0)
          updateData.blockedBy = blockedBy;
        const createData = {
          ipAddress: ip,
          reason,
          severity,
          blockedAt: now,
          expiresAt,
          violationCount: 1
        };
        if (organizationId)
          createData.organizationId = organizationId;
        if (blockedBy !== void 0)
          createData.blockedBy = blockedBy;
        await prisma.iPBlock.upsert({
          where: { ipAddress: ip },
          update: updateData,
          create: createData
        });
        this.ipBlockCache.set(ip, {
          blocked: true,
          expiresAt: expiresAt?.getTime(),
          reason
        });
        await this.logSecurityEvent({
          ipAddress: ip,
          action: "IP_BLOCKED",
          details: { reason, severity, blockedBy, organizationId },
          severity: severity === "PERSISTENT" ? "CRITICAL" : "WARNING"
        });
      }
      // Enhanced rate limiting with IP blocking
      async checkRateLimit(ctx, config2) {
        const ip = this.getClientIP(ctx.event);
        const key2 = `${ip}:${ctx.action || "global"}`;
        const blockStatus = await this.isIPBlocked(ip);
        if (blockStatus.blocked) {
          return { success: false, blocked: true };
        }
        const rateLimitResult = this.checkInMemoryRateLimit(key2, config2);
        if (!rateLimitResult.success) {
          await this.logSecurityEvent({
            event: ctx.event,
            ipAddress: ip,
            action: "RATE_LIMIT_VIOLATION",
            details: {
              limit: config2.limit,
              windowMs: config2.windowMs,
              action: ctx.action
            },
            severity: "WARNING",
            userId: ctx.userId
          });
          if (config2.violationThreshold) {
            const recentViolations = await this.getRecentViolations(ip, config2.windowMs * 2);
            if (recentViolations >= config2.violationThreshold) {
              config2.blockDuration || 24 * 60 * 60 * 1e3;
              await this.blockIP(
                ip,
                `Excessive violations: ${recentViolations} in ${config2.windowMs * 2}ms`,
                "PERSISTENT",
                void 0
              );
              return { success: false, blocked: true };
            } else {
              await this.blockIP(
                ip,
                "Rate limit exceeded",
                "TEMPORARY",
                void 0
              );
            }
          }
        }
        return rateLimitResult;
      }
      checkInMemoryRateLimit(key2, config2) {
        const now = Date.now();
        const entry = this.rateLimitMap.get(key2);
        if (!entry || now > entry.resetTime) {
          const newEntry = {
            count: 1,
            resetTime: now + config2.windowMs
          };
          this.rateLimitMap.set(key2, newEntry);
          return {
            success: true,
            resetTime: newEntry.resetTime,
            remaining: config2.limit - 1
          };
        }
        if (entry.count >= config2.limit) {
          return {
            success: false,
            resetTime: entry.resetTime,
            remaining: 0
          };
        }
        entry.count++;
        return {
          success: true,
          resetTime: entry.resetTime,
          remaining: config2.limit - entry.count
        };
      }
      // Get client IP from request
      getClientIP(event) {
        const cfConnectingIP = event.request.headers.get("cf-connecting-ip");
        if (cfConnectingIP)
          return cfConnectingIP;
        const xForwardedFor = event.request.headers.get("x-forwarded-for");
        if (xForwardedFor) {
          return xForwardedFor.split(",")[0].trim();
        }
        const xRealIP = event.request.headers.get("x-real-ip");
        if (xRealIP)
          return xRealIP;
        return event.getClientAddress();
      }
      // Get recent violations count
      async getRecentViolations(ip, timeWindowMs) {
        const prisma = await getPrisma();
        const cutoff = new Date(Date.now() - timeWindowMs);
        const count = await prisma.securityLog.count({
          where: {
            ipAddress: ip,
            action: "RATE_LIMIT_VIOLATION",
            createdAt: { gte: cutoff }
          }
        });
        return count;
      }
      // Log security events
      async logSecurityEvent(data) {
        const prisma = await getPrisma();
        let ip = data.ipAddress;
        let userAgent;
        if (data.event && !ip) {
          ip = this.getClientIP(data.event);
          userAgent = data.event.request.headers.get("user-agent") || void 0;
        }
        await prisma.securityLog.create({
          data: {
            ipAddress: ip || "unknown",
            userAgent,
            action: data.action,
            details: data.details,
            severity: data.severity || "INFO",
            userId: data.userId
          }
        });
        this.cleanupOldLogs();
      }
      // Clean up old logs (run periodically)
      async cleanupOldLogs() {
        const lastCleanup = parseInt(process.env.LAST_LOG_CLEANUP || "0");
        const now = Date.now();
        if (now - lastCleanup < 36e5)
          return;
        process.env.LAST_LOG_CLEANUP = now.toString();
        const prisma = await getPrisma();
        const cutoff = new Date(now - 30 * 24 * 60 * 60 * 1e3);
        await prisma.securityLog.deleteMany({
          where: {
            createdAt: { lt: cutoff }
          }
        });
        await prisma.iPBlock.deleteMany({
          where: {
            expiresAt: { lt: /* @__PURE__ */ new Date() }
          }
        });
      }
      // Get security logs for dashboard
      async getSecurityLogs(filters) {
        const prisma = await getPrisma();
        const {
          severity,
          action,
          ipAddress,
          limit = 50,
          offset = 0,
          startDate,
          endDate,
          organizationId
        } = filters;
        const where = {};
        if (severity)
          where.severity = severity;
        if (action)
          where.action = action;
        if (ipAddress)
          where.ipAddress = ipAddress;
        if (startDate || endDate) {
          where.createdAt = {};
          if (startDate)
            where.createdAt.gte = startDate;
          if (endDate)
            where.createdAt.lte = endDate;
        }
        if (organizationId) {
          where.User = { organizationId };
        }
        const [logs, total] = await Promise.all([
          prisma.securityLog.findMany({
            where,
            orderBy: { createdAt: "desc" },
            take: limit,
            skip: offset,
            include: {
              User: {
                select: {
                  id: true,
                  firstName: true,
                  lastName: true,
                  email: true
                }
              }
            }
          }),
          prisma.securityLog.count({ where })
        ]);
        return { logs, total };
      }
      // Get blocked IPs for dashboard
      async getBlockedIPs(limit = 50, offset = 0, organizationId) {
        const prisma = await getPrisma();
        const where = organizationId ? { OR: [{ organizationId }, { organizationId: null }] } : void 0;
        const [blocks, total] = await Promise.all([
          prisma.iPBlock.findMany({
            where,
            orderBy: { blockedAt: "desc" },
            take: limit,
            skip: offset,
            include: {
              Organization: {
                select: { id: true, name: true }
              },
              User: {
                select: { id: true, firstName: true, lastName: true }
              }
            }
          }),
          prisma.iPBlock.count({ where })
        ]);
        return { blocks, total };
      }
      // Unblock an IP
      async unblockIP(ip, unblockedBy) {
        const prisma = await getPrisma();
        await prisma.iPBlock.delete({
          where: { ipAddress: ip }
        });
        this.ipBlockCache.delete(ip);
        await this.logSecurityEvent({
          ipAddress: ip,
          action: "IP_UNBLOCKED",
          details: { unblockedBy },
          severity: "INFO"
        });
      }
    };
    SECURITY_RATE_LIMITS = {
      AUTH: {
        limit: 5,
        windowMs: 60 * 1e3,
        blockDuration: 15 * 60 * 1e3,
        // 15 minutes
        violationThreshold: 3
        // Block after 3 violations
      },
      API: {
        limit: 100,
        windowMs: 60 * 1e3,
        violationThreshold: 5
      },
      FORM: {
        limit: 10,
        windowMs: 60 * 1e3,
        violationThreshold: 3
      },
      PASSWORD_RESET: {
        limit: 3,
        windowMs: 60 * 60 * 1e3,
        // 1 hour
        violationThreshold: 2
      }
    };
  }
});

// .svelte-kit/output/server/chunks/audit.js
async function logAudit(userId, action, details) {
  try {
    const client = await getPrisma();
    await client.auditLog.create({
      data: {
        userId,
        action,
        details
      }
    });
    const security = SecurityManager.getInstance();
    const privilegedActions = [
      "USER_CREATED",
      "USER_UPDATED",
      "USER_ROLE_CHANGED",
      "USER_DELETED",
      "WORK_ORDER_DELETED",
      "ASSET_DELETED",
      "SITE_DELETED",
      "ROOM_DELETED"
    ];
    if (privilegedActions.includes(action)) {
      await security.logSecurityEvent({
        action: `PRIVILEGED_ACTION: ${action}`,
        details: {
          auditAction: action,
          auditDetails: details
        },
        severity: "WARNING",
        userId
      });
    }
  } catch (e3) {
    console.error("Audit log failed:", e3);
  }
}
var init_audit = __esm({
  ".svelte-kit/output/server/chunks/audit.js"() {
    init_prisma();
    init_security();
  }
});

// .svelte-kit/output/server/chunks/templates.js
async function queryTemplates(prisma, filters) {
  const { organizationId, isActive, search } = filters;
  const where = {
    OR: [
      { organizationId },
      { isGlobal: true }
    ]
  };
  if (isActive !== void 0) {
    where.isActive = isActive;
  }
  if (search) {
    where.name = { contains: search, mode: "insensitive" };
  }
  const templates = await prisma.workOrderTemplate.findMany({
    where,
    orderBy: { name: "asc" },
    include: {
      Organization: {
        select: { id: true, name: true }
      },
      Creator: {
        select: { id: true, firstName: true, lastName: true, email: true }
      }
    }
  });
  const templateIds = templates.map((t2) => t2.id);
  const itemCounts = await prisma.workOrderTemplateItem.groupBy({
    by: ["templateId"],
    where: { templateId: { in: templateIds } },
    _count: { _all: true }
  });
  const itemCountMap = new Map(
    itemCounts.map((item) => [item.templateId, item._count._all])
  );
  return templates.map((template) => ({
    ...template,
    _itemCount: itemCountMap.get(template.id) || 0
  }));
}
async function getTemplateById(prisma, templateId, organizationId, userId) {
  let template;
  try {
    template = await prisma.workOrderTemplate.findUnique({
      where: { id: templateId },
      include: {
        TemplateItems: {
          orderBy: { position: "asc" }
        }
      }
    });
  } catch (e3) {
    logError("Failed to fetch template", e3, { templateId, userId });
    return fail(500, { error: "Failed to fetch template. Please try again." });
  }
  if (!template) {
    return fail(404, { error: "Template not found." });
  }
  if (!template.isGlobal && template.organizationId !== organizationId) {
    if (userId) {
      const security = SecurityManager.getInstance();
      await security.logSecurityEvent({
        event: void 0,
        action: "TEMPLATE_ACCESS_DENIED",
        details: { templateId, reason: "Organization mismatch" },
        severity: "WARNING",
        userId
      });
    }
    return fail(403, { error: "You do not have access to this template." });
  }
  if (!template.isActive) {
    return fail(404, { error: "Template not found." });
  }
  return template;
}
async function createTemplate(event, prisma, data, userId, organizationId) {
  const { name, description, title, workDescription, priority, isGlobal = false, items } = data;
  if (isGlobal) {
    const user = await prisma.user.findUnique({
      where: { id: userId },
      select: { role: true }
    });
    if (!user || user.role !== "ADMIN") {
      return fail(403, { error: "Only administrators can create global templates." });
    }
  }
  if (!items || items.length === 0) {
    return fail(400, { error: "At least one checklist item is required." });
  }
  try {
    const template = await prisma.$transaction(async (tx) => {
      const newTemplate = await tx.workOrderTemplate.create({
        data: {
          name: name.trim(),
          description: description?.trim() || null,
          title: title?.trim() || null,
          workDescription: workDescription?.trim() || null,
          priority: priority || "MEDIUM",
          isGlobal,
          organizationId: isGlobal ? null : organizationId,
          createdBy: userId
        }
      });
      const templateItems = items.map((item, index24) => ({
        title: item.title.trim(),
        position: index24,
        templateId: newTemplate.id
      }));
      await tx.workOrderTemplateItem.createMany({
        data: templateItems
      });
      return newTemplate;
    });
    await logAudit(userId, "WORK_ORDER_TEMPLATE_CREATED", {
      templateId: template.id,
      name: template.name,
      isGlobal: template.isGlobal
    });
    return { success: true, template };
  } catch (e3) {
    logError("Failed to create template", e3, { userId, organizationId });
    return fail(500, { error: "Failed to create template. Please try again." });
  }
}
async function updateTemplate(event, prisma, templateId, data, userId, organizationId) {
  const existing = await getTemplateById(prisma, templateId, organizationId);
  if ("status" in existing) {
    return existing;
  }
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  if (!user) {
    return fail(403, { error: "User not found." });
  }
  const isCreator = existing.createdBy === userId;
  const isManager = user.role === "MANAGER" || user.role === "ADMIN";
  if (!isCreator && !isManager) {
    return fail(403, { error: "You can only edit your own templates." });
  }
  if (existing.isGlobal && user.role !== "ADMIN") {
    return fail(403, { error: "Only administrators can edit global templates." });
  }
  try {
    const { name, description, title, workDescription, priority, isActive, items } = data;
    await prisma.$transaction(async (tx) => {
      const updateData = {};
      if (name !== void 0)
        updateData.name = name.trim();
      if (description !== void 0) {
        updateData.description = description?.trim() || null;
      }
      if (title !== void 0) {
        updateData.title = title?.trim() || null;
      }
      if (workDescription !== void 0) {
        updateData.workDescription = workDescription?.trim() || null;
      }
      if (priority !== void 0)
        updateData.priority = priority;
      if (isActive !== void 0)
        updateData.isActive = isActive;
      if (Object.keys(updateData).length > 0) {
        await tx.workOrderTemplate.update({
          where: { id: templateId },
          data: updateData
        });
      }
      if (items && items.length > 0) {
        await tx.workOrderTemplateItem.deleteMany({
          where: { templateId }
        });
        const templateItems = items.map((item, index24) => ({
          title: item.title.trim(),
          position: index24,
          templateId
        }));
        await tx.workOrderTemplateItem.createMany({
          data: templateItems
        });
      }
    });
    await logAudit(userId, "WORK_ORDER_TEMPLATE_UPDATED", {
      templateId
    });
    return { success: true };
  } catch (e3) {
    logError("Failed to update template", e3, { templateId, userId });
    return fail(500, { error: "Failed to update template. Please try again." });
  }
}
async function deleteTemplate(event, prisma, templateId, userId, organizationId) {
  const existing = await prisma.workOrderTemplate.findUnique({
    where: { id: templateId },
    select: { id: true, createdBy: true, isGlobal: true, organizationId: true }
  });
  if (!existing) {
    return fail(404, { error: "Template not found." });
  }
  if (!existing.isGlobal && existing.organizationId !== organizationId) {
    return fail(403, { error: "You do not have access to this template." });
  }
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { role: true }
  });
  if (!user) {
    return fail(403, { error: "User not found." });
  }
  const isCreator = existing.createdBy === userId;
  const isManager = user.role === "MANAGER" || user.role === "ADMIN";
  if (!isCreator && !isManager) {
    return fail(403, { error: "You can only delete your own templates." });
  }
  if (existing.isGlobal && user.role !== "ADMIN") {
    return fail(403, { error: "Only administrators can delete global templates." });
  }
  try {
    await prisma.workOrderTemplate.update({
      where: { id: templateId },
      data: { isActive: false }
    });
    await logAudit(userId, "WORK_ORDER_TEMPLATE_DELETED", {
      templateId
    });
    return { success: true };
  } catch (e3) {
    logError("Failed to delete template", e3, { templateId, userId });
    return fail(500, { error: "Failed to delete template. Please try again." });
  }
}
async function applyTemplate(prisma, templateId, organizationId) {
  const template = await prisma.workOrderTemplate.findUnique({
    where: { id: templateId },
    include: {
      TemplateItems: {
        orderBy: { position: "asc" }
      }
    }
  });
  if (!template) {
    return fail(404, { error: "Template not found." });
  }
  if (!template.isActive) {
    return fail(400, { error: "This template is no longer active." });
  }
  if (!template.isGlobal && template.organizationId !== organizationId) {
    return fail(403, { error: "You do not have access to this template." });
  }
  try {
    await prisma.workOrderTemplate.update({
      where: { id: templateId },
      data: { usageCount: { increment: 1 } }
    });
    return {
      title: template.title,
      description: template.workDescription,
      priority: template.priority,
      items: template.TemplateItems.map((item) => ({
        title: item.title,
        position: item.position
      }))
    };
  } catch (e3) {
    logError("Failed to apply template", e3, { templateId, organizationId });
    return fail(500, { error: "Failed to apply template. Please try again." });
  }
}
var init_templates = __esm({
  ".svelte-kit/output/server/chunks/templates.js"() {
    init_chunks();
    init_logger();
    init_audit();
    init_security();
  }
});

// .svelte-kit/output/server/entries/pages/_layout.server.ts.js
var layout_server_ts_exports = {};
__export(layout_server_ts_exports, {
  load: () => load
});
var load;
var init_layout_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.server.ts.js"() {
    init_prisma();
    init_templates();
    load = async ({ locals }) => {
      let assets2 = [];
      let buildings = [];
      let rooms = [];
      let templates = [];
      if (locals.user && locals.authState === "org_member") {
        const prisma = await getPrisma();
        assets2 = await prisma.asset.findMany({
          where: {
            Unit: {
              Site: {
                organizationId: locals.user.organizationId ?? void 0
              }
            }
          },
          include: {
            Unit: {
              include: {
                Building: true,
                Site: { select: { name: true } }
              }
            }
          },
          orderBy: {
            name: "asc"
          },
          take: 35
          // Limit to keep it performant
        });
        buildings = await prisma.building.findMany({
          where: {
            Site: {
              organizationId: locals.user.organizationId ?? void 0
            }
          },
          include: {
            Site: true
          },
          orderBy: {
            name: "asc"
          },
          take: 35
          // Limit to keep it performant
        });
        rooms = await prisma.unit.findMany({
          where: {
            Site: {
              organizationId: locals.user.organizationId ?? void 0
            }
          },
          include: {
            Building: true,
            Site: true
          },
          orderBy: {
            roomNumber: "asc"
          },
          take: 35
          // Limit to keep it performant
        });
        templates = await queryTemplates(prisma, {
          organizationId: locals.user.organizationId,
          isActive: true
        });
      }
      return {
        user: locals.user ?? null,
        authState: locals.authState,
        organizations: locals.organizations,
        currentOrganization: locals.currentOrganization,
        assets: assets2.map((asset) => ({
          id: asset.id,
          name: asset.name,
          room: asset.Unit ? {
            id: asset.Unit.id,
            name: asset.Unit.name || asset.Unit.roomNumber,
            building: asset.Unit.Building,
            site: asset.Unit.Site ? {
              name: asset.Unit.Site.name
            } : void 0
          } : void 0
        })),
        buildings: buildings.map((building2) => ({
          id: building2.id,
          name: building2.name,
          site: building2.Site ? {
            name: building2.Site.name
          } : void 0
        })),
        rooms: rooms.map((unit) => ({
          id: unit.id,
          name: unit.name || unit.roomNumber,
          building: unit.Building,
          site: unit.Site ? {
            name: unit.Site.name
          } : void 0
        })),
        templates
      };
    };
  }
});

// .svelte-kit/output/server/chunks/stores.js
var getStores, page;
var init_stores = __esm({
  ".svelte-kit/output/server/chunks/stores.js"() {
    init_ssr();
    getStores = () => {
      const stores = getContext("__svelte__");
      return {
        /** @type {typeof page} */
        page: {
          subscribe: stores.page.subscribe
        },
        /** @type {typeof navigating} */
        navigating: {
          subscribe: stores.navigating.subscribe
        },
        /** @type {typeof updated} */
        updated: stores.updated
      };
    };
    page = {
      subscribe(fn) {
        const store = getStores().page;
        return store.subscribe(fn);
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/_layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
  default: () => Layout
});
function isPathExcluded(pathname) {
  return breadcrumbConfig.excludedPaths.some((pattern2) => {
    const regex = new RegExp(`^${pattern2}$`);
    return regex.test(pathname);
  });
}
function patternToRegex(pattern2) {
  return new RegExp(
    "^" + pattern2.replace(/\[([^\]]+)\]/g, "([^/]+)") + "$"
  );
}
function extractParams(pattern2, pathname) {
  const regex = patternToRegex(pattern2);
  const match = pathname.match(regex);
  if (!match)
    return null;
  const paramNames = pattern2.match(/\[([^\]]+)\]/g) || [];
  const params = {};
  paramNames.forEach((param, index24) => {
    const paramName = param.slice(1, -1);
    params[paramName] = match[index24 + 1];
  });
  return params;
}
function findRoute(pathname) {
  for (const route of breadcrumbConfig.routes) {
    const params = extractParams(route.path, pathname);
    if (params) {
      return { route, params };
    }
  }
  return null;
}
function getParentPath(routePath, explicitParent) {
  if (explicitParent)
    return explicitParent;
  const segments = routePath.split("/").filter(Boolean);
  if (segments.length <= 1)
    return null;
  segments.pop();
  return "/" + segments.join("/");
}
function buildHref(pattern2, params) {
  let href = pattern2;
  Object.entries(params).forEach(([key2, value]) => {
    href = href.replace(`[${key2}]`, value);
  });
  return href;
}
function getBreadcrumbs(pathname, pageParams, pageData, userRole) {
  const items = [];
  const match = findRoute(pathname);
  if (!match)
    return items;
  const { route, params } = match;
  if (route.role && route.role !== userRole)
    return items;
  const visited = /* @__PURE__ */ new Set();
  const buildHierarchy = (currentPath) => {
    if (visited.has(currentPath))
      return [];
    visited.add(currentPath);
    const routeMatch = findRoute(currentPath);
    if (!routeMatch)
      return [];
    const { route: currentRoute, params: currentParams } = routeMatch;
    if (currentRoute.role && currentRoute.role !== userRole)
      return [];
    const parentPath = getParentPath(currentRoute.path, currentRoute.parent);
    const parentItems = parentPath ? buildHierarchy(parentPath) : [];
    let title = currentRoute.title;
    if (currentRoute.dynamic && currentRoute.fetchTitle) {
      title = currentRoute.fetchTitle(currentParams, { pageData, user: { role: userRole } });
    }
    const href = buildHref(currentRoute.path, currentParams);
    const isCurrentPage = href === pathname;
    return [
      ...parentItems,
      {
        title,
        href: isCurrentPage ? void 0 : href,
        icon: currentRoute.icon
      }
    ];
  };
  return buildHierarchy(pathname);
}
var QuickFAB, breadcrumbConfig, Breadcrumb, Layout;
var init_layout_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_layout.svelte.js"() {
    init_ssr();
    init_stores();
    init_devalue();
    QuickFAB = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { assets: assets2 = [] } = $$props;
      let { buildings = [] } = $$props;
      let { rooms = [] } = $$props;
      let { templates = [] } = $$props;
      createEventDispatcher();
      if ($$props.assets === void 0 && $$bindings.assets && assets2 !== void 0)
        $$bindings.assets(assets2);
      if ($$props.buildings === void 0 && $$bindings.buildings && buildings !== void 0)
        $$bindings.buildings(buildings);
      if ($$props.rooms === void 0 && $$bindings.rooms && rooms !== void 0)
        $$bindings.rooms(rooms);
      if ($$props.templates === void 0 && $$bindings.templates && templates !== void 0)
        $$bindings.templates(templates);
      return ` ${` <button type="button" class="fixed bottom-6 right-6 z-50 bg-spore-orange hover:bg-spore-orange/90 text-white rounded-full w-14 h-14 flex items-center justify-center shadow-lg hover:shadow-xl transition-all transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-spore-orange/50 lg:hidden" title="Create Work Order" aria-label="Create Work Order"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg></button>  <button type="button" class="fixed bottom-6 right-6 z-50 bg-spore-orange hover:bg-spore-orange/90 text-white rounded-full w-16 h-16 flex items-center justify-center shadow-lg hover:shadow-xl transition-all transform hover:scale-110 focus:outline-none focus:ring-4 focus:ring-spore-orange/50 hidden lg:flex" title="Create Work Order" aria-label="Create Work Order"><svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg></button>`}  ${``}`;
    });
    breadcrumbConfig = {
      excludedPaths: [
        "/",
        "/auth.*",
        "/onboarding",
        "/join-organization",
        "/select-organization"
      ],
      routes: [
        { path: "/dashboard", title: "Dashboard", icon: "\u{1F4CA}" },
        {
          path: "/work-orders",
          title: "Work Orders",
          icon: "\u{1F4CB}",
          parent: "/dashboard"
        },
        {
          path: "/work-orders/[id]",
          title: "Work Order",
          dynamic: true,
          fetchTitle: (_params, data) => data.pageData?.workOrder?.title || "Work Order",
          parent: "/work-orders"
        },
        {
          path: "/sites",
          title: "Sites",
          icon: "\u{1F3E2}",
          parent: "/dashboard"
        },
        {
          path: "/sites/[id]",
          title: "Site",
          dynamic: true,
          fetchTitle: (_params, data) => data.pageData?.site?.name || "Site",
          parent: "/sites"
        },
        {
          path: "/assets",
          title: "Assets",
          icon: "\u2699\uFE0F",
          parent: "/dashboard"
        },
        {
          path: "/assets/[id]",
          title: "Asset",
          dynamic: true,
          fetchTitle: (_params, data) => data.pageData?.asset?.name || "Asset",
          parent: "/assets"
        },
        {
          path: "/templates",
          title: "Templates",
          icon: "\u{1F4DD}",
          parent: "/dashboard"
        },
        {
          path: "/templates/[id]",
          title: "Template",
          dynamic: true,
          fetchTitle: (_params, data) => data.pageData?.template?.name || "Template",
          parent: "/templates"
        },
        {
          path: "/work-orders/new",
          title: "New Work Order",
          parent: "/work-orders"
        },
        {
          path: "/users",
          title: "Users",
          icon: "\u{1F465}",
          parent: "/dashboard"
        },
        { path: "/users/security", title: "Security", parent: "/users" },
        {
          path: "/audit-log",
          title: "Audit Log",
          icon: "\u{1F4DC}",
          parent: "/dashboard"
        },
        { path: "/profile", title: "Profile" }
      ]
    };
    Breadcrumb = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let showBreadcrumbs;
      let breadcrumbs;
      let $page, $$unsubscribe_page;
      validate_store(page, "page");
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      let currentPathname = "";
      {
        if ($page.url) {
          currentPathname = $page.url.pathname;
        }
      }
      showBreadcrumbs = !isPathExcluded(currentPathname);
      breadcrumbs = getBreadcrumbs(
        currentPathname,
        $page.params || {},
        {
          pageData: $page.data,
          user: { role: $page.data?.user?.role }
        },
        $page.data?.user?.role
      );
      $$unsubscribe_page();
      return `${showBreadcrumbs && breadcrumbs.length > 0 ? `<nav class="bg-spore-steel" aria-label="Breadcrumb"><div class="max-w-7xl mx-auto px-4 py-2"><ol class="flex items-center gap-2 text-sm overflow-x-auto">${each(breadcrumbs, (crumb, index24) => {
        return `<li class="flex items-center gap-2">${index24 > 0 ? `<svg class="w-4 h-4 text-spore-cream/30 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd"></path></svg> ` : ``}}
						${crumb.href ? `<a${add_attribute("href", crumb.href, 0)} class="text-spore-cream/60 hover:text-spore-orange transition-colors truncate max-w-[200px]">${escape(crumb.title)} </a>` : `<span class="text-spore-orange font-semibold truncate max-w-[200px]">${escape(crumb.title)} </span>`} </li>`;
      })}</ol></div></nav>` : ``}`;
    });
    Layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let currentPath;
      let user;
      let authState;
      let isAuthPage;
      let isLandingPage;
      let isOnboardingPage;
      let showFAB;
      let $page, $$unsubscribe_page;
      validate_store(page, "page");
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      let { data } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      currentPath = $page.url.pathname;
      user = data.user;
      authState = data.authState;
      isAuthPage = currentPath.startsWith("/auth");
      isLandingPage = currentPath === "/";
      isOnboardingPage = currentPath.startsWith("/onboarding") || currentPath.startsWith("/join-organization") || currentPath.startsWith("/select-organization");
      showFAB = user && authState === "org_member" && !isAuthPage && !isLandingPage && !isOnboardingPage && !currentPath.startsWith("/work-orders/new");
      $$unsubscribe_page();
      return `${!isAuthPage && !isLandingPage && !isOnboardingPage && user && authState === "org_member" ? ` <nav class="bg-spore-dark border-b border-spore-steel/30"><div class="max-w-7xl mx-auto px-4"><div class="flex justify-between h-16"><div class="flex items-center gap-10"> <a href="/dashboard" class="flex items-center gap-2"><span class="text-2xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-p6fqmb">SPORE</span> <span class="text-xs font-medium text-spore-steel uppercase tracking-widest" data-svelte-h="svelte-1fermaa">CMMS</span></a>  <div class="hidden md:flex items-center gap-1"><a href="/dashboard" class="${"px-4 py-2 text-sm font-semibold tracking-wide transition-colors " + escape(
        currentPath === "/dashboard" ? "text-spore-orange" : "text-spore-cream/70 hover:text-spore-cream",
        true
      )}">Dashboard</a>  <div class="relative"><button class="${"px-4 py-2 text-sm font-semibold tracking-wide transition-colors flex items-center gap-1 " + escape(
        currentPath.startsWith("/work-orders") || currentPath.startsWith("/templates") ? "text-spore-orange" : "text-spore-cream/70 hover:text-spore-cream",
        true
      )}">Work Orders
							<svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></button>  <div id="wo-menu" class="hidden absolute left-0 mt-2 w-48 bg-spore-cream rounded-lg shadow-lg border border-spore-forest/20 z-50"><div class="py-1"><a href="/work-orders" class="block px-4 py-2 text-sm font-bold text-spore-forest hover:bg-spore-forest/10 transition-colors" data-svelte-h="svelte-19kcx05">Work Order Manager</a> <a href="/templates" class="block px-4 py-2 text-sm font-bold text-spore-forest hover:bg-spore-forest/10 transition-colors" data-svelte-h="svelte-vgv6ve">Template Manager</a></div></div></div> <a href="/sites" class="${"px-4 py-2 text-sm font-semibold tracking-wide transition-colors " + escape(
        currentPath.startsWith("/sites") ? "text-spore-orange" : "text-spore-cream/70 hover:text-spore-cream",
        true
      )}">Sites</a> <a href="/assets" class="${"px-4 py-2 text-sm font-semibold tracking-wide transition-colors " + escape(
        currentPath.startsWith("/assets") ? "text-spore-orange" : "text-spore-cream/70 hover:text-spore-cream",
        true
      )}">Assets</a> ${user.role === "ADMIN" ? `<a href="/users" class="${"px-4 py-2 text-sm font-semibold tracking-wide transition-colors " + escape(
        currentPath.startsWith("/users") ? "text-spore-orange" : "text-spore-cream/70 hover:text-spore-cream",
        true
      )}">Users</a> <a href="/audit-log" class="${"px-4 py-2 text-sm font-semibold tracking-wide transition-colors " + escape(
        currentPath.startsWith("/audit-log") ? "text-spore-orange" : "text-spore-cream/70 hover:text-spore-cream",
        true
      )}">Audit Log</a>` : ``}</div></div>  <div class="flex items-center gap-4">${data.organizations && data.organizations.length > 1 ? `<div class="relative hidden sm:block"><button class="text-right hover:opacity-80 transition-opacity"><p class="text-sm font-semibold text-spore-cream">${escape(user?.firstName || user?.email?.split("@")[0] || "User")}</p> <p class="text-xs text-spore-orange flex items-center gap-1">${escape(data.currentOrganization?.name || "Select Organization")} <svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg></p></button>  <div id="org-menu" class="hidden absolute right-0 mt-2 w-56 bg-spore-dark rounded-lg shadow-lg border border-spore-steel/30 z-50"><div class="py-1">${each(data.organizations, (org) => {
        return `<form method="POST" action="/select-organization" class="contents"><input type="hidden" name="organizationId"${add_attribute("value", org.id, 0)}> <button type="submit" class="${"w-full px-4 py-2 text-left text-sm hover:bg-spore-cream/10 transition-colors " + escape(
          org.id === data.currentOrganization?.id ? "text-spore-orange bg-spore-cream/5" : "text-spore-cream/80",
          true
        )}">${escape(org.name)} ${org.id === data.currentOrganization?.id ? `<span class="ml-2 text-xs" data-svelte-h="svelte-1b39yym">(Current)</span>` : ``}</button> </form>`;
      })}</div></div></div>` : `<a href="/profile" class="hidden sm:block text-right hover:opacity-80 transition-opacity"><p class="text-sm font-semibold text-spore-cream">${escape(user?.firstName || user?.email?.split("@")[0] || "User")}</p> <p class="text-xs text-spore-steel capitalize">${escape(user?.role?.toLowerCase() || "member")}</p></a>`} <form method="POST" action="/auth/logout"><button type="submit" class="text-sm font-semibold text-spore-cream/50 hover:text-spore-cream transition-colors" title="Sign out of your account" data-svelte-h="svelte-ou1opy">Logout</button></form></div></div></div></nav>  <nav class="md:hidden bg-spore-dark border-b border-spore-steel/30">${data.organizations && data.organizations.length > 1 ? ` <div class="px-4 py-3 border-b border-spore-steel/20"><div class="flex items-center justify-between"><span class="text-xs font-semibold text-spore-steel uppercase tracking-wider" data-svelte-h="svelte-1ihtktw">Organization</span> <div class="flex items-center gap-2"><span class="text-sm font-medium text-spore-orange truncate max-w-[180px]">${escape(data.currentOrganization?.name || "Select...")}</span> <a href="/select-organization" class="text-spore-cream/60 hover:text-spore-cream transition-colors"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg></a></div></div></div>` : ``} <div class="flex justify-around items-center py-3 shadow-lg"><a href="/dashboard" class="${"flex flex-col items-center gap-1 px-3 py-2 rounded-lg transition-colors " + escape(
        currentPath === "/dashboard" ? "text-spore-orange bg-spore-cream/10" : "text-spore-cream/70 hover:text-spore-cream hover:bg-spore-cream/5",
        true
      )}"><span class="text-xl leading-none" data-svelte-h="svelte-n8oaaj">\u{1F4CA}</span> <span class="text-xs font-medium" data-svelte-h="svelte-q6iwf9">Dashboard</span></a> <a href="/work-orders" class="${"flex flex-col items-center gap-1 px-3 py-2 rounded-lg transition-colors " + escape(
        currentPath.startsWith("/work-orders") ? "text-spore-orange bg-spore-cream/10" : "text-spore-cream/70 hover:text-spore-cream hover:bg-spore-cream/5",
        true
      )}"><span class="text-xl leading-none" data-svelte-h="svelte-ud50em">\u{1F4CB}</span> <span class="text-xs font-medium" data-svelte-h="svelte-t3cpir">Work Orders</span></a> <a href="/templates" class="${"flex flex-col items-center gap-1 px-3 py-2 rounded-lg transition-colors " + escape(
        currentPath.startsWith("/templates") ? "text-spore-orange bg-spore-cream/10" : "text-spore-cream/70 hover:text-spore-cream hover:bg-spore-cream/5",
        true
      )}"><span class="text-xl leading-none" data-svelte-h="svelte-108gef0">\u{1F4DD}</span> <span class="text-xs font-medium" data-svelte-h="svelte-fxknzk">Templates</span></a> <a href="/sites" class="${"flex flex-col items-center gap-1 px-3 py-2 rounded-lg transition-colors " + escape(
        currentPath.startsWith("/sites") ? "text-spore-orange bg-spore-cream/10" : "text-spore-cream/70 hover:text-spore-cream hover:bg-spore-cream/5",
        true
      )}"><span class="text-xl leading-none" data-svelte-h="svelte-1oi8lds">\u{1F3E2}</span> <span class="text-xs font-medium" data-svelte-h="svelte-1vga3wp">Sites</span></a> <a href="/assets" class="${"flex flex-col items-center gap-1 px-3 py-2 rounded-lg transition-colors " + escape(
        currentPath.startsWith("/assets") ? "text-spore-orange bg-spore-cream/10" : "text-spore-cream/70 hover:text-spore-cream hover:bg-spore-cream/5",
        true
      )}"><span class="text-xl leading-none" data-svelte-h="svelte-170tr8u">\u2699\uFE0F</span> <span class="text-xs font-medium" data-svelte-h="svelte-1vr39kw">Assets</span></a> ${user.role === "ADMIN" ? `<div class="flex gap-2"><a href="/users" class="${"flex flex-col items-center gap-1 px-2 py-2 rounded-lg transition-colors " + escape(
        currentPath.startsWith("/users") ? "text-spore-orange bg-spore-cream/10" : "text-spore-cream/70 hover:text-spore-cream hover:bg-spore-cream/5",
        true
      )}"><span class="text-lg leading-none" data-svelte-h="svelte-kzuy6d">\u{1F465}</span></a> <a href="/audit-log" class="${"flex flex-col items-center gap-1 px-2 py-2 rounded-lg transition-colors " + escape(
        currentPath.startsWith("/audit-log") ? "text-spore-orange bg-spore-cream/10" : "text-spore-cream/70 hover:text-spore-cream hover:bg-spore-cream/5",
        true
      )}"><span class="text-lg leading-none" data-svelte-h="svelte-r3t20g">\u{1F4DC}</span></a></div>` : ``}</div></nav>` : ``}  ${validate_component(Breadcrumb, "Breadcrumb").$$render($$result, {}, {}, {})} <main${add_attribute(
        "class",
        isAuthPage || isLandingPage ? "" : "bg-spore-steel min-h-screen",
        0
      )}>${slots.default ? slots.default({}) : ``}</main>  ${showFAB ? `${validate_component(QuickFAB, "QuickFAB").$$render(
        $$result,
        {
          assets: data.assets || [],
          buildings: data.buildings || [],
          rooms: data.rooms || [],
          templates: data.templates || []
        },
        {},
        {}
      )}` : ``}`;
    });
  }
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
  component: () => component,
  fonts: () => fonts,
  imports: () => imports,
  index: () => index,
  server: () => layout_server_ts_exports,
  server_id: () => server_id,
  stylesheets: () => stylesheets
});
var index, component_cache, component, server_id, imports, stylesheets, fonts;
var init__ = __esm({
  ".svelte-kit/output/server/nodes/0.js"() {
    init_layout_server_ts();
    index = 0;
    component = async () => component_cache ??= (await Promise.resolve().then(() => (init_layout_svelte(), layout_svelte_exports))).default;
    server_id = "src/routes/+layout.server.ts";
    imports = ["_app/immutable/nodes/0.4e77ab64.js", "_app/immutable/chunks/_layout.94fcb4e6.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/stores.e6b76d1c.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/globals.7f7f1b26.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/constants.cc7bddc0.js"];
    stylesheets = ["_app/immutable/assets/_layout.1ec5a2f9.css"];
    fonts = [];
  }
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
  default: () => Error2
});
var Error2;
var init_error_svelte = __esm({
  ".svelte-kit/output/server/entries/fallbacks/error.svelte.js"() {
    init_ssr();
    init_stores();
    Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let $page, $$unsubscribe_page;
      validate_store(page, "page");
      $$unsubscribe_page = subscribe(page, (value) => $page = value);
      $$unsubscribe_page();
      return `<h1>${escape($page.status)}</h1> <p>${escape($page.error?.message)}</p>`;
    });
  }
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
  component: () => component2,
  fonts: () => fonts2,
  imports: () => imports2,
  index: () => index2,
  stylesheets: () => stylesheets2
});
var index2, component_cache2, component2, imports2, stylesheets2, fonts2;
var init__2 = __esm({
  ".svelte-kit/output/server/nodes/1.js"() {
    index2 = 1;
    component2 = async () => component_cache2 ??= (await Promise.resolve().then(() => (init_error_svelte(), error_svelte_exports))).default;
    imports2 = ["_app/immutable/nodes/1.dbeccec8.js", "_app/immutable/chunks/error.522891f4.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/stores.e6b76d1c.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets2 = [];
    fonts2 = [];
  }
});

// .svelte-kit/output/server/entries/pages/_page.server.ts.js
var page_server_ts_exports = {};
__export(page_server_ts_exports, {
  actions: () => actions
});
var actions;
var init_page_server_ts = __esm({
  ".svelte-kit/output/server/entries/pages/_page.server.ts.js"() {
    init_chunks();
    init_prisma();
    actions = {
      joinWaitlist: async ({ request }) => {
        const data = await request.formData();
        const email3 = data.get("email");
        const name = data.get("name");
        const company = data.get("company");
        const role = data.get("role");
        const phone = data.get("phone");
        if (!email3 || !email3.includes("@")) {
          return fail(400, { email: email3, name, company, role, phone, error: "Please enter a valid email address." });
        }
        if (!name) {
          return fail(400, { email: email3, name, company, role, phone, error: "Name is required." });
        }
        try {
          const prisma = await getPrisma();
          await prisma.waitlist.create({
            data: {
              email: email3,
              name: name?.trim() || null,
              company: company?.trim() || null,
              role: role?.trim() || null,
              phone: phone?.trim() || null
            }
          });
          return { success: true };
        } catch (error47) {
          if (error47.code === "P2002") {
            return { success: true };
          }
          console.error("Waitlist error:", error47);
          return fail(500, { email: email3, name, company, role, phone, error: "Something went wrong. Please try again." });
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/_page.svelte.js
var page_svelte_exports = {};
__export(page_svelte_exports, {
  default: () => Page
});
var Page;
var init_page_svelte = __esm({
  ".svelte-kit/output/server/entries/pages/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { form } = $$props;
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      return `${$$result.head += `<!-- HEAD_svelte-lnxxrm_START -->${$$result.title = `<title>Spore CMMS - Maintenance Management Reimagined</title>`, ""}<meta name="description" content="Simple, mobile-first CMMS for property management. Real-time updates, multi-site support, and intuitive work order management."><!-- HEAD_svelte-lnxxrm_END -->`, ""}  <div class="min-h-screen bg-gradient-to-br from-spore-dark via-spore-steel to-spore-dark"> <section class="px-4 py-16 md:py-24"><div class="max-w-6xl mx-auto text-center"> <div class="flex items-center justify-center gap-3 mb-8"><span class="text-4xl md:text-5xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-r5ck25">SPORE</span> <span class="text-lg md:text-xl font-medium text-spore-steel uppercase tracking-widest bg-spore-cream/10 px-3 py-1 rounded-full" data-svelte-h="svelte-1jlm8b7">CMMS</span></div>  <h1 class="text-4xl md:text-6xl font-extrabold text-spore-cream mb-6 leading-tight">Simple CMMS for<br> <span class="text-spore-orange" data-svelte-h="svelte-1gb1p3h">Property Management</span></h1>  <p class="text-xl md:text-2xl text-spore-cream/80 mb-12 max-w-3xl mx-auto leading-relaxed" data-svelte-h="svelte-1uzcocz">Streamline maintenance operations with real-time updates, mobile-first design, and multi-site support. Join the future of maintenance.</p>  <div class="flex flex-col items-center justify-center w-full max-w-xl mx-auto">${form?.success ? `<div class="bg-spore-forest/30 border border-spore-forest text-spore-cream px-8 py-8 rounded-2xl w-full text-center shadow-lg backdrop-blur-sm"><div class="text-5xl mb-4" data-svelte-h="svelte-f3fw9j">\u2705</div> <h3 class="text-2xl font-bold mb-2" data-svelte-h="svelte-1ez1mau">You&#39;re on the list!</h3> <p class="text-spore-cream/70 text-lg" data-svelte-h="svelte-1mzcllk">We&#39;ll be in touch with your early access invite soon.</p></div>` : `<div class="bg-spore-white/5 border border-spore-cream/10 rounded-2xl p-6 w-full backdrop-blur-sm"><h3 class="text-spore-cream font-bold text-lg mb-4 text-left" data-svelte-h="svelte-qfkqiq">Request Early Access</h3> <form method="POST" action="?/joinWaitlist" class="space-y-4"><div class="grid grid-cols-1 sm:grid-cols-2 gap-4"><div class="text-left"><label for="name" class="block text-xs font-bold text-spore-cream/60 uppercase tracking-wide mb-1" data-svelte-h="svelte-7cqnz3">Name *</label> <input type="text" name="name" id="name" placeholder="John Doe" required${add_attribute("value", form?.name ?? "", 0)} class="w-full bg-spore-dark/50 border border-spore-cream/20 text-spore-cream placeholder-spore-cream/30 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-spore-orange transition-all"></div> <div class="text-left"><label for="company" class="block text-xs font-bold text-spore-cream/60 uppercase tracking-wide mb-1" data-svelte-h="svelte-85yvc1">Company</label> <input type="text" name="company" id="company" placeholder="Acme Properties"${add_attribute("value", form?.company ?? "", 0)} class="w-full bg-spore-dark/50 border border-spore-cream/20 text-spore-cream placeholder-spore-cream/30 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-spore-orange transition-all"></div></div> <div class="text-left"><label for="email" class="block text-xs font-bold text-spore-cream/60 uppercase tracking-wide mb-1" data-svelte-h="svelte-1ij4f1e">Work Email *</label> <input type="email" name="email" id="email" placeholder="john@example.com" required${add_attribute("value", form?.email ?? "", 0)} class="w-full bg-spore-dark/50 border border-spore-cream/20 text-spore-cream placeholder-spore-cream/30 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-spore-orange transition-all"></div> <div class="grid grid-cols-1 sm:grid-cols-2 gap-4"><div class="text-left"><label for="phone" class="block text-xs font-bold text-spore-cream/60 uppercase tracking-wide mb-1" data-svelte-h="svelte-pw66tu">Phone (Optional)</label> <input type="tel" name="phone" id="phone" placeholder="(555) 123-4567"${add_attribute("value", form?.phone ?? "", 0)} class="w-full bg-spore-dark/50 border border-spore-cream/20 text-spore-cream placeholder-spore-cream/30 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-spore-orange transition-all"></div> <div class="text-left"><label for="role" class="block text-xs font-bold text-spore-cream/60 uppercase tracking-wide mb-1" data-svelte-h="svelte-1icxtl8">Role (Optional)</label> <input type="text" name="role" id="role" placeholder="Facility Manager"${add_attribute("value", form?.role ?? "", 0)} class="w-full bg-spore-dark/50 border border-spore-cream/20 text-spore-cream placeholder-spore-cream/30 rounded-lg px-4 py-3 focus:outline-none focus:ring-2 focus:ring-spore-orange transition-all"></div></div> <button type="submit" ${""} class="w-full bg-spore-orange text-white px-8 py-4 rounded-xl font-bold text-lg hover:bg-spore-orange/90 focus:outline-none focus:ring-4 focus:ring-spore-orange/50 transition-all transform hover:scale-[1.02] shadow-lg disabled:opacity-50 disabled:hover:scale-100 mt-2">${escape("Request Early Access")}</button></form></div> ${form?.error ? `<p class="text-red-400 mt-3 text-sm font-medium bg-red-900/20 px-4 py-2 rounded-lg border border-red-500/20">${escape(form.error)}</p>` : ``} <div class="mt-8 flex flex-col sm:flex-row items-center gap-6 text-sm"><a href="/auth/login" class="text-spore-cream/60 hover:text-spore-orange font-medium transition-colors" data-svelte-h="svelte-7e2gus">Existing user? Sign in \u2192</a> <a href="#features" class="text-spore-cream/60 hover:text-spore-cream font-medium transition-colors" data-svelte-h="svelte-69mgbk">Learn more \u2193</a></div>`}</div></div></section>  <section id="features" class="px-4 py-20 bg-spore-steel/10 backdrop-blur-sm border-y border-spore-steel/20"><div class="max-w-6xl mx-auto"><h2 class="text-3xl md:text-4xl font-extrabold text-spore-cream text-center mb-16" data-svelte-h="svelte-mkle0w">Built for Property Teams</h2> <div class="grid md:grid-cols-3 gap-8"> <div class="bg-spore-dark/50 rounded-2xl p-8 border border-spore-steel/30 hover:border-spore-orange/50 transition-all hover:-translate-y-1"><div class="text-4xl mb-4 bg-spore-orange/10 w-16 h-16 rounded-full flex items-center justify-center" data-svelte-h="svelte-1vfkf70">\u{1F4F1}</div> <h3 class="text-xl font-bold text-spore-cream mb-3" data-svelte-h="svelte-xihcg">Mobile-First Design</h3> <p class="text-spore-cream/70 leading-relaxed" data-svelte-h="svelte-18m3aey">Work orders, updates, and communications work seamlessly on any device. Perfect for field teams who need to stay connected from anywhere.</p></div>  <div class="bg-spore-dark/50 rounded-2xl p-8 border border-spore-steel/30 hover:border-spore-orange/50 transition-all hover:-translate-y-1"><div class="text-4xl mb-4 bg-spore-orange/10 w-16 h-16 rounded-full flex items-center justify-center" data-svelte-h="svelte-2ir809">\u26A1</div> <h3 class="text-xl font-bold text-spore-cream mb-3" data-svelte-h="svelte-bzkxxr">Real-Time Updates</h3> <p class="text-spore-cream/70 leading-relaxed" data-svelte-h="svelte-vry7ce">Instant notifications when work orders are created, assigned, or completed. Keep your entire team in sync without constant check-ins.</p></div>  <div class="bg-spore-dark/50 rounded-2xl p-8 border border-spore-steel/30 hover:border-spore-orange/50 transition-all hover:-translate-y-1"><div class="text-4xl mb-4 bg-spore-orange/10 w-16 h-16 rounded-full flex items-center justify-center" data-svelte-h="svelte-phl768">\u{1F3E2}</div> <h3 class="text-xl font-bold text-spore-cream mb-3" data-svelte-h="svelte-tol3s5">Multi-Site Support</h3> <p class="text-spore-cream/70 leading-relaxed" data-svelte-h="svelte-31e08m">Manage multiple properties, buildings, and assets from a single dashboard. Organize by location with room-level tracking.</p></div></div></div></section>  <footer class="px-4 py-12 border-t border-spore-steel/20 bg-spore-dark"><div class="max-w-6xl mx-auto"><div class="flex flex-col md:flex-row justify-between items-center gap-4"><div class="flex items-center gap-2"><span class="text-xl font-extrabold text-spore-cream" data-svelte-h="svelte-1hc2kqz">SPORE</span> <span class="text-sm font-medium text-spore-steel uppercase tracking-widest" data-svelte-h="svelte-7f91ij">CMMS</span></div> <div class="text-sm text-spore-cream/40" data-svelte-h="svelte-11sormd">\xA9 2025 Spore Intelligent Systems. All rights reserved.</div></div></div></footer></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
  component: () => component3,
  fonts: () => fonts3,
  imports: () => imports3,
  index: () => index3,
  server: () => page_server_ts_exports,
  server_id: () => server_id2,
  stylesheets: () => stylesheets3
});
var index3, component_cache3, component3, server_id2, imports3, stylesheets3, fonts3;
var init__3 = __esm({
  ".svelte-kit/output/server/nodes/2.js"() {
    init_page_server_ts();
    index3 = 2;
    component3 = async () => component_cache3 ??= (await Promise.resolve().then(() => (init_page_svelte(), page_svelte_exports))).default;
    server_id2 = "src/routes/+page.server.ts";
    imports3 = ["_app/immutable/chunks/2.4b56285a.js", "_app/immutable/chunks/_page.a7320398.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets3 = [];
    fonts3 = [];
  }
});

// .svelte-kit/output/server/chunks/guards.js
function requireAuth(event) {
  if (!event.locals.user) {
    throw redirect(303, "/auth/login");
  }
}
function isAdmin(event) {
  return event.locals.user?.role === "ADMIN";
}
function isManagerOrAbove(event) {
  const role = event.locals.user?.role;
  return role === "ADMIN" || role === "MANAGER";
}
function canUpdateWorkOrder(userId, userRole, workOrderCreatedById, workOrderAssignedToId) {
  return userRole === "ADMIN" || userRole === "MANAGER" || userId === workOrderCreatedById || userId === workOrderAssignedToId;
}
function canAssignWorkOrder(userRole) {
  return userRole === "ADMIN" || userRole === "MANAGER";
}
function canDeleteWorkOrder(userRole) {
  return userRole === "ADMIN" || userRole === "MANAGER";
}
var init_guards = __esm({
  ".svelte-kit/output/server/chunks/guards.js"() {
    init_chunks();
  }
});

// node_modules/zod/v4/core/core.js
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init2(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = params?.Parent ? new Definition() : this;
    init2(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init2 });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}
var NEVER, $brand, $ZodAsyncError, $ZodEncodeError, globalConfig;
var init_core = __esm({
  "node_modules/zod/v4/core/core.js"() {
    NEVER = Object.freeze({
      status: "aborted"
    });
    $brand = Symbol("zod_brand");
    $ZodAsyncError = class extends Error {
      constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
      }
    };
    $ZodEncodeError = class extends Error {
      constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
      }
    };
    globalConfig = {};
  }
});

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array3, separator = "|") {
  return array3.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match?.[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key2, getter) {
  let value = void 0;
  Object.defineProperty(object2, key2, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key2, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key2) => acc?.[key2], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key2) => promisesObj[key2]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars3 = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars3[Math.floor(Math.random() * chars3.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
function isPlainObject(o2) {
  if (isObject(o2) === false)
    return false;
  const ctor = o2.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o2) {
  if (isPlainObject(o2))
    return { ...o2 };
  if (Array.isArray(o2))
    return [...o2];
  return o2;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key2 in data) {
    if (Object.prototype.hasOwnProperty.call(data, key2)) {
      keyCount++;
    }
  }
  return keyCount;
}
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key2 in mask) {
        if (!(key2 in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key2}"`);
        }
        if (!mask[key2])
          continue;
        newShape[key2] = currDef.shape[key2];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key2 in mask) {
        if (!(key2 in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key2}"`);
        }
        if (!mask[key2])
          continue;
        delete newShape[key2];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key2 in mask) {
          if (!(key2 in oldShape)) {
            throw new Error(`Unrecognized key: "${key2}"`);
          }
          if (!mask[key2])
            continue;
          shape[key2] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key2]
          }) : oldShape[key2];
        }
      } else {
        for (const key2 in oldShape) {
          shape[key2] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key2]
          }) : oldShape[key2];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key2 in mask) {
          if (!(key2 in shape)) {
            throw new Error(`Unrecognized key: "${key2}"`);
          }
          if (!mask[key2])
            continue;
          shape[key2] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key2]
          });
        }
      } else {
        for (const key2 in oldShape) {
          shape[key2] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key2]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base644) {
  const binaryString = atob(base644);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base644 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base644.length % 4) % 4);
  return base64ToUint8Array(base644 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var EVALUATING, captureStackTrace, allowsEval, getParsedType, propertyKeyTypes, primitiveTypes, NUMBER_FORMAT_RANGES, BIGINT_FORMAT_RANGES, Class;
var init_util = __esm({
  "node_modules/zod/v4/core/util.js"() {
    EVALUATING = Symbol("evaluating");
    captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
    };
    allowsEval = cached(() => {
      if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
      }
      try {
        const F = Function;
        new F("");
        return true;
      } catch (_) {
        return false;
      }
    });
    getParsedType = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return Number.isNaN(data) ? "nan" : "number";
        case "boolean":
          return "boolean";
        case "function":
          return "function";
        case "bigint":
          return "bigint";
        case "symbol":
          return "symbol";
        case "object":
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return "promise";
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return "map";
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return "set";
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return "date";
          }
          if (typeof File !== "undefined" && data instanceof File) {
            return "file";
          }
          return "object";
        default:
          throw new Error(`Unknown data type: ${t2}`);
      }
    };
    propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
    primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
    NUMBER_FORMAT_RANGES = {
      safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
      int32: [-2147483648, 2147483647],
      uint32: [0, 4294967295],
      float32: [-34028234663852886e22, 34028234663852886e22],
      float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
    };
    BIGINT_FORMAT_RANGES = {
      int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
      uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
    };
    Class = class {
      constructor(..._args) {
      }
    };
  }
});

// node_modules/zod/v4/core/errors.js
function flattenError(error47, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error47.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error47, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error48) => {
    for (const issue2 of error48.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error47);
  return fieldErrors;
}
function treeifyError(error47, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error48, path = []) => {
    var _a2, _b;
    for (const issue2 of error48.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error47);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error47) {
  const lines = [];
  const issues = [...error47.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(`\u2716 ${issue2.message}`);
    if (issue2.path?.length)
      lines.push(`  \u2192 at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}
var initializer, $ZodError, $ZodRealError;
var init_errors = __esm({
  "node_modules/zod/v4/core/errors.js"() {
    init_core();
    init_util();
    initializer = (inst, def) => {
      inst.name = "$ZodError";
      Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false
      });
      Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false
      });
      inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
      Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false
      });
    };
    $ZodError = $constructor("$ZodError", initializer);
    $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
  }
});

// node_modules/zod/v4/core/parse.js
var _parse, parse3, _parseAsync, parseAsync, _safeParse, safeParse, _safeParseAsync, safeParseAsync, _encode, encode2, _decode, decode, _encodeAsync, encodeAsync, _decodeAsync, decodeAsync, _safeEncode, safeEncode, _safeDecode, safeDecode, _safeEncodeAsync, safeEncodeAsync, _safeDecodeAsync, safeDecodeAsync;
var init_parse2 = __esm({
  "node_modules/zod/v4/core/parse.js"() {
    init_core();
    init_errors();
    init_util();
    _parse = (_Err) => (schema, value, _ctx, _params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      if (result.issues.length) {
        const e3 = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e3, _params?.callee);
        throw e3;
      }
      return result.value;
    };
    parse3 = /* @__PURE__ */ _parse($ZodRealError);
    _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      if (result.issues.length) {
        const e3 = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e3, params?.callee);
        throw e3;
      }
      return result.value;
    };
    parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
    _safeParse = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
      const result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise) {
        throw new $ZodAsyncError();
      }
      return result.issues.length ? {
        success: false,
        error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
    _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
      let result = schema._zod.run({ value, issues: [] }, ctx);
      if (result instanceof Promise)
        result = await result;
      return result.issues.length ? {
        success: false,
        error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
      } : { success: true, data: result.value };
    };
    safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);
    _encode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parse(_Err)(schema, value, ctx);
    };
    encode2 = /* @__PURE__ */ _encode($ZodRealError);
    _decode = (_Err) => (schema, value, _ctx) => {
      return _parse(_Err)(schema, value, _ctx);
    };
    decode = /* @__PURE__ */ _decode($ZodRealError);
    _encodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _parseAsync(_Err)(schema, value, ctx);
    };
    encodeAsync = /* @__PURE__ */ _encodeAsync($ZodRealError);
    _decodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _parseAsync(_Err)(schema, value, _ctx);
    };
    decodeAsync = /* @__PURE__ */ _decodeAsync($ZodRealError);
    _safeEncode = (_Err) => (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParse(_Err)(schema, value, ctx);
    };
    safeEncode = /* @__PURE__ */ _safeEncode($ZodRealError);
    _safeDecode = (_Err) => (schema, value, _ctx) => {
      return _safeParse(_Err)(schema, value, _ctx);
    };
    safeDecode = /* @__PURE__ */ _safeDecode($ZodRealError);
    _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
      const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
      return _safeParseAsync(_Err)(schema, value, ctx);
    };
    safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync($ZodRealError);
    _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
      return _safeParseAsync(_Err)(schema, value, _ctx);
    };
    safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync($ZodRealError);
  }
});

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base642,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
function emoji() {
  return new RegExp(_emoji, "u");
}
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var cuid, cuid2, ulid, xid, ksuid, nanoid, duration, extendedDuration, guid, uuid, uuid4, uuid6, uuid7, email, html5Email, rfc5322Email, unicodeEmail, idnEmail, browserEmail, _emoji, ipv4, ipv6, mac, cidrv4, cidrv6, base642, base64url, hostname, domain, e164, dateSource, date, string, bigint, integer, number, boolean, _null, _undefined, lowercase, uppercase, hex, md5_hex, md5_base64, md5_base64url, sha1_hex, sha1_base64, sha1_base64url, sha256_hex, sha256_base64, sha256_base64url, sha384_hex, sha384_base64, sha384_base64url, sha512_hex, sha512_base64, sha512_base64url;
var init_regexes = __esm({
  "node_modules/zod/v4/core/regexes.js"() {
    init_util();
    cuid = /^[cC][^\s-]{8,}$/;
    cuid2 = /^[0-9a-z]+$/;
    ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
    xid = /^[0-9a-vA-V]{20}$/;
    ksuid = /^[A-Za-z0-9]{27}$/;
    nanoid = /^[a-zA-Z0-9_-]{21}$/;
    duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
    extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
    uuid = (version2) => {
      if (!version2)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
      return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
    };
    uuid4 = /* @__PURE__ */ uuid(4);
    uuid6 = /* @__PURE__ */ uuid(6);
    uuid7 = /* @__PURE__ */ uuid(7);
    email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
    html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
    unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
    idnEmail = unicodeEmail;
    browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
    _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
    mac = (delimiter) => {
      const escapedDelim = escapeRegex(delimiter ?? ":");
      return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
    };
    cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
    cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base642 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
    base64url = /^[A-Za-z0-9_-]*$/;
    hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
    domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
    e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
    dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
    date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
    string = (params) => {
      const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
      return new RegExp(`^${regex}$`);
    };
    bigint = /^-?\d+n?$/;
    integer = /^-?\d+$/;
    number = /^-?\d+(?:\.\d+)?/;
    boolean = /^(?:true|false)$/i;
    _null = /^null$/i;
    _undefined = /^undefined$/i;
    lowercase = /^[^A-Z]*$/;
    uppercase = /^[^a-z]*$/;
    hex = /^[0-9a-fA-F]*$/;
    md5_hex = /^[0-9a-fA-F]{32}$/;
    md5_base64 = /* @__PURE__ */ fixedBase64(22, "==");
    md5_base64url = /* @__PURE__ */ fixedBase64url(22);
    sha1_hex = /^[0-9a-fA-F]{40}$/;
    sha1_base64 = /* @__PURE__ */ fixedBase64(27, "=");
    sha1_base64url = /* @__PURE__ */ fixedBase64url(27);
    sha256_hex = /^[0-9a-fA-F]{64}$/;
    sha256_base64 = /* @__PURE__ */ fixedBase64(43, "=");
    sha256_base64url = /* @__PURE__ */ fixedBase64url(43);
    sha384_hex = /^[0-9a-fA-F]{96}$/;
    sha384_base64 = /* @__PURE__ */ fixedBase64(64, "");
    sha384_base64url = /* @__PURE__ */ fixedBase64url(64);
    sha512_hex = /^[0-9a-fA-F]{128}$/;
    sha512_base64 = /* @__PURE__ */ fixedBase64(86, "==");
    sha512_base64url = /* @__PURE__ */ fixedBase64url(86);
  }
});

// node_modules/zod/v4/core/checks.js
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheck, numericOriginMap, $ZodCheckLessThan, $ZodCheckGreaterThan, $ZodCheckMultipleOf, $ZodCheckNumberFormat, $ZodCheckBigIntFormat, $ZodCheckMaxSize, $ZodCheckMinSize, $ZodCheckSizeEquals, $ZodCheckMaxLength, $ZodCheckMinLength, $ZodCheckLengthEquals, $ZodCheckStringFormat, $ZodCheckRegex, $ZodCheckLowerCase, $ZodCheckUpperCase, $ZodCheckIncludes, $ZodCheckStartsWith, $ZodCheckEndsWith, $ZodCheckProperty, $ZodCheckMimeType, $ZodCheckOverwrite;
var init_checks = __esm({
  "node_modules/zod/v4/core/checks.js"() {
    init_core();
    init_regexes();
    init_util();
    $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
      var _a2;
      inst._zod ?? (inst._zod = {});
      inst._zod.def = def;
      (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
    });
    numericOriginMap = {
      number: "number",
      bigint: "bigint",
      object: "date"
    };
    $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
          if (def.inclusive)
            bag.maximum = def.value;
          else
            bag.exclusiveMaximum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
      $ZodCheck.init(inst, def);
      const origin = numericOriginMap[typeof def.value];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
          if (def.inclusive)
            bag.minimum = def.value;
          else
            bag.exclusiveMinimum = def.value;
        }
      });
      inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
          return;
        }
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.value,
          input: payload.value,
          inclusive: def.inclusive,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        var _a2;
        (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
      });
      inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
          throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
          return;
        payload.issues.push({
          origin: typeof payload.value,
          code: "not_multiple_of",
          divisor: def.value,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      def.format = def.format || "float64";
      const isInt = def.format?.includes("int");
      const origin = isInt ? "int" : "number";
      const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
          bag.pattern = integer;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
          if (!Number.isInteger(input)) {
            payload.issues.push({
              expected: origin,
              format: def.format,
              code: "invalid_type",
              continue: false,
              input,
              inst
            });
            return;
          }
          if (!Number.isSafeInteger(input)) {
            if (input > 0) {
              payload.issues.push({
                input,
                code: "too_big",
                maximum: Number.MAX_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            } else {
              payload.issues.push({
                input,
                code: "too_small",
                minimum: Number.MIN_SAFE_INTEGER,
                note: "Integers must be within the safe integer range.",
                inst,
                origin,
                continue: !def.abort
              });
            }
            return;
          }
        }
        if (input < minimum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "number",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
      $ZodCheck.init(inst, def);
      const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        if (input < minimum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_small",
            minimum,
            inclusive: true,
            inst,
            continue: !def.abort
          });
        }
        if (input > maximum) {
          payload.issues.push({
            origin: "bigint",
            input,
            code: "too_big",
            maximum,
            inst
          });
        }
      };
    });
    $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size <= def.maximum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size >= def.minimum)
          return;
        payload.issues.push({
          origin: getSizableOrigin(input),
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.size !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.size;
        bag.maximum = def.size;
        bag.size = def.size;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const size = input.size;
        if (size === def.size)
          return;
        const tooBig = size > def.size;
        payload.issues.push({
          origin: getSizableOrigin(input),
          ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
        if (def.maximum < curr)
          inst2._zod.bag.maximum = def.maximum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_big",
          maximum: def.maximum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
        if (def.minimum > curr)
          inst2._zod.bag.minimum = def.minimum;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
          return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
          origin,
          code: "too_small",
          minimum: def.minimum,
          inclusive: true,
          input,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
      var _a2;
      $ZodCheck.init(inst, def);
      (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== void 0;
      });
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
      });
      inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
          return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
          origin,
          ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
          inclusive: true,
          exact: true,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
      var _a2, _b;
      $ZodCheck.init(inst, def);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
          bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
          bag.patterns.add(def.pattern);
        }
      });
      if (def.pattern)
        (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
          def.pattern.lastIndex = 0;
          if (def.pattern.test(payload.value))
            return;
          payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: def.format,
            input: payload.value,
            ...def.pattern ? { pattern: def.pattern.toString() } : {},
            inst,
            continue: !def.abort
          });
        });
      else
        (_b = inst._zod).check ?? (_b.check = () => {
        });
    });
    $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "regex",
          input: payload.value,
          pattern: def.pattern.toString(),
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
      def.pattern ?? (def.pattern = lowercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
      def.pattern ?? (def.pattern = uppercase);
      $ZodCheckStringFormat.init(inst, def);
    });
    $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
      $ZodCheck.init(inst, def);
      const escapedRegex = escapeRegex(def.includes);
      const pattern2 = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
      def.pattern = pattern2;
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern2);
      });
      inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "includes",
          includes: def.includes,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern2 = new RegExp(`^${escapeRegex(def.prefix)}.*`);
      def.pattern ?? (def.pattern = pattern2);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern2);
      });
      inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "starts_with",
          prefix: def.prefix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
      $ZodCheck.init(inst, def);
      const pattern2 = new RegExp(`.*${escapeRegex(def.suffix)}$`);
      def.pattern ?? (def.pattern = pattern2);
      inst._zod.onattach.push((inst2) => {
        const bag = inst2._zod.bag;
        bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
        bag.patterns.add(pattern2);
      });
      inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
          return;
        payload.issues.push({
          origin: "string",
          code: "invalid_format",
          format: "ends_with",
          suffix: def.suffix,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        const result = def.schema._zod.run({
          value: payload.value[def.property],
          issues: []
        }, {});
        if (result instanceof Promise) {
          return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
        }
        handleCheckPropertyResult(result, payload, def.property);
        return;
      };
    });
    $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
      $ZodCheck.init(inst, def);
      const mimeSet = new Set(def.mime);
      inst._zod.onattach.push((inst2) => {
        inst2._zod.bag.mime = def.mime;
      });
      inst._zod.check = (payload) => {
        if (mimeSet.has(payload.value.type))
          return;
        payload.issues.push({
          code: "invalid_value",
          values: def.mime,
          input: payload.value.type,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
      $ZodCheck.init(inst, def);
      inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
      };
    });
  }
});

// node_modules/zod/v4/core/doc.js
var Doc;
var init_doc = __esm({
  "node_modules/zod/v4/core/doc.js"() {
    Doc = class {
      constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
          this.args = args;
      }
      indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
      }
      write(arg) {
        if (typeof arg === "function") {
          arg(this, { execution: "sync" });
          arg(this, { execution: "async" });
          return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
          this.content.push(line);
        }
      }
      compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        return new F(...args, lines.join("\n"));
      }
    };
  }
});

// node_modules/zod/v4/core/versions.js
var version;
var init_versions = __esm({
  "node_modules/zod/v4/core/versions.js"() {
    version = {
      major: 4,
      minor: 1,
      patch: 13
    };
  }
});

// node_modules/zod/v4/core/schemas.js
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base644 = data.replace(/[-_]/g, (c2) => c2 === "-" ? "+" : "/");
  const padded = base644.padEnd(Math.ceil(base644.length / 4) * 4, "=");
  return isValidBase64(padded);
}
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
function handleArrayResult(result, final, index24) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index24, result.issues));
  }
  final.value[index24] = result.value;
}
function handlePropertyResult(result, final, key2, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key2, result.issues));
  }
  if (result.value === void 0) {
    if (key2 in input) {
      final.value[key2] = void 0;
    }
  } else {
    final.value[key2] = result.value;
  }
}
function normalizeDef(def) {
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t2 = _catchall.def.type;
  for (const key2 in input) {
    if (keySet.has(key2))
      continue;
    if (t2 === "never") {
      unrecognized.push(key2);
      continue;
    }
    const r3 = _catchall.run({ value: input[key2], issues: [] }, ctx);
    if (r3 instanceof Promise) {
      proms.push(r3.then((r4) => handlePropertyResult(r4, payload, key2, input)));
    } else {
      handlePropertyResult(r3, payload, key2, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r3) => !aborted(r3));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key2) => bKeys.indexOf(key2) !== -1);
    const newObj = { ...a, ...b };
    for (const key2 of sharedKeys) {
      const sharedValue = mergeValues(a[key2], b[key2]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key2, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key2] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index24 = 0; index24 < a.length; index24++) {
      const itemA = a[index24];
      const itemB = b[index24];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index24, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
function handleTupleResult(result, final, index24) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index24, result.issues));
  }
  final.value[index24] = result.value;
}
function handleMapResult(keyResult, valueResult, final, key2, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key2)) {
      final.issues.push(...prefixIssues(key2, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key2)) {
      final.issues.push(...prefixIssues(key2, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key: key2,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}
var $ZodType, $ZodString, $ZodStringFormat, $ZodGUID, $ZodUUID, $ZodEmail, $ZodURL, $ZodEmoji, $ZodNanoID, $ZodCUID, $ZodCUID2, $ZodULID, $ZodXID, $ZodKSUID, $ZodISODateTime, $ZodISODate, $ZodISOTime, $ZodISODuration, $ZodIPv4, $ZodIPv6, $ZodMAC, $ZodCIDRv4, $ZodCIDRv6, $ZodBase64, $ZodBase64URL, $ZodE164, $ZodJWT, $ZodCustomStringFormat, $ZodNumber, $ZodNumberFormat, $ZodBoolean, $ZodBigInt, $ZodBigIntFormat, $ZodSymbol, $ZodUndefined, $ZodNull, $ZodAny, $ZodUnknown, $ZodNever, $ZodVoid, $ZodDate, $ZodArray, $ZodObject, $ZodObjectJIT, $ZodUnion, $ZodDiscriminatedUnion, $ZodIntersection, $ZodTuple, $ZodRecord, $ZodMap, $ZodSet, $ZodEnum, $ZodLiteral, $ZodFile, $ZodTransform, $ZodOptional, $ZodNullable, $ZodDefault, $ZodPrefault, $ZodNonOptional, $ZodSuccess, $ZodCatch, $ZodNaN, $ZodPipe, $ZodCodec, $ZodReadonly, $ZodTemplateLiteral, $ZodFunction, $ZodPromise, $ZodLazy, $ZodCustom;
var init_schemas = __esm({
  "node_modules/zod/v4/core/schemas.js"() {
    init_checks();
    init_core();
    init_doc();
    init_parse2();
    init_regexes();
    init_util();
    init_versions();
    init_util();
    $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
      var _a2;
      inst ?? (inst = {});
      inst._zod.def = def;
      inst._zod.bag = inst._zod.bag || {};
      inst._zod.version = version;
      const checks = [...inst._zod.def.checks ?? []];
      if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
      }
      for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
          fn(inst);
        }
      }
      if (checks.length === 0) {
        (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
        inst._zod.deferred?.push(() => {
          inst._zod.run = inst._zod.parse;
        });
      } else {
        const runChecks = (payload, checks2, ctx) => {
          let isAborted = aborted(payload);
          let asyncResult;
          for (const ch of checks2) {
            if (ch._zod.def.when) {
              const shouldRun = ch._zod.def.when(payload);
              if (!shouldRun)
                continue;
            } else if (isAborted) {
              continue;
            }
            const currLen = payload.issues.length;
            const _ = ch._zod.check(payload);
            if (_ instanceof Promise && ctx?.async === false) {
              throw new $ZodAsyncError();
            }
            if (asyncResult || _ instanceof Promise) {
              asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                await _;
                const nextLen = payload.issues.length;
                if (nextLen === currLen)
                  return;
                if (!isAborted)
                  isAborted = aborted(payload, currLen);
              });
            } else {
              const nextLen = payload.issues.length;
              if (nextLen === currLen)
                continue;
              if (!isAborted)
                isAborted = aborted(payload, currLen);
            }
          }
          if (asyncResult) {
            return asyncResult.then(() => {
              return payload;
            });
          }
          return payload;
        };
        const handleCanaryResult = (canary, payload, ctx) => {
          if (aborted(canary)) {
            canary.aborted = true;
            return canary;
          }
          const checkResult = runChecks(payload, checks, ctx);
          if (checkResult instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
          }
          return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
          if (ctx.skipChecks) {
            return inst._zod.parse(payload, ctx);
          }
          if (ctx.direction === "backward") {
            const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
            if (canary instanceof Promise) {
              return canary.then((canary2) => {
                return handleCanaryResult(canary2, payload, ctx);
              });
            }
            return handleCanaryResult(canary, payload, ctx);
          }
          const result = inst._zod.parse(payload, ctx);
          if (result instanceof Promise) {
            if (ctx.async === false)
              throw new $ZodAsyncError();
            return result.then((result2) => runChecks(result2, checks, ctx));
          }
          return runChecks(result, checks, ctx);
        };
      }
      inst["~standard"] = {
        validate: (value) => {
          try {
            const r3 = safeParse(inst, value);
            return r3.success ? { value: r3.data } : { issues: r3.error?.issues };
          } catch (_) {
            return safeParseAsync(inst, value).then((r3) => r3.success ? { value: r3.data } : { issues: r3.error?.issues });
          }
        },
        vendor: "zod",
        version: 1
      };
    });
    $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
      inst._zod.parse = (payload, _) => {
        if (def.coerce)
          try {
            payload.value = String(payload.value);
          } catch (_2) {
          }
        if (typeof payload.value === "string")
          return payload;
        payload.issues.push({
          expected: "string",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
      $ZodCheckStringFormat.init(inst, def);
      $ZodString.init(inst, def);
    });
    $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
      def.pattern ?? (def.pattern = guid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
      if (def.version) {
        const versionMap = {
          v1: 1,
          v2: 2,
          v3: 3,
          v4: 4,
          v5: 5,
          v6: 6,
          v7: 7,
          v8: 8
        };
        const v = versionMap[def.version];
        if (v === void 0)
          throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
      } else
        def.pattern ?? (def.pattern = uuid());
      $ZodStringFormat.init(inst, def);
    });
    $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
      def.pattern ?? (def.pattern = email);
      $ZodStringFormat.init(inst, def);
    });
    $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        try {
          const trimmed = payload.value.trim();
          const url2 = new URL(trimmed);
          if (def.hostname) {
            def.hostname.lastIndex = 0;
            if (!def.hostname.test(url2.hostname)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid hostname",
                pattern: def.hostname.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.protocol) {
            def.protocol.lastIndex = 0;
            if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                note: "Invalid protocol",
                pattern: def.protocol.source,
                input: payload.value,
                inst,
                continue: !def.abort
              });
            }
          }
          if (def.normalize) {
            payload.value = url2.href;
          } else {
            payload.value = trimmed;
          }
          return;
        } catch (_) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
      def.pattern ?? (def.pattern = emoji());
      $ZodStringFormat.init(inst, def);
    });
    $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
      def.pattern ?? (def.pattern = nanoid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
      def.pattern ?? (def.pattern = cuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
      def.pattern ?? (def.pattern = cuid2);
      $ZodStringFormat.init(inst, def);
    });
    $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
      def.pattern ?? (def.pattern = ulid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
      def.pattern ?? (def.pattern = xid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
      def.pattern ?? (def.pattern = ksuid);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
      def.pattern ?? (def.pattern = datetime(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
      def.pattern ?? (def.pattern = date);
      $ZodStringFormat.init(inst, def);
    });
    $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
      def.pattern ?? (def.pattern = time(def));
      $ZodStringFormat.init(inst, def);
    });
    $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
      def.pattern ?? (def.pattern = duration);
      $ZodStringFormat.init(inst, def);
    });
    $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
      def.pattern ?? (def.pattern = ipv4);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv4`;
    });
    $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
      def.pattern ?? (def.pattern = ipv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `ipv6`;
      inst._zod.check = (payload) => {
        try {
          new URL(`http://[${payload.value}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "ipv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
      def.pattern ?? (def.pattern = mac(def.delimiter));
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.format = `mac`;
    });
    $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv4);
      $ZodStringFormat.init(inst, def);
    });
    $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
      def.pattern ?? (def.pattern = cidrv6);
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
          if (parts.length !== 2)
            throw new Error();
          const [address, prefix] = parts;
          if (!prefix)
            throw new Error();
          const prefixNum = Number(prefix);
          if (`${prefixNum}` !== prefix)
            throw new Error();
          if (prefixNum < 0 || prefixNum > 128)
            throw new Error();
          new URL(`http://[${address}]`);
        } catch {
          payload.issues.push({
            code: "invalid_format",
            format: "cidrv6",
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      };
    });
    $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
      def.pattern ?? (def.pattern = base642);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64";
      inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
      def.pattern ?? (def.pattern = base64url);
      $ZodStringFormat.init(inst, def);
      inst._zod.bag.contentEncoding = "base64url";
      inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "base64url",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
      def.pattern ?? (def.pattern = e164);
      $ZodStringFormat.init(inst, def);
    });
    $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: "jwt",
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      inst._zod.check = (payload) => {
        if (def.fn(payload.value))
          return;
        payload.issues.push({
          code: "invalid_format",
          format: def.format,
          input: payload.value,
          inst,
          continue: !def.abort
        });
      };
    });
    $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = inst._zod.bag.pattern ?? number;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Number(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
          return payload;
        }
        const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
        payload.issues.push({
          expected: "number",
          code: "invalid_type",
          input,
          inst,
          ...received ? { received } : {}
        });
        return payload;
      };
    });
    $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
      $ZodCheckNumberFormat.init(inst, def);
      $ZodNumber.init(inst, def);
    });
    $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = boolean;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = Boolean(payload.value);
          } catch (_) {
          }
        const input = payload.value;
        if (typeof input === "boolean")
          return payload;
        payload.issues.push({
          expected: "boolean",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = bigint;
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
          try {
            payload.value = BigInt(payload.value);
          } catch (_) {
          }
        if (typeof payload.value === "bigint")
          return payload;
        payload.issues.push({
          expected: "bigint",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
      $ZodCheckBigIntFormat.init(inst, def);
      $ZodBigInt.init(inst, def);
    });
    $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "symbol")
          return payload;
        payload.issues.push({
          expected: "symbol",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _undefined;
      inst._zod.values = /* @__PURE__ */ new Set([void 0]);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "undefined",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.pattern = _null;
      inst._zod.values = /* @__PURE__ */ new Set([null]);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input === null)
          return payload;
        payload.issues.push({
          expected: "null",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload) => payload;
    });
    $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
          expected: "never",
          code: "invalid_type",
          input: payload.value,
          inst
        });
        return payload;
      };
    });
    $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (typeof input === "undefined")
          return payload;
        payload.issues.push({
          expected: "void",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (def.coerce) {
          try {
            payload.value = new Date(payload.value);
          } catch (_err) {
          }
        }
        const input = payload.value;
        const isDate = input instanceof Date;
        const isValidDate = isDate && !Number.isNaN(input.getTime());
        if (isValidDate)
          return payload;
        payload.issues.push({
          expected: "date",
          code: "invalid_type",
          input,
          ...isDate ? { received: "Invalid Date" } : {},
          inst
        });
        return payload;
      };
    });
    $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            expected: "array",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
          const item = input[i];
          const result = def.element._zod.run({
            value: item,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
          } else {
            handleArrayResult(result, payload, i);
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
      $ZodType.init(inst, def);
      const desc = Object.getOwnPropertyDescriptor(def, "shape");
      if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
          get: () => {
            const newSh = { ...sh };
            Object.defineProperty(def, "shape", {
              value: newSh
            });
            return newSh;
          }
        });
      }
      const _normalized = cached(() => normalizeDef(def));
      defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key2 in shape) {
          const field = shape[key2]._zod;
          if (field.values) {
            propValues[key2] ?? (propValues[key2] = /* @__PURE__ */ new Set());
            for (const v of field.values)
              propValues[key2].add(v);
          }
        }
        return propValues;
      });
      const isObject2 = isObject;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject2(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key2 of value.keys) {
          const el = shape[key2];
          const r3 = el._zod.run({ value: input[key2], issues: [] }, ctx);
          if (r3 instanceof Promise) {
            proms.push(r3.then((r4) => handlePropertyResult(r4, payload, key2, input)));
          } else {
            handlePropertyResult(r3, payload, key2, input);
          }
        }
        if (!catchall) {
          return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
      };
    });
    $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
      $ZodObject.init(inst, def);
      const superParse = inst._zod.parse;
      const _normalized = cached(() => normalizeDef(def));
      const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key2) => {
          const k = esc(key2);
          return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = /* @__PURE__ */ Object.create(null);
        let counter = 0;
        for (const key2 of normalized.keys) {
          ids[key2] = `key_${counter++}`;
        }
        doc.write(`const newResult = {};`);
        for (const key2 of normalized.keys) {
          const id = ids[key2];
          const k = esc(key2);
          doc.write(`const ${id} = ${parseStr(key2)};`);
          doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
      };
      let fastpass;
      const isObject2 = isObject;
      const jit = !globalConfig.jitless;
      const allowsEval2 = allowsEval;
      const fastEnabled = jit && allowsEval2.value;
      const catchall = def.catchall;
      let value;
      inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject2(input)) {
          payload.issues.push({
            expected: "object",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
          if (!fastpass)
            fastpass = generateFastpass(def.shape);
          payload = fastpass(payload, ctx);
          if (!catchall)
            return payload;
          return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
      };
    });
    $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.options.some((o2) => o2._zod.optin === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "optout", () => def.options.some((o2) => o2._zod.optout === "optional") ? "optional" : void 0);
      defineLazy(inst._zod, "values", () => {
        if (def.options.every((o2) => o2._zod.values)) {
          return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o2) => o2._zod.pattern)) {
          const patterns = def.options.map((o2) => o2._zod.pattern);
          return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return void 0;
      });
      const single = def.options.length === 1;
      const first = def.options[0]._zod.run;
      inst._zod.parse = (payload, ctx) => {
        if (single) {
          return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
          const result = option._zod.run({
            value: payload.value,
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            results.push(result);
            async = true;
          } else {
            if (result.issues.length === 0)
              return result;
            results.push(result);
          }
        }
        if (!async)
          return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results2) => {
          return handleUnionResults(results2, payload, inst, ctx);
        });
      };
    });
    $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      const _super = inst._zod.parse;
      defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
          const pv = option._zod.propValues;
          if (!pv || Object.keys(pv).length === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
          for (const [k, v] of Object.entries(pv)) {
            if (!propValues[k])
              propValues[k] = /* @__PURE__ */ new Set();
            for (const val of v) {
              propValues[k].add(val);
            }
          }
        }
        return propValues;
      });
      const disc = cached(() => {
        const opts = def.options;
        const map2 = /* @__PURE__ */ new Map();
        for (const o2 of opts) {
          const values = o2._zod.propValues?.[def.discriminator];
          if (!values || values.size === 0)
            throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o2)}"`);
          for (const v of values) {
            if (map2.has(v)) {
              throw new Error(`Duplicate discriminator value "${String(v)}"`);
            }
            map2.set(v, o2);
          }
        }
        return map2;
      });
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject(input)) {
          payload.issues.push({
            code: "invalid_type",
            expected: "object",
            input,
            inst
          });
          return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
          return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
          return _super(payload, ctx);
        }
        payload.issues.push({
          code: "invalid_union",
          errors: [],
          note: "No matching discriminator",
          discriminator: def.discriminator,
          input,
          path: [def.discriminator],
          inst
        });
        return payload;
      };
    });
    $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
          return Promise.all([left, right]).then(([left2, right2]) => {
            return handleIntersectionResults(payload, left2, right2);
          });
        }
        return handleIntersectionResults(payload, left, right);
      };
    });
    $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
      $ZodType.init(inst, def);
      const items = def.items;
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
          payload.issues.push({
            input,
            inst,
            expected: "tuple",
            code: "invalid_type"
          });
          return payload;
        }
        payload.value = [];
        const proms = [];
        const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
        const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
        if (!def.rest) {
          const tooBig = input.length > items.length;
          const tooSmall = input.length < optStart - 1;
          if (tooBig || tooSmall) {
            payload.issues.push({
              ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
              input,
              inst,
              origin: "array"
            });
            return payload;
          }
        }
        let i = -1;
        for (const item of items) {
          i++;
          if (i >= input.length) {
            if (i >= optStart)
              continue;
          }
          const result = item._zod.run({
            value: input[i],
            issues: []
          }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
          } else {
            handleTupleResult(result, payload, i);
          }
        }
        if (def.rest) {
          const rest = input.slice(items.length);
          for (const el of rest) {
            i++;
            const result = def.rest._zod.run({
              value: el,
              issues: []
            }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
            } else {
              handleTupleResult(result, payload, i);
            }
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
          payload.issues.push({
            expected: "record",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        const values = def.keyType._zod.values;
        if (values) {
          payload.value = {};
          const recordKeys = /* @__PURE__ */ new Set();
          for (const key2 of values) {
            if (typeof key2 === "string" || typeof key2 === "number" || typeof key2 === "symbol") {
              recordKeys.add(typeof key2 === "number" ? key2.toString() : key2);
              const result = def.valueType._zod.run({ value: input[key2], issues: [] }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result2) => {
                  if (result2.issues.length) {
                    payload.issues.push(...prefixIssues(key2, result2.issues));
                  }
                  payload.value[key2] = result2.value;
                }));
              } else {
                if (result.issues.length) {
                  payload.issues.push(...prefixIssues(key2, result.issues));
                }
                payload.value[key2] = result.value;
              }
            }
          }
          let unrecognized;
          for (const key2 in input) {
            if (!recordKeys.has(key2)) {
              unrecognized = unrecognized ?? [];
              unrecognized.push(key2);
            }
          }
          if (unrecognized && unrecognized.length > 0) {
            payload.issues.push({
              code: "unrecognized_keys",
              input,
              inst,
              keys: unrecognized
            });
          }
        } else {
          payload.value = {};
          for (const key2 of Reflect.ownKeys(input)) {
            if (key2 === "__proto__")
              continue;
            const keyResult = def.keyType._zod.run({ value: key2, issues: [] }, ctx);
            if (keyResult instanceof Promise) {
              throw new Error("Async schemas not supported in object keys currently");
            }
            if (keyResult.issues.length) {
              payload.issues.push({
                code: "invalid_key",
                origin: "record",
                issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                input: key2,
                path: [key2],
                inst
              });
              payload.value[keyResult.value] = keyResult.value;
              continue;
            }
            const result = def.valueType._zod.run({ value: input[key2], issues: [] }, ctx);
            if (result instanceof Promise) {
              proms.push(result.then((result2) => {
                if (result2.issues.length) {
                  payload.issues.push(...prefixIssues(key2, result2.issues));
                }
                payload.value[keyResult.value] = result2.value;
              }));
            } else {
              if (result.issues.length) {
                payload.issues.push(...prefixIssues(key2, result.issues));
              }
              payload.value[keyResult.value] = result.value;
            }
          }
        }
        if (proms.length) {
          return Promise.all(proms).then(() => payload);
        }
        return payload;
      };
    });
    $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Map)) {
          payload.issues.push({
            expected: "map",
            code: "invalid_type",
            input,
            inst
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Map();
        for (const [key2, value] of input) {
          const keyResult = def.keyType._zod.run({ value: key2, issues: [] }, ctx);
          const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
          if (keyResult instanceof Promise || valueResult instanceof Promise) {
            proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
              handleMapResult(keyResult2, valueResult2, payload, key2, input, inst, ctx);
            }));
          } else {
            handleMapResult(keyResult, valueResult, payload, key2, input, inst, ctx);
          }
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!(input instanceof Set)) {
          payload.issues.push({
            input,
            inst,
            expected: "set",
            code: "invalid_type"
          });
          return payload;
        }
        const proms = [];
        payload.value = /* @__PURE__ */ new Set();
        for (const item of input) {
          const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => handleSetResult(result2, payload)));
          } else
            handleSetResult(result, payload);
        }
        if (proms.length)
          return Promise.all(proms).then(() => payload);
        return payload;
      };
    });
    $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
      $ZodType.init(inst, def);
      const values = getEnumValues(def.entries);
      const valuesSet = new Set(values);
      inst._zod.values = valuesSet;
      inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2.toString()).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
      }
      const values = new Set(def.values);
      inst._zod.values = values;
      inst._zod.pattern = new RegExp(`^(${def.values.map((o2) => typeof o2 === "string" ? escapeRegex(o2) : o2 ? escapeRegex(o2.toString()) : String(o2)).join("|")})$`);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (values.has(input)) {
          return payload;
        }
        payload.issues.push({
          code: "invalid_value",
          values: def.values,
          input,
          inst
        });
        return payload;
      };
    });
    $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (input instanceof File)
          return payload;
        payload.issues.push({
          expected: "file",
          code: "invalid_type",
          input,
          inst
        });
        return payload;
      };
    });
    $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
          const output = _out instanceof Promise ? _out : Promise.resolve(_out);
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        if (_out instanceof Promise) {
          throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
      };
    });
    $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      inst._zod.optout = "optional";
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
      });
      defineLazy(inst._zod, "pattern", () => {
        const pattern2 = def.innerType._zod.pattern;
        return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)})?$`) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
          const result = def.innerType._zod.run(payload, ctx);
          if (result instanceof Promise)
            return result.then((r3) => handleOptionalResult(r3, payload.value));
          return handleOptionalResult(result, payload.value);
        }
        if (payload.value === void 0) {
          return payload;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "pattern", () => {
        const pattern2 = def.innerType._zod.pattern;
        return pattern2 ? new RegExp(`^(${cleanRegex(pattern2.source)}|null)$`) : void 0;
      });
      defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        if (payload.value === null)
          return payload;
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
          return payload;
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleDefaultResult(result2, def));
        }
        return handleDefaultResult(result, def);
      };
    });
    $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.optin = "optional";
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        if (payload.value === void 0) {
          payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
      };
    });
    $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
      });
      inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => handleNonOptionalResult(result2, inst));
        }
        return handleNonOptionalResult(result, inst);
      };
    });
    $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          throw new $ZodEncodeError("ZodSuccess");
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.issues.length === 0;
            return payload;
          });
        }
        payload.value = result.issues.length === 0;
        return payload;
      };
    });
    $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
      defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then((result2) => {
            payload.value = result2.value;
            if (result2.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
                },
                input: payload.value
              });
              payload.issues = [];
            }
            return payload;
          });
        }
        payload.value = result.value;
        if (result.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      };
    });
    $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "nan",
            code: "invalid_type"
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handlePipeResult(right2, def.in, ctx));
          }
          return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
          return left.then((left2) => handlePipeResult(left2, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
      };
    });
    $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "values", () => def.in._zod.values);
      defineLazy(inst._zod, "optin", () => def.in._zod.optin);
      defineLazy(inst._zod, "optout", () => def.out._zod.optout);
      defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
      inst._zod.parse = (payload, ctx) => {
        const direction = ctx.direction || "forward";
        if (direction === "forward") {
          const left = def.in._zod.run(payload, ctx);
          if (left instanceof Promise) {
            return left.then((left2) => handleCodecAResult(left2, def, ctx));
          }
          return handleCodecAResult(left, def, ctx);
        } else {
          const right = def.out._zod.run(payload, ctx);
          if (right instanceof Promise) {
            return right.then((right2) => handleCodecAResult(right2, def, ctx));
          }
          return handleCodecAResult(right, def, ctx);
        }
      };
    });
    $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
      defineLazy(inst._zod, "values", () => def.innerType._zod.values);
      defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin);
      defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout);
      inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
          return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
          return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
      };
    });
    $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
      $ZodType.init(inst, def);
      const regexParts = [];
      for (const part of def.parts) {
        if (typeof part === "object" && part !== null) {
          if (!part._zod.pattern) {
            throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
          }
          const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
          if (!source)
            throw new Error(`Invalid template literal part: ${part._zod.traits}`);
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          regexParts.push(source.slice(start, end));
        } else if (part === null || primitiveTypes.has(typeof part)) {
          regexParts.push(escapeRegex(`${part}`));
        } else {
          throw new Error(`Invalid template literal part: ${part}`);
        }
      }
      inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "string") {
          payload.issues.push({
            input: payload.value,
            inst,
            expected: "template_literal",
            code: "invalid_type"
          });
          return payload;
        }
        inst._zod.pattern.lastIndex = 0;
        if (!inst._zod.pattern.test(payload.value)) {
          payload.issues.push({
            input: payload.value,
            inst,
            code: "invalid_format",
            format: def.format ?? "template_literal",
            pattern: inst._zod.pattern.source
          });
          return payload;
        }
        return payload;
      };
    });
    $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => {
      $ZodType.init(inst, def);
      inst._def = def;
      inst._zod.def = def;
      inst.implement = (func) => {
        if (typeof func !== "function") {
          throw new Error("implement() must be called with a function");
        }
        return function(...args) {
          const parsedArgs = inst._def.input ? parse3(inst._def.input, args) : args;
          const result = Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return parse3(inst._def.output, result);
          }
          return result;
        };
      };
      inst.implementAsync = (func) => {
        if (typeof func !== "function") {
          throw new Error("implementAsync() must be called with a function");
        }
        return async function(...args) {
          const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
          const result = await Reflect.apply(func, this, parsedArgs);
          if (inst._def.output) {
            return await parseAsync(inst._def.output, result);
          }
          return result;
        };
      };
      inst._zod.parse = (payload, _ctx) => {
        if (typeof payload.value !== "function") {
          payload.issues.push({
            code: "invalid_type",
            expected: "function",
            input: payload.value,
            inst
          });
          return payload;
        }
        const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
        if (hasPromiseOutput) {
          payload.value = inst.implementAsync(payload.value);
        } else {
          payload.value = inst.implement(payload.value);
        }
        return payload;
      };
      inst.input = (...args) => {
        const F = inst.constructor;
        if (Array.isArray(args[0])) {
          return new F({
            type: "function",
            input: new $ZodTuple({
              type: "tuple",
              items: args[0],
              rest: args[1]
            }),
            output: inst._def.output
          });
        }
        return new F({
          type: "function",
          input: args[0],
          output: inst._def.output
        });
      };
      inst.output = (output) => {
        const F = inst.constructor;
        return new F({
          type: "function",
          input: inst._def.input,
          output
        });
      };
      return inst;
    });
    $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, ctx) => {
        return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
      };
    });
    $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
      $ZodType.init(inst, def);
      defineLazy(inst._zod, "innerType", () => def.getter());
      defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern);
      defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues);
      defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0);
      defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0);
      inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
      };
    });
    $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
      $ZodCheck.init(inst, def);
      $ZodType.init(inst, def);
      inst._zod.parse = (payload, _) => {
        return payload;
      };
      inst._zod.check = (payload) => {
        const input = payload.value;
        const r3 = def.fn(input);
        if (r3 instanceof Promise) {
          return r3.then((r4) => handleRefineResult(r4, payload, input, inst));
        }
        handleRefineResult(r3, payload, input, inst);
        return;
      };
    });
  }
});

// node_modules/zod/v4/locales/ar.js
function ar_default() {
  return {
    localeError: error2()
  };
}
var error2;
var init_ar = __esm({
  "node_modules/zod/v4/locales/ar.js"() {
    init_util();
    error2 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0641", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        file: { unit: "\u0628\u0627\u064A\u062A", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        array: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" },
        set: { unit: "\u0639\u0646\u0635\u0631", verb: "\u0623\u0646 \u064A\u062D\u0648\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0645\u062F\u062E\u0644",
        email: "\u0628\u0631\u064A\u062F \u0625\u0644\u0643\u062A\u0631\u0648\u0646\u064A",
        url: "\u0631\u0627\u0628\u0637",
        emoji: "\u0625\u064A\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u064A\u062E \u0648\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        date: "\u062A\u0627\u0631\u064A\u062E \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        time: "\u0648\u0642\u062A \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        duration: "\u0645\u062F\u0629 \u0628\u0645\u0639\u064A\u0627\u0631 ISO",
        ipv4: "\u0639\u0646\u0648\u0627\u0646 IPv4",
        ipv6: "\u0639\u0646\u0648\u0627\u0646 IPv6",
        cidrv4: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv4",
        cidrv6: "\u0645\u062F\u0649 \u0639\u0646\u0627\u0648\u064A\u0646 \u0628\u0635\u064A\u063A\u0629 IPv6",
        base64: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64-encoded",
        base64url: "\u0646\u064E\u0635 \u0628\u062A\u0631\u0645\u064A\u0632 base64url-encoded",
        json_string: "\u0646\u064E\u0635 \u0639\u0644\u0649 \u0647\u064A\u0626\u0629 JSON",
        e164: "\u0631\u0642\u0645 \u0647\u0627\u062A\u0641 \u0628\u0645\u0639\u064A\u0627\u0631 E.164",
        jwt: "JWT",
        template_literal: "\u0645\u062F\u062E\u0644"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${issue2.expected}\u060C \u0648\u0644\u0643\u0646 \u062A\u0645 \u0625\u062F\u062E\u0627\u0644 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0645\u062F\u062E\u0644\u0627\u062A \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644\u0629: \u064A\u0641\u062A\u0631\u0636 \u0625\u062F\u062E\u0627\u0644 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0627\u062E\u062A\u064A\u0627\u0631 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062A\u0648\u0642\u0639 \u0627\u0646\u062A\u0642\u0627\u0621 \u0623\u062D\u062F \u0647\u0630\u0647 \u0627\u0644\u062E\u064A\u0627\u0631\u0627\u062A: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return ` \u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"}`;
            return `\u0623\u0643\u0628\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0623\u0646 \u062A\u0643\u0648\u0646 ${issue2.origin ?? "\u0627\u0644\u0642\u064A\u0645\u0629"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0623\u0635\u063A\u0631 \u0645\u0646 \u0627\u0644\u0644\u0627\u0632\u0645: \u064A\u0641\u062A\u0631\u0636 \u0644\u0640 ${issue2.origin} \u0623\u0646 \u064A\u0643\u0648\u0646 ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0628\u062F\u0623 \u0628\u0640 "${issue2.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0646\u062A\u0647\u064A \u0628\u0640 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u062A\u0636\u0645\u0651\u064E\u0646 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u0646\u064E\u0635 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0637\u0627\u0628\u0642 \u0627\u0644\u0646\u0645\u0637 ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644`;
          }
          case "not_multiple_of":
            return `\u0631\u0642\u0645 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644: \u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0645\u0646 \u0645\u0636\u0627\u0639\u0641\u0627\u062A ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u0645\u0639\u0631\u0641${issue2.keys.length > 1 ? "\u0627\u062A" : ""} \u063A\u0631\u064A\u0628${issue2.keys.length > 1 ? "\u0629" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `\u0645\u0639\u0631\u0641 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          case "invalid_union":
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
          case "invalid_element":
            return `\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644 \u0641\u064A ${issue2.origin}`;
          default:
            return "\u0645\u062F\u062E\u0644 \u063A\u064A\u0631 \u0645\u0642\u0628\u0648\u0644";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/az.js
function az_default() {
  return {
    localeError: error3()
  };
}
var error3;
var init_az = __esm({
  "node_modules/zod/v4/locales/az.js"() {
    init_util();
    error3 = () => {
      const Sizable = {
        string: { unit: "simvol", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "element", verb: "olmal\u0131d\u0131r" },
        set: { unit: "element", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${issue2.expected}, daxil olan ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Yanl\u0131\u015F d\u0259y\u0259r: g\xF6zl\u0259nil\u0259n ${stringifyPrimitive(issue2.values[0])}`;
            return `Yanl\u0131\u015F se\xE7im: a\u015Fa\u011F\u0131dak\u0131lardan biri olmal\u0131d\u0131r: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            return `\xC7ox b\xF6y\xFCk: g\xF6zl\u0259nil\u0259n ${issue2.origin ?? "d\u0259y\u0259r"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ox ki\xE7ik: g\xF6zl\u0259nil\u0259n ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.prefix}" il\u0259 ba\u015Flamal\u0131d\u0131r`;
            if (_issue.format === "ends_with")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.suffix}" il\u0259 bitm\u0259lidir`;
            if (_issue.format === "includes")
              return `Yanl\u0131\u015F m\u0259tn: "${_issue.includes}" daxil olmal\u0131d\u0131r`;
            if (_issue.format === "regex")
              return `Yanl\u0131\u015F m\u0259tn: ${_issue.pattern} \u015Fablonuna uy\u011Fun olmal\u0131d\u0131r`;
            return `Yanl\u0131\u015F ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Yanl\u0131\u015F \u0259d\u0259d: ${issue2.divisor} il\u0259 b\xF6l\xFCn\u0259 bil\u0259n olmal\u0131d\u0131r`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan a\xE7ar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F a\xE7ar`;
          case "invalid_union":
            return "Yanl\u0131\u015F d\u0259y\u0259r";
          case "invalid_element":
            return `${issue2.origin} daxilind\u0259 yanl\u0131\u015F d\u0259y\u0259r`;
          default:
            return `Yanl\u0131\u015F d\u0259y\u0259r`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function be_default() {
  return {
    localeError: error4()
  };
}
var error4;
var init_be = __esm({
  "node_modules/zod/v4/locales/be.js"() {
    init_util();
    error4 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0456\u043C\u0432\u0430\u043B",
            few: "\u0441\u0456\u043C\u0432\u0430\u043B\u044B",
            many: "\u0441\u0456\u043C\u0432\u0430\u043B\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u044B",
            many: "\u0431\u0430\u0439\u0442\u0430\u045E"
          },
          verb: "\u043C\u0435\u0446\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u043B\u0456\u043A";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0456\u045E";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0443\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0430\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0456 \u0447\u0430\u0441",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0447\u0430\u0441",
        duration: "ISO \u043F\u0440\u0430\u0446\u044F\u0433\u043B\u0430\u0441\u0446\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0430\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0430\u0441",
        cidrv4: "IPv4 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u044B\u044F\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64",
        base64url: "\u0440\u0430\u0434\u043E\u043A \u0443 \u0444\u0430\u0440\u043C\u0430\u0446\u0435 base64url",
        json_string: "JSON \u0440\u0430\u0434\u043E\u043A",
        e164: "\u043D\u0443\u043C\u0430\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0443\u0432\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u045E\u0441\u044F ${issue2.expected}, \u0430\u0442\u0440\u044B\u043C\u0430\u043D\u0430 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0432\u0430\u0440\u044B\u044F\u043D\u0442: \u0447\u0430\u043A\u0430\u045E\u0441\u044F \u0430\u0434\u0437\u0456\u043D \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u0432\u044F\u043B\u0456\u043A\u0456: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435"} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u0430 \u043C\u0430\u043B\u044B: \u0447\u0430\u043A\u0430\u043B\u0430\u0441\u044F, \u0448\u0442\u043E ${issue2.origin} \u043F\u0430\u0432\u0456\u043D\u043D\u0430 \u0431\u044B\u0446\u044C ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u043F\u0430\u0447\u044B\u043D\u0430\u0446\u0446\u0430 \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u0430\u043A\u0430\u043D\u0447\u0432\u0430\u0446\u0446\u0430 \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0437\u043C\u044F\u0448\u0447\u0430\u0446\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u0440\u0430\u0434\u043E\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0430\u0434\u043F\u0430\u0432\u044F\u0434\u0430\u0446\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043B\u0456\u043A: \u043F\u0430\u0432\u0456\u043D\u0435\u043D \u0431\u044B\u0446\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u0430\u0437\u043D\u0430\u043D\u044B ${issue2.keys.length > 1 ? "\u043A\u043B\u044E\u0447\u044B" : "\u043A\u043B\u044E\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434";
          case "invalid_element":
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u0430\u0435 \u0437\u043D\u0430\u0447\u044D\u043D\u043D\u0435 \u045E ${issue2.origin}`;
          default:
            return `\u041D\u044F\u043F\u0440\u0430\u0432\u0456\u043B\u044C\u043D\u044B \u045E\u0432\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/bg.js
function bg_default() {
  return {
    localeError: error5()
  };
}
var parsedType, error5;
var init_bg = __esm({
  "node_modules/zod/v4/locales/bg.js"() {
    init_util();
    parsedType = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u043C\u0430\u0441\u0438\u0432";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t2;
    };
    error5 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430", verb: "\u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "\u0432\u0445\u043E\u0434",
        email: "\u0438\u043C\u0435\u0439\u043B \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0436\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u043F\u0440\u043E\u0434\u044A\u043B\u0436\u0438\u0442\u0435\u043B\u043D\u043E\u0441\u0442",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "base64-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        base64url: "base64url-\u043A\u043E\u0434\u0438\u0440\u0430\u043D \u043D\u0438\u0437",
        json_string: "JSON \u043D\u0438\u0437",
        e164: "E.164 \u043D\u043E\u043C\u0435\u0440",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D ${parsedType(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434: \u043E\u0447\u0430\u043A\u0432\u0430\u043D ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u043E\u043F\u0446\u0438\u044F: \u043E\u0447\u0430\u043A\u0432\u0430\u043D\u043E \u0435\u0434\u043D\u043E \u043E\u0442 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0430"}`;
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u0433\u043E\u043B\u044F\u043C\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin ?? "\u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442"} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0441\u044A\u0434\u044A\u0440\u0436\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0422\u0432\u044A\u0440\u0434\u0435 \u043C\u0430\u043B\u043A\u043E: \u043E\u0447\u0430\u043A\u0432\u0430 \u0441\u0435 ${issue2.origin} \u0434\u0430 \u0431\u044A\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u0432\u0430 \u0441 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0437\u0430\u0432\u044A\u0440\u0448\u0432\u0430 \u0441 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0432\u043A\u043B\u044E\u0447\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043D\u0438\u0437: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0441\u044A\u0432\u043F\u0430\u0434\u0430 \u0441 ${_issue.pattern}`;
            let invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D";
            if (_issue.format === "emoji")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "datetime")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "date")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            if (_issue.format === "time")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E";
            if (_issue.format === "duration")
              invalid_adj = "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430";
            return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u043E \u0447\u0438\u0441\u043B\u043E: \u0442\u0440\u044F\u0431\u0432\u0430 \u0434\u0430 \u0431\u044A\u0434\u0435 \u043A\u0440\u0430\u0442\u043D\u043E \u043D\u0430 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0437\u043F\u043E\u0437\u043D\u0430\u0442${issue2.keys.length > 1 ? "\u0438" : ""} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u043E\u0432\u0435" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u043D\u0430 \u0441\u0442\u043E\u0439\u043D\u043E\u0441\u0442 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0430\u043B\u0438\u0434\u0435\u043D \u0432\u0445\u043E\u0434`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ca.js
function ca_default() {
  return {
    localeError: error6()
  };
}
var error6;
var init_ca = __esm({
  "node_modules/zod/v4/locales/ca.js"() {
    init_util();
    error6 = () => {
      const Sizable = {
        string: { unit: "car\xE0cters", verb: "contenir" },
        file: { unit: "bytes", verb: "contenir" },
        array: { unit: "elements", verb: "contenir" },
        set: { unit: "elements", verb: "contenir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "entrada",
        email: "adre\xE7a electr\xF2nica",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "durada ISO",
        ipv4: "adre\xE7a IPv4",
        ipv6: "adre\xE7a IPv6",
        cidrv4: "rang IPv4",
        cidrv6: "rang IPv6",
        base64: "cadena codificada en base64",
        base64url: "cadena codificada en base64url",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Tipus inv\xE0lid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Valor inv\xE0lid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3 inv\xE0lida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "com a m\xE0xim" : "menys de";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingu\xE9s ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "com a m\xEDnim" : "m\xE9s de";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Massa petit: s'esperava que ${issue2.origin} contingu\xE9s ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Format inv\xE0lid: ha de comen\xE7ar amb "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Format inv\xE0lid: ha d'acabar amb "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Format inv\xE0lid: ha d'incloure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Format inv\xE0lid: ha de coincidir amb el patr\xF3 ${_issue.pattern}`;
            return `Format inv\xE0lid per a ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE0lid: ha de ser m\xFAltiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Clau inv\xE0lida a ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE0lida";
          case "invalid_element":
            return `Element inv\xE0lid a ${issue2.origin}`;
          default:
            return `Entrada inv\xE0lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/cs.js
function cs_default() {
  return {
    localeError: error7()
  };
}
var error7;
var init_cs = __esm({
  "node_modules/zod/v4/locales/cs.js"() {
    init_util();
    error7 = () => {
      const Sizable = {
        string: { unit: "znak\u016F", verb: "m\xEDt" },
        file: { unit: "bajt\u016F", verb: "m\xEDt" },
        array: { unit: "prvk\u016F", verb: "m\xEDt" },
        set: { unit: "prvk\u016F", verb: "m\xEDt" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u010D\xEDslo";
          }
          case "string": {
            return "\u0159et\u011Bzec";
          }
          case "boolean": {
            return "boolean";
          }
          case "bigint": {
            return "bigint";
          }
          case "function": {
            return "funkce";
          }
          case "symbol": {
            return "symbol";
          }
          case "undefined": {
            return "undefined";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "pole";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "regul\xE1rn\xED v\xFDraz",
        email: "e-mailov\xE1 adresa",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "datum a \u010Das ve form\xE1tu ISO",
        date: "datum ve form\xE1tu ISO",
        time: "\u010Das ve form\xE1tu ISO",
        duration: "doba trv\xE1n\xED ISO",
        ipv4: "IPv4 adresa",
        ipv6: "IPv6 adresa",
        cidrv4: "rozsah IPv4",
        cidrv6: "rozsah IPv6",
        base64: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64",
        base64url: "\u0159et\u011Bzec zak\xF3dovan\xFD ve form\xE1tu base64url",
        json_string: "\u0159et\u011Bzec ve form\xE1tu JSON",
        e164: "\u010D\xEDslo E.164",
        jwt: "JWT",
        template_literal: "vstup"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${issue2.expected}, obdr\u017Eeno ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neplatn\xFD vstup: o\u010Dek\xE1v\xE1no ${stringifyPrimitive(issue2.values[0])}`;
            return `Neplatn\xE1 mo\u017Enost: o\u010Dek\xE1v\xE1na jedna z hodnot ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 velk\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED m\xEDt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk\u016F"}`;
            }
            return `Hodnota je p\u0159\xEDli\u0161 mal\xE1: ${issue2.origin ?? "hodnota"} mus\xED b\xFDt ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED za\u010D\xEDnat na "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED kon\u010Dit na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED obsahovat "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neplatn\xFD \u0159et\u011Bzec: mus\xED odpov\xEDdat vzoru ${_issue.pattern}`;
            return `Neplatn\xFD form\xE1t ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neplatn\xE9 \u010D\xEDslo: mus\xED b\xFDt n\xE1sobkem ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nezn\xE1m\xE9 kl\xED\u010De: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neplatn\xFD kl\xED\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neplatn\xFD vstup";
          case "invalid_element":
            return `Neplatn\xE1 hodnota v ${issue2.origin}`;
          default:
            return `Neplatn\xFD vstup`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/da.js
function da_default() {
  return {
    localeError: error8()
  };
}
var error8;
var init_da = __esm({
  "node_modules/zod/v4/locales/da.js"() {
    init_util();
    error8 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "havde" },
        file: { unit: "bytes", verb: "havde" },
        array: { unit: "elementer", verb: "indeholdt" },
        set: { unit: "elementer", verb: "indeholdt" }
      };
      const TypeNames = {
        string: "streng",
        number: "tal",
        boolean: "boolean",
        array: "liste",
        object: "objekt",
        set: "s\xE6t",
        file: "fil"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type) {
        return TypeNames[type] ?? type;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
            return "objekt";
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "input",
        email: "e-mailadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkesl\xE6t",
        date: "ISO-dato",
        time: "ISO-klokkesl\xE6t",
        duration: "ISO-varighed",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodet streng",
        base64url: "base64url-kodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType8(issue2.input))}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig v\xE6rdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldigt valg: forventede en af f\xF8lgende ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing)
              return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing) {
              return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: skal matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldigt tal: skal v\xE6re deleligt med ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukendte n\xF8gler" : "Ukendt n\xF8gle"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8gle i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldigt input: matcher ingen af de tilladte typer";
          case "invalid_element":
            return `Ugyldig v\xE6rdi i ${issue2.origin}`;
          default:
            return `Ugyldigt input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/de.js
function de_default() {
  return {
    localeError: error9()
  };
}
var error9;
var init_de = __esm({
  "node_modules/zod/v4/locales/de.js"() {
    init_util();
    error9 = () => {
      const Sizable = {
        string: { unit: "Zeichen", verb: "zu haben" },
        file: { unit: "Bytes", verb: "zu haben" },
        array: { unit: "Elemente", verb: "zu haben" },
        set: { unit: "Elemente", verb: "zu haben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "Zahl";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "Array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "Eingabe",
        email: "E-Mail-Adresse",
        url: "URL",
        emoji: "Emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-Datum und -Uhrzeit",
        date: "ISO-Datum",
        time: "ISO-Uhrzeit",
        duration: "ISO-Dauer",
        ipv4: "IPv4-Adresse",
        ipv6: "IPv6-Adresse",
        cidrv4: "IPv4-Bereich",
        cidrv6: "IPv6-Bereich",
        base64: "Base64-codierter String",
        base64url: "Base64-URL-codierter String",
        json_string: "JSON-String",
        e164: "E.164-Nummer",
        jwt: "JWT",
        template_literal: "Eingabe"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ung\xFCltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ung\xFCltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ung\xFCltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
            return `Zu gro\xDF: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
            }
            return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ung\xFCltiger String: muss mit "${_issue.prefix}" beginnen`;
            if (_issue.format === "ends_with")
              return `Ung\xFCltiger String: muss mit "${_issue.suffix}" enden`;
            if (_issue.format === "includes")
              return `Ung\xFCltiger String: muss "${_issue.includes}" enthalten`;
            if (_issue.format === "regex")
              return `Ung\xFCltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
            return `Ung\xFCltig: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ung\xFCltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Unbekannte Schl\xFCssel" : "Unbekannter Schl\xFCssel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ung\xFCltiger Schl\xFCssel in ${issue2.origin}`;
          case "invalid_union":
            return "Ung\xFCltige Eingabe";
          case "invalid_element":
            return `Ung\xFCltiger Wert in ${issue2.origin}`;
          default:
            return `Ung\xFCltige Eingabe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/en.js
function en_default() {
  return {
    localeError: error10()
  };
}
var parsedType2, error10;
var init_en = __esm({
  "node_modules/zod/v4/locales/en.js"() {
    init_util();
    parsedType2 = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t2;
    };
    error10 = () => {
      const Sizable = {
        string: { unit: "characters", verb: "to have" },
        file: { unit: "bytes", verb: "to have" },
        array: { unit: "items", verb: "to have" },
        set: { unit: "items", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "input",
        email: "email address",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datetime",
        date: "ISO date",
        time: "ISO time",
        duration: "ISO duration",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        mac: "MAC address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded string",
        base64url: "base64url-encoded string",
        json_string: "JSON string",
        e164: "E.164 number",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
            return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Invalid string: must start with "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Invalid string: must end with "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Invalid string: must include "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Invalid string: must match pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Invalid number: must be a multiple of ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Invalid key in ${issue2.origin}`;
          case "invalid_union":
            return "Invalid input";
          case "invalid_element":
            return `Invalid value in ${issue2.origin}`;
          default:
            return `Invalid input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/eo.js
function eo_default() {
  return {
    localeError: error11()
  };
}
var parsedType3, error11;
var init_eo = __esm({
  "node_modules/zod/v4/locales/eo.js"() {
    init_util();
    parsedType3 = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "nombro";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "tabelo";
          }
          if (data === null) {
            return "senvalora";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t2;
    };
    error11 = () => {
      const Sizable = {
        string: { unit: "karaktrojn", verb: "havi" },
        file: { unit: "bajtojn", verb: "havi" },
        array: { unit: "elementojn", verb: "havi" },
        set: { unit: "elementojn", verb: "havi" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "enigo",
        email: "retadreso",
        url: "URL",
        emoji: "emo\u011Dio",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datotempo",
        date: "ISO-dato",
        time: "ISO-tempo",
        duration: "ISO-da\u016Dro",
        ipv4: "IPv4-adreso",
        ipv6: "IPv6-adreso",
        cidrv4: "IPv4-rango",
        cidrv6: "IPv6-rango",
        base64: "64-ume kodita karaktraro",
        base64url: "URL-64-ume kodita karaktraro",
        json_string: "JSON-karaktraro",
        e164: "E.164-nombro",
        jwt: "JWT",
        template_literal: "enigo"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Nevalida enigo: atendi\u011Dis ${issue2.expected}, ricevi\u011Dis ${parsedType3(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nevalida enigo: atendi\u011Dis ${stringifyPrimitive(issue2.values[0])}`;
            return `Nevalida opcio: atendi\u011Dis unu el ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
            return `Tro granda: atendi\u011Dis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Tro malgranda: atendi\u011Dis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nevalida karaktraro: devas komenci\u011Di per "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nevalida karaktraro: devas fini\u011Di per "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
            return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nekonata${issue2.keys.length > 1 ? "j" : ""} \u015Dlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nevalida \u015Dlosilo en ${issue2.origin}`;
          case "invalid_union":
            return "Nevalida enigo";
          case "invalid_element":
            return `Nevalida valoro en ${issue2.origin}`;
          default:
            return `Nevalida enigo`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/es.js
function es_default() {
  return {
    localeError: error12()
  };
}
var error12;
var init_es = __esm({
  "node_modules/zod/v4/locales/es.js"() {
    init_util();
    error12 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "tener" },
        file: { unit: "bytes", verb: "tener" },
        array: { unit: "elementos", verb: "tener" },
        set: { unit: "elementos", verb: "tener" }
      };
      const TypeNames = {
        string: "texto",
        number: "n\xFAmero",
        boolean: "booleano",
        array: "arreglo",
        object: "objeto",
        set: "conjunto",
        file: "archivo",
        date: "fecha",
        bigint: "n\xFAmero grande",
        symbol: "s\xEDmbolo",
        undefined: "indefinido",
        null: "nulo",
        function: "funci\xF3n",
        map: "mapa",
        record: "registro",
        tuple: "tupla",
        enum: "enumeraci\xF3n",
        union: "uni\xF3n",
        literal: "literal",
        promise: "promesa",
        void: "vac\xEDo",
        never: "nunca",
        unknown: "desconocido",
        any: "cualquiera"
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      function getTypeName(type) {
        return TypeNames[type] ?? type;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype) {
              return data.constructor.name;
            }
            return "object";
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "entrada",
        email: "direcci\xF3n de correo electr\xF3nico",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "fecha y hora ISO",
        date: "fecha ISO",
        time: "hora ISO",
        duration: "duraci\xF3n ISO",
        ipv4: "direcci\xF3n IPv4",
        ipv6: "direcci\xF3n IPv6",
        cidrv4: "rango IPv4",
        cidrv6: "rango IPv6",
        base64: "cadena codificada en base64",
        base64url: "URL codificada en base64",
        json_string: "cadena JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entrada inv\xE1lida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType8(issue2.input))}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
            return `Opci\xF3n inv\xE1lida: se esperaba una de ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing)
              return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            const origin = getTypeName(issue2.origin);
            if (sizing) {
              return `Demasiado peque\xF1o: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Demasiado peque\xF1o: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cadena inv\xE1lida: debe comenzar con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cadena inv\xE1lida: debe terminar en "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cadena inv\xE1lida: debe incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cadena inv\xE1lida: debe coincidir con el patr\xF3n ${_issue.pattern}`;
            return `Inv\xE1lido ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: debe ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Llave inv\xE1lida en ${getTypeName(issue2.origin)}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido en ${getTypeName(issue2.origin)}`;
          default:
            return `Entrada inv\xE1lida`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fa.js
function fa_default() {
  return {
    localeError: error13()
  };
}
var error13;
var init_fa = __esm({
  "node_modules/zod/v4/locales/fa.js"() {
    init_util();
    error13 = () => {
      const Sizable = {
        string: { unit: "\u06A9\u0627\u0631\u0627\u06A9\u062A\u0631", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        file: { unit: "\u0628\u0627\u06CC\u062A", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        array: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" },
        set: { unit: "\u0622\u06CC\u062A\u0645", verb: "\u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u0627\u06CC\u0647";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u06CC",
        email: "\u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644",
        url: "URL",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u062A\u0627\u0631\u06CC\u062E \u0648 \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        date: "\u062A\u0627\u0631\u06CC\u062E \u0627\u06CC\u0632\u0648",
        time: "\u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        duration: "\u0645\u062F\u062A \u0632\u0645\u0627\u0646 \u0627\u06CC\u0632\u0648",
        ipv4: "IPv4 \u0622\u062F\u0631\u0633",
        ipv6: "IPv6 \u0622\u062F\u0631\u0633",
        cidrv4: "IPv4 \u062F\u0627\u0645\u0646\u0647",
        cidrv6: "IPv6 \u062F\u0627\u0645\u0646\u0647",
        base64: "base64-encoded \u0631\u0634\u062A\u0647",
        base64url: "base64url-encoded \u0631\u0634\u062A\u0647",
        json_string: "JSON \u0631\u0634\u062A\u0647",
        e164: "E.164 \u0639\u062F\u062F",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u06CC"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${issue2.expected} \u0645\u06CC\u200C\u0628\u0648\u062F\u060C ${parsedType8(issue2.input)} \u062F\u0631\u06CC\u0627\u0641\u062A \u0634\u062F`;
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A ${stringifyPrimitive(issue2.values[0])} \u0645\u06CC\u200C\u0628\u0648\u062F`;
            }
            return `\u06AF\u0632\u06CC\u0646\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0645\u06CC\u200C\u0628\u0627\u06CC\u0633\u062A \u06CC\u06A9\u06CC \u0627\u0632 ${joinValues(issue2.values, "|")} \u0645\u06CC\u200C\u0628\u0648\u062F`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631"} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u0628\u0632\u0631\u06AF: ${issue2.origin ?? "\u0645\u0642\u062F\u0627\u0631"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0628\u0627\u0634\u062F`;
            }
            return `\u062E\u06CC\u0644\u06CC \u06A9\u0648\u0686\u06A9: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0628\u0627\u0634\u062F`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.prefix}" \u0634\u0631\u0648\u0639 \u0634\u0648\u062F`;
            }
            if (_issue.format === "ends_with") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 "${_issue.suffix}" \u062A\u0645\u0627\u0645 \u0634\u0648\u062F`;
            }
            if (_issue.format === "includes") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0634\u0627\u0645\u0644 "${_issue.includes}" \u0628\u0627\u0634\u062F`;
            }
            if (_issue.format === "regex") {
              return `\u0631\u0634\u062A\u0647 \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0628\u0627 \u0627\u0644\u06AF\u0648\u06CC ${_issue.pattern} \u0645\u0637\u0627\u0628\u0642\u062A \u062F\u0627\u0634\u062A\u0647 \u0628\u0627\u0634\u062F`;
            }
            return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          }
          case "not_multiple_of":
            return `\u0639\u062F\u062F \u0646\u0627\u0645\u0639\u062A\u0628\u0631: \u0628\u0627\u06CC\u062F \u0645\u0636\u0631\u0628 ${issue2.divisor} \u0628\u0627\u0634\u062F`;
          case "unrecognized_keys":
            return `\u06A9\u0644\u06CC\u062F${issue2.keys.length > 1 ? "\u0647\u0627\u06CC" : ""} \u0646\u0627\u0634\u0646\u0627\u0633: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u06A9\u0644\u06CC\u062F \u0646\u0627\u0634\u0646\u0627\u0633 \u062F\u0631 ${issue2.origin}`;
          case "invalid_union":
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
          case "invalid_element":
            return `\u0645\u0642\u062F\u0627\u0631 \u0646\u0627\u0645\u0639\u062A\u0628\u0631 \u062F\u0631 ${issue2.origin}`;
          default:
            return `\u0648\u0631\u0648\u062F\u06CC \u0646\u0627\u0645\u0639\u062A\u0628\u0631`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fi.js
function fi_default() {
  return {
    localeError: error14()
  };
}
var error14;
var init_fi = __esm({
  "node_modules/zod/v4/locales/fi.js"() {
    init_util();
    error14 = () => {
      const Sizable = {
        string: { unit: "merkki\xE4", subject: "merkkijonon" },
        file: { unit: "tavua", subject: "tiedoston" },
        array: { unit: "alkiota", subject: "listan" },
        set: { unit: "alkiota", subject: "joukon" },
        number: { unit: "", subject: "luvun" },
        bigint: { unit: "", subject: "suuren kokonaisluvun" },
        int: { unit: "", subject: "kokonaisluvun" },
        date: { unit: "", subject: "p\xE4iv\xE4m\xE4\xE4r\xE4n" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "s\xE4\xE4nn\xF6llinen lauseke",
        email: "s\xE4hk\xF6postiosoite",
        url: "URL-osoite",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-aikaleima",
        date: "ISO-p\xE4iv\xE4m\xE4\xE4r\xE4",
        time: "ISO-aika",
        duration: "ISO-kesto",
        ipv4: "IPv4-osoite",
        ipv6: "IPv6-osoite",
        cidrv4: "IPv4-alue",
        cidrv6: "IPv6-alue",
        base64: "base64-koodattu merkkijono",
        base64url: "base64url-koodattu merkkijono",
        json_string: "JSON-merkkijono",
        e164: "E.164-luku",
        jwt: "JWT",
        template_literal: "templaattimerkkijono"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Virheellinen sy\xF6te: t\xE4ytyy olla ${stringifyPrimitive(issue2.values[0])}`;
            return `Virheellinen valinta: t\xE4ytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian suuri: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian suuri: arvon t\xE4ytyy olla ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Liian pieni: ${sizing.subject} t\xE4ytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
            }
            return `Liian pieni: arvon t\xE4ytyy olla ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy alkaa "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Virheellinen sy\xF6te: t\xE4ytyy loppua "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Virheellinen sy\xF6te: t\xE4ytyy sis\xE4lt\xE4\xE4 "${_issue.includes}"`;
            if (_issue.format === "regex") {
              return `Virheellinen sy\xF6te: t\xE4ytyy vastata s\xE4\xE4nn\xF6llist\xE4 lauseketta ${_issue.pattern}`;
            }
            return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Virheellinen luku: t\xE4ytyy olla luvun ${issue2.divisor} monikerta`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Virheellinen avain tietueessa";
          case "invalid_union":
            return "Virheellinen unioni";
          case "invalid_element":
            return "Virheellinen arvo joukossa";
          default:
            return `Virheellinen sy\xF6te`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr.js
function fr_default() {
  return {
    localeError: error15()
  };
}
var error15;
var init_fr = __esm({
  "node_modules/zod/v4/locales/fr.js"() {
    init_util();
    error15 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombre";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tableau";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date et heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : ${issue2.expected} attendu, ${parsedType8(issue2.input)} re\xE7u`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
            return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xE9l\xE9ment(s)"}`;
            return `Trop grand : ${issue2.origin ?? "valeur"} doit \xEAtre ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : ${issue2.origin} doit \xEAtre ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au mod\xE8le ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/fr-CA.js
function fr_CA_default() {
  return {
    localeError: error16()
  };
}
var error16;
var init_fr_CA = __esm({
  "node_modules/zod/v4/locales/fr-CA.js"() {
    init_util();
    error16 = () => {
      const Sizable = {
        string: { unit: "caract\xE8res", verb: "avoir" },
        file: { unit: "octets", verb: "avoir" },
        array: { unit: "\xE9l\xE9ments", verb: "avoir" },
        set: { unit: "\xE9l\xE9ments", verb: "avoir" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "entr\xE9e",
        email: "adresse courriel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "date-heure ISO",
        date: "date ISO",
        time: "heure ISO",
        duration: "dur\xE9e ISO",
        ipv4: "adresse IPv4",
        ipv6: "adresse IPv6",
        cidrv4: "plage IPv4",
        cidrv6: "plage IPv6",
        base64: "cha\xEEne encod\xE9e en base64",
        base64url: "cha\xEEne encod\xE9e en base64url",
        json_string: "cha\xEEne JSON",
        e164: "num\xE9ro E.164",
        jwt: "JWT",
        template_literal: "entr\xE9e"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Entr\xE9e invalide : attendu ${issue2.expected}, re\xE7u ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entr\xE9e invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
            return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u2264" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u2265" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Cha\xEEne invalide : doit commencer par "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Cha\xEEne invalide : doit se terminer par "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Cha\xEEne invalide : doit inclure "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Cha\xEEne invalide : doit correspondre au motif ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} invalide`;
          }
          case "not_multiple_of":
            return `Nombre invalide : doit \xEAtre un multiple de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Cl\xE9${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Cl\xE9 invalide dans ${issue2.origin}`;
          case "invalid_union":
            return "Entr\xE9e invalide";
          case "invalid_element":
            return `Valeur invalide dans ${issue2.origin}`;
          default:
            return `Entr\xE9e invalide`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/he.js
function he_default() {
  return {
    localeError: error17()
  };
}
var error17;
var init_he = __esm({
  "node_modules/zod/v4/locales/he.js"() {
    init_util();
    error17 = () => {
      const TypeNames = {
        string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA", gender: "f" },
        number: { label: "\u05DE\u05E1\u05E4\u05E8", gender: "m" },
        boolean: { label: "\u05E2\u05E8\u05DA \u05D1\u05D5\u05DC\u05D9\u05D0\u05E0\u05D9", gender: "m" },
        bigint: { label: "BigInt", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA", gender: "m" },
        array: { label: "\u05DE\u05E2\u05E8\u05DA", gender: "m" },
        object: { label: "\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8", gender: "m" },
        null: { label: "\u05E2\u05E8\u05DA \u05E8\u05D9\u05E7 (null)", gender: "m" },
        undefined: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05DE\u05D5\u05D2\u05D3\u05E8 (undefined)", gender: "m" },
        symbol: { label: "\u05E1\u05D9\u05DE\u05D1\u05D5\u05DC (Symbol)", gender: "m" },
        function: { label: "\u05E4\u05D5\u05E0\u05E7\u05E6\u05D9\u05D4", gender: "f" },
        map: { label: "\u05DE\u05E4\u05D4 (Map)", gender: "f" },
        set: { label: "\u05E7\u05D1\u05D5\u05E6\u05D4 (Set)", gender: "f" },
        file: { label: "\u05E7\u05D5\u05D1\u05E5", gender: "m" },
        promise: { label: "Promise", gender: "m" },
        NaN: { label: "NaN", gender: "m" },
        unknown: { label: "\u05E2\u05E8\u05DA \u05DC\u05D0 \u05D9\u05D3\u05D5\u05E2", gender: "m" },
        value: { label: "\u05E2\u05E8\u05DA", gender: "m" }
      };
      const Sizable = {
        string: { unit: "\u05EA\u05D5\u05D5\u05D9\u05DD", shortLabel: "\u05E7\u05E6\u05E8", longLabel: "\u05D0\u05E8\u05D5\u05DA" },
        file: { unit: "\u05D1\u05D9\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        array: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        set: { unit: "\u05E4\u05E8\u05D9\u05D8\u05D9\u05DD", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" },
        number: { unit: "", shortLabel: "\u05E7\u05D8\u05DF", longLabel: "\u05D2\u05D3\u05D5\u05DC" }
        // no unit
      };
      const typeEntry = (t2) => t2 ? TypeNames[t2] : void 0;
      const typeLabel = (t2) => {
        const e3 = typeEntry(t2);
        if (e3)
          return e3.label;
        return t2 ?? TypeNames.unknown.label;
      };
      const withDefinite = (t2) => `\u05D4${typeLabel(t2)}`;
      const verbFor = (t2) => {
        const e3 = typeEntry(t2);
        const gender = e3?.gender ?? "m";
        return gender === "f" ? "\u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05D9\u05D5\u05EA" : "\u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA";
      };
      const getSizing = (origin) => {
        if (!origin)
          return null;
        return Sizable[origin] ?? null;
      };
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number":
            return Number.isNaN(data) ? "NaN" : "number";
          case "object": {
            if (Array.isArray(data))
              return "array";
            if (data === null)
              return "null";
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
            return "object";
          }
          default:
            return t2;
        }
      };
      const Nouns = {
        regex: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        email: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC", gender: "f" },
        url: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        emoji: { label: "\u05D0\u05D9\u05DE\u05D5\u05D2'\u05D9", gender: "m" },
        uuid: { label: "UUID", gender: "m" },
        nanoid: { label: "nanoid", gender: "m" },
        guid: { label: "GUID", gender: "m" },
        cuid: { label: "cuid", gender: "m" },
        cuid2: { label: "cuid2", gender: "m" },
        ulid: { label: "ULID", gender: "m" },
        xid: { label: "XID", gender: "m" },
        ksuid: { label: "KSUID", gender: "m" },
        datetime: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA \u05D5\u05D6\u05DE\u05DF ISO", gender: "m" },
        date: { label: "\u05EA\u05D0\u05E8\u05D9\u05DA ISO", gender: "m" },
        time: { label: "\u05D6\u05DE\u05DF ISO", gender: "m" },
        duration: { label: "\u05DE\u05E9\u05DA \u05D6\u05DE\u05DF ISO", gender: "m" },
        ipv4: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv4", gender: "f" },
        ipv6: { label: "\u05DB\u05EA\u05D5\u05D1\u05EA IPv6", gender: "f" },
        cidrv4: { label: "\u05D8\u05D5\u05D5\u05D7 IPv4", gender: "m" },
        cidrv6: { label: "\u05D8\u05D5\u05D5\u05D7 IPv6", gender: "m" },
        base64: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64", gender: "f" },
        base64url: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D1\u05D1\u05E1\u05D9\u05E1 64 \u05DC\u05DB\u05EA\u05D5\u05D1\u05D5\u05EA \u05E8\u05E9\u05EA", gender: "f" },
        json_string: { label: "\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA JSON", gender: "f" },
        e164: { label: "\u05DE\u05E1\u05E4\u05E8 E.164", gender: "m" },
        jwt: { label: "JWT", gender: "m" },
        ends_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        includes: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        lowercase: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        starts_with: { label: "\u05E7\u05DC\u05D8", gender: "m" },
        uppercase: { label: "\u05E7\u05DC\u05D8", gender: "m" }
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type": {
            const expectedKey = issue2.expected;
            const expected = typeLabel(expectedKey);
            const receivedKey = parsedType8(issue2.input);
            const received = TypeNames[receivedKey]?.label ?? receivedKey;
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${expected}, \u05D4\u05EA\u05E7\u05D1\u05DC ${received}`;
          }
          case "invalid_value": {
            if (issue2.values.length === 1) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05E2\u05E8\u05DA \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA ${stringifyPrimitive(issue2.values[0])}`;
            }
            const stringified = issue2.values.map((v) => stringifyPrimitive(v));
            if (issue2.values.length === 2) {
              return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${stringified[0]} \u05D0\u05D5 ${stringified[1]}`;
            }
            const lastValue = stringified[stringified.length - 1];
            const restValues = stringified.slice(0, -1).join(", ");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D4\u05D0\u05E4\u05E9\u05E8\u05D5\u05D9\u05D5\u05EA \u05D4\u05DE\u05EA\u05D0\u05D9\u05DE\u05D5\u05EA \u05D4\u05DF ${restValues} \u05D0\u05D5 ${lastValue}`;
          }
          case "too_big": {
            const sizing = getSizing(issue2.origin);
            const subject = withDefinite(issue2.origin ?? "value");
            if (issue2.origin === "string") {
              return `${sizing?.longLabel ?? "\u05D0\u05E8\u05D5\u05DA"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.maximum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA" : "\u05DC\u05DB\u05DC \u05D4\u05D9\u05D5\u05EA\u05E8"}`.trim();
            }
            if (issue2.origin === "number") {
              const comparison = issue2.inclusive ? `\u05E7\u05D8\u05DF \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.maximum}` : `\u05E7\u05D8\u05DF \u05DE-${issue2.maximum}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue2.origin === "array" || issue2.origin === "set") {
              const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              const comparison = issue2.inclusive ? `${issue2.maximum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05E4\u05D7\u05D5\u05EA` : `\u05E4\u05D7\u05D5\u05EA \u05DE-${issue2.maximum} ${sizing?.unit ?? ""}`;
              return `\u05D2\u05D3\u05D5\u05DC \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue2.inclusive ? "<=" : "<";
            const be = verbFor(issue2.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.longLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.longLabel ?? "\u05D2\u05D3\u05D5\u05DC"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const sizing = getSizing(issue2.origin);
            const subject = withDefinite(issue2.origin ?? "value");
            if (issue2.origin === "string") {
              return `${sizing?.shortLabel ?? "\u05E7\u05E6\u05E8"} \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DB\u05D4 \u05DC\u05D4\u05DB\u05D9\u05DC ${issue2.minimum.toString()} ${sizing?.unit ?? ""} ${issue2.inclusive ? "\u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8" : "\u05DC\u05E4\u05D7\u05D5\u05EA"}`.trim();
            }
            if (issue2.origin === "number") {
              const comparison = issue2.inclusive ? `\u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC-${issue2.minimum}` : `\u05D2\u05D3\u05D5\u05DC \u05DE-${issue2.minimum}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} \u05E6\u05E8\u05D9\u05DA \u05DC\u05D4\u05D9\u05D5\u05EA ${comparison}`;
            }
            if (issue2.origin === "array" || issue2.origin === "set") {
              const verb = issue2.origin === "set" ? "\u05E6\u05E8\u05D9\u05DB\u05D4" : "\u05E6\u05E8\u05D9\u05DA";
              if (issue2.minimum === 1 && issue2.inclusive) {
                const singularPhrase = issue2.origin === "set" ? "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3" : "\u05DC\u05E4\u05D7\u05D5\u05EA \u05E4\u05E8\u05D9\u05D8 \u05D0\u05D7\u05D3";
                return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${singularPhrase}`;
              }
              const comparison = issue2.inclusive ? `${issue2.minimum} ${sizing?.unit ?? ""} \u05D0\u05D5 \u05D9\u05D5\u05EA\u05E8` : `\u05D9\u05D5\u05EA\u05E8 \u05DE-${issue2.minimum} ${sizing?.unit ?? ""}`;
              return `\u05E7\u05D8\u05DF \u05DE\u05D3\u05D9: ${subject} ${verb} \u05DC\u05D4\u05DB\u05D9\u05DC ${comparison}`.trim();
            }
            const adj = issue2.inclusive ? ">=" : ">";
            const be = verbFor(issue2.origin ?? "value");
            if (sizing?.unit) {
              return `${sizing.shortLabel} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `${sizing?.shortLabel ?? "\u05E7\u05D8\u05DF"} \u05DE\u05D3\u05D9: ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D7\u05D9\u05DC \u05D1 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05DB\u05DC\u05D5\u05DC "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u05D4\u05DE\u05D7\u05E8\u05D5\u05D6\u05EA \u05D7\u05D9\u05D9\u05D1\u05EA \u05DC\u05D4\u05EA\u05D0\u05D9\u05DD \u05DC\u05EA\u05D1\u05E0\u05D9\u05EA ${_issue.pattern}`;
            const nounEntry = Nouns[_issue.format];
            const noun = nounEntry?.label ?? _issue.format;
            const gender = nounEntry?.gender ?? "m";
            const adjective = gender === "f" ? "\u05EA\u05E7\u05D9\u05E0\u05D4" : "\u05EA\u05E7\u05D9\u05DF";
            return `${noun} \u05DC\u05D0 ${adjective}`;
          }
          case "not_multiple_of":
            return `\u05DE\u05E1\u05E4\u05E8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF: \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05DB\u05E4\u05DC\u05D4 \u05E9\u05DC ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u05DE\u05E4\u05EA\u05D7${issue2.keys.length > 1 ? "\u05D5\u05EA" : ""} \u05DC\u05D0 \u05DE\u05D6\u05D5\u05D4${issue2.keys.length > 1 ? "\u05D9\u05DD" : "\u05D4"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key": {
            return `\u05E9\u05D3\u05D4 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1\u05D0\u05D5\u05D1\u05D9\u05D9\u05E7\u05D8`;
          }
          case "invalid_union":
            return "\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF";
          case "invalid_element": {
            const place = withDefinite(issue2.origin ?? "array");
            return `\u05E2\u05E8\u05DA \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF \u05D1${place}`;
          }
          default:
            return `\u05E7\u05DC\u05D8 \u05DC\u05D0 \u05EA\u05E7\u05D9\u05DF`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/hu.js
function hu_default() {
  return {
    localeError: error18()
  };
}
var error18;
var init_hu = __esm({
  "node_modules/zod/v4/locales/hu.js"() {
    init_util();
    error18 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "legyen" },
        file: { unit: "byte", verb: "legyen" },
        array: { unit: "elem", verb: "legyen" },
        set: { unit: "elem", verb: "legyen" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "sz\xE1m";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "t\xF6mb";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "bemenet",
        email: "email c\xEDm",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO id\u0151b\xE9lyeg",
        date: "ISO d\xE1tum",
        time: "ISO id\u0151",
        duration: "ISO id\u0151intervallum",
        ipv4: "IPv4 c\xEDm",
        ipv6: "IPv6 c\xEDm",
        cidrv4: "IPv4 tartom\xE1ny",
        cidrv6: "IPv6 tartom\xE1ny",
        base64: "base64-k\xF3dolt string",
        base64url: "base64url-k\xF3dolt string",
        json_string: "JSON string",
        e164: "E.164 sz\xE1m",
        jwt: "JWT",
        template_literal: "bemenet"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${issue2.expected}, a kapott \xE9rt\xE9k ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xC9rv\xE9nytelen bemenet: a v\xE1rt \xE9rt\xE9k ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC9rv\xE9nytelen opci\xF3: valamelyik \xE9rt\xE9k v\xE1rt ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xFAl nagy: ${issue2.origin ?? "\xE9rt\xE9k"} m\xE9rete t\xFAl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
            return `T\xFAl nagy: a bemeneti \xE9rt\xE9k ${issue2.origin ?? "\xE9rt\xE9k"} t\xFAl nagy: ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} m\xE9rete t\xFAl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `T\xFAl kicsi: a bemeneti \xE9rt\xE9k ${issue2.origin} t\xFAl kicsi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\xC9rv\xE9nytelen string: "${_issue.prefix}" \xE9rt\xE9kkel kell kezd\u0151dnie`;
            if (_issue.format === "ends_with")
              return `\xC9rv\xE9nytelen string: "${_issue.suffix}" \xE9rt\xE9kkel kell v\xE9gz\u0151dnie`;
            if (_issue.format === "includes")
              return `\xC9rv\xE9nytelen string: "${_issue.includes}" \xE9rt\xE9ket kell tartalmaznia`;
            if (_issue.format === "regex")
              return `\xC9rv\xE9nytelen string: ${_issue.pattern} mint\xE1nak kell megfelelnie`;
            return `\xC9rv\xE9nytelen ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\xC9rv\xE9nytelen sz\xE1m: ${issue2.divisor} t\xF6bbsz\xF6r\xF6s\xE9nek kell lennie`;
          case "unrecognized_keys":
            return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\xC9rv\xE9nytelen kulcs ${issue2.origin}`;
          case "invalid_union":
            return "\xC9rv\xE9nytelen bemenet";
          case "invalid_element":
            return `\xC9rv\xE9nytelen \xE9rt\xE9k: ${issue2.origin}`;
          default:
            return `\xC9rv\xE9nytelen bemenet`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/id.js
function id_default() {
  return {
    localeError: error19()
  };
}
var error19;
var init_id = __esm({
  "node_modules/zod/v4/locales/id.js"() {
    init_util();
    error19 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "memiliki" },
        file: { unit: "byte", verb: "memiliki" },
        array: { unit: "item", verb: "memiliki" },
        set: { unit: "item", verb: "memiliki" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "input",
        email: "alamat email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tanggal dan waktu format ISO",
        date: "tanggal format ISO",
        time: "jam format ISO",
        duration: "durasi format ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "rentang alamat IPv4",
        cidrv6: "rentang alamat IPv6",
        base64: "string dengan enkode base64",
        base64url: "string dengan enkode base64url",
        json_string: "string JSON",
        e164: "angka E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak valid: harus menyertakan "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
          }
          case "not_multiple_of":
            return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak valid di ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak valid";
          case "invalid_element":
            return `Nilai tidak valid di ${issue2.origin}`;
          default:
            return `Input tidak valid`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/is.js
function is_default() {
  return {
    localeError: error20()
  };
}
var parsedType4, error20;
var init_is = __esm({
  "node_modules/zod/v4/locales/is.js"() {
    init_util();
    parsedType4 = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "n\xFAmer";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "fylki";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t2;
    };
    error20 = () => {
      const Sizable = {
        string: { unit: "stafi", verb: "a\xF0 hafa" },
        file: { unit: "b\xE6ti", verb: "a\xF0 hafa" },
        array: { unit: "hluti", verb: "a\xF0 hafa" },
        set: { unit: "hluti", verb: "a\xF0 hafa" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "gildi",
        email: "netfang",
        url: "vefsl\xF3\xF0",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dagsetning og t\xEDmi",
        date: "ISO dagsetning",
        time: "ISO t\xEDmi",
        duration: "ISO t\xEDmalengd",
        ipv4: "IPv4 address",
        ipv6: "IPv6 address",
        cidrv4: "IPv4 range",
        cidrv6: "IPv6 range",
        base64: "base64-encoded strengur",
        base64url: "base64url-encoded strengur",
        json_string: "JSON strengur",
        e164: "E.164 t\xF6lugildi",
        jwt: "JWT",
        template_literal: "gildi"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Rangt gildi: \xDE\xFA sl\xF3st inn ${parsedType4(issue2.input)} \xFEar sem \xE1 a\xF0 vera ${issue2.expected}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Rangt gildi: gert r\xE1\xF0 fyrir ${stringifyPrimitive(issue2.values[0])}`;
            return `\xD3gilt val: m\xE1 vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
            return `Of st\xF3rt: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin ?? "gildi"} s\xE9 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Of l\xEDti\xF0: gert er r\xE1\xF0 fyrir a\xF0 ${issue2.origin} s\xE9 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\xD3gildur strengur: ver\xF0ur a\xF0 byrja \xE1 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 enda \xE1 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 innihalda "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\xD3gildur strengur: ver\xF0ur a\xF0 fylgja mynstri ${_issue.pattern}`;
            return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `R\xF6ng tala: ver\xF0ur a\xF0 vera margfeldi af ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\xD3\xFEekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Rangur lykill \xED ${issue2.origin}`;
          case "invalid_union":
            return "Rangt gildi";
          case "invalid_element":
            return `Rangt gildi \xED ${issue2.origin}`;
          default:
            return `Rangt gildi`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/it.js
function it_default() {
  return {
    localeError: error21()
  };
}
var error21;
var init_it = __esm({
  "node_modules/zod/v4/locales/it.js"() {
    init_util();
    error21 = () => {
      const Sizable = {
        string: { unit: "caratteri", verb: "avere" },
        file: { unit: "byte", verb: "avere" },
        array: { unit: "elementi", verb: "avere" },
        set: { unit: "elementi", verb: "avere" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "vettore";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "input",
        email: "indirizzo email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e ora ISO",
        date: "data ISO",
        time: "ora ISO",
        duration: "durata ISO",
        ipv4: "indirizzo IPv4",
        ipv6: "indirizzo IPv6",
        cidrv4: "intervallo IPv4",
        cidrv6: "intervallo IPv6",
        base64: "stringa codificata in base64",
        base64url: "URL codificata in base64",
        json_string: "stringa JSON",
        e164: "numero E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
            return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
            return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Stringa non valida: deve includere "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chiave non valida in ${issue2.origin}`;
          case "invalid_union":
            return "Input non valido";
          case "invalid_element":
            return `Valore non valido in ${issue2.origin}`;
          default:
            return `Input non valido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ja.js
function ja_default() {
  return {
    localeError: error22()
  };
}
var error22;
var init_ja = __esm({
  "node_modules/zod/v4/locales/ja.js"() {
    init_util();
    error22 = () => {
      const Sizable = {
        string: { unit: "\u6587\u5B57", verb: "\u3067\u3042\u308B" },
        file: { unit: "\u30D0\u30A4\u30C8", verb: "\u3067\u3042\u308B" },
        array: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" },
        set: { unit: "\u8981\u7D20", verb: "\u3067\u3042\u308B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u6570\u5024";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u914D\u5217";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u5165\u529B\u5024",
        email: "\u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9",
        url: "URL",
        emoji: "\u7D75\u6587\u5B57",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u6642",
        date: "ISO\u65E5\u4ED8",
        time: "ISO\u6642\u523B",
        duration: "ISO\u671F\u9593",
        ipv4: "IPv4\u30A2\u30C9\u30EC\u30B9",
        ipv6: "IPv6\u30A2\u30C9\u30EC\u30B9",
        cidrv4: "IPv4\u7BC4\u56F2",
        cidrv6: "IPv6\u7BC4\u56F2",
        base64: "base64\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        base64url: "base64url\u30A8\u30F3\u30B3\u30FC\u30C9\u6587\u5B57\u5217",
        json_string: "JSON\u6587\u5B57\u5217",
        e164: "E.164\u756A\u53F7",
        jwt: "JWT",
        template_literal: "\u5165\u529B\u5024"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u7121\u52B9\u306A\u5165\u529B: ${issue2.expected}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F\u304C\u3001${parsedType8(issue2.input)}\u304C\u5165\u529B\u3055\u308C\u307E\u3057\u305F`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u52B9\u306A\u5165\u529B: ${stringifyPrimitive(issue2.values[0])}\u304C\u671F\u5F85\u3055\u308C\u307E\u3057\u305F`;
            return `\u7121\u52B9\u306A\u9078\u629E: ${joinValues(issue2.values, "\u3001")}\u306E\u3044\u305A\u308C\u304B\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0B\u3067\u3042\u308B" : "\u3088\u308A\u5C0F\u3055\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${sizing.unit ?? "\u8981\u7D20"}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5927\u304D\u3059\u304E\u308B\u5024: ${issue2.origin ?? "\u5024"}\u306F${issue2.maximum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u4EE5\u4E0A\u3067\u3042\u308B" : "\u3088\u308A\u5927\u304D\u3044";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${sizing.unit}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u5C0F\u3055\u3059\u304E\u308B\u5024: ${issue2.origin}\u306F${issue2.minimum.toString()}${adj}\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.prefix}"\u3067\u59CB\u307E\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "ends_with")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.suffix}"\u3067\u7D42\u308F\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "includes")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: "${_issue.includes}"\u3092\u542B\u3080\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            if (_issue.format === "regex")
              return `\u7121\u52B9\u306A\u6587\u5B57\u5217: \u30D1\u30BF\u30FC\u30F3${_issue.pattern}\u306B\u4E00\u81F4\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
            return `\u7121\u52B9\u306A${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u52B9\u306A\u6570\u5024: ${issue2.divisor}\u306E\u500D\u6570\u3067\u3042\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059`;
          case "unrecognized_keys":
            return `\u8A8D\u8B58\u3055\u308C\u3066\u3044\u306A\u3044\u30AD\u30FC${issue2.keys.length > 1 ? "\u7FA4" : ""}: ${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u30AD\u30FC`;
          case "invalid_union":
            return "\u7121\u52B9\u306A\u5165\u529B";
          case "invalid_element":
            return `${issue2.origin}\u5185\u306E\u7121\u52B9\u306A\u5024`;
          default:
            return `\u7121\u52B9\u306A\u5165\u529B`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ka.js
function ka_default() {
  return {
    localeError: error23()
  };
}
var parsedType5, error23;
var init_ka = __esm({
  "node_modules/zod/v4/locales/ka.js"() {
    init_util();
    parsedType5 = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "\u10E0\u10D8\u10EA\u10EE\u10D5\u10D8";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "\u10DB\u10D0\u10E1\u10D8\u10D5\u10D8";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      const typeMap = {
        string: "\u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        boolean: "\u10D1\u10E3\u10DA\u10D4\u10D0\u10DC\u10D8",
        undefined: "undefined",
        bigint: "bigint",
        symbol: "symbol",
        function: "\u10E4\u10E3\u10DC\u10E5\u10EA\u10D8\u10D0"
      };
      return typeMap[t2] ?? t2;
    };
    error23 = () => {
      const Sizable = {
        string: { unit: "\u10E1\u10D8\u10DB\u10D1\u10DD\u10DA\u10DD", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        file: { unit: "\u10D1\u10D0\u10D8\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        array: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" },
        set: { unit: "\u10D4\u10DA\u10D4\u10DB\u10D4\u10DC\u10E2\u10D8", verb: "\u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0",
        email: "\u10D4\u10DA-\u10E4\u10DD\u10E1\u10E2\u10D8\u10E1 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        url: "URL",
        emoji: "\u10D4\u10DB\u10DD\u10EF\u10D8",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8-\u10D3\u10E0\u10DD",
        date: "\u10D7\u10D0\u10E0\u10D8\u10E6\u10D8",
        time: "\u10D3\u10E0\u10DD",
        duration: "\u10EE\u10D0\u10DC\u10D2\u10E0\u10EB\u10DA\u10D8\u10D5\u10DD\u10D1\u10D0",
        ipv4: "IPv4 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        ipv6: "IPv6 \u10DB\u10D8\u10E1\u10D0\u10DB\u10D0\u10E0\u10D7\u10D8",
        cidrv4: "IPv4 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        cidrv6: "IPv6 \u10D3\u10D8\u10D0\u10DE\u10D0\u10D6\u10DD\u10DC\u10D8",
        base64: "base64-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        base64url: "base64url-\u10D9\u10DD\u10D3\u10D8\u10E0\u10D4\u10D1\u10E3\u10DA\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        json_string: "JSON \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8",
        e164: "E.164 \u10DC\u10DD\u10DB\u10D4\u10E0\u10D8",
        jwt: "JWT",
        template_literal: "\u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.expected}, \u10DB\u10D8\u10E6\u10D4\u10D1\u10E3\u10DA\u10D8 ${parsedType5(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D5\u10D0\u10E0\u10D8\u10D0\u10DC\u10E2\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8\u10D0 \u10D4\u10E0\u10D7-\u10D4\u10E0\u10D7\u10D8 ${joinValues(issue2.values, "|")}-\u10D3\u10D0\u10DC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10D3\u10D8\u10D3\u10D8: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin ?? "\u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0"} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u10D6\u10D4\u10D3\u10DB\u10D4\u10E2\u10D0\u10D3 \u10DE\u10D0\u10E2\u10D0\u10E0\u10D0: \u10DB\u10DD\u10E1\u10D0\u10DA\u10DD\u10D3\u10DC\u10D4\u10DA\u10D8 ${issue2.origin} \u10D8\u10E7\u10DD\u10E1 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10EC\u10E7\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.prefix}"-\u10D8\u10D7`;
            }
            if (_issue.format === "ends_with")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10DB\u10D7\u10D0\u10D5\u10E0\u10D3\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 "${_issue.suffix}"-\u10D8\u10D7`;
            if (_issue.format === "includes")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D8\u10EA\u10D0\u10D5\u10D3\u10D4\u10E1 "${_issue.includes}"-\u10E1`;
            if (_issue.format === "regex")
              return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E1\u10E2\u10E0\u10D8\u10DC\u10D2\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10E8\u10D4\u10D4\u10E1\u10D0\u10D1\u10D0\u10DB\u10D4\u10D1\u10DD\u10D3\u10D4\u10E1 \u10E8\u10D0\u10D1\u10DA\u10DD\u10DC\u10E1 ${_issue.pattern}`;
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E0\u10D8\u10EA\u10EE\u10D5\u10D8: \u10E3\u10DC\u10D3\u10D0 \u10D8\u10E7\u10DD\u10E1 ${issue2.divisor}-\u10D8\u10E1 \u10EF\u10D4\u10E0\u10D0\u10D3\u10D8`;
          case "unrecognized_keys":
            return `\u10E3\u10EA\u10DC\u10DD\u10D1\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1${issue2.keys.length > 1 ? "\u10D4\u10D1\u10D8" : "\u10D8"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10D2\u10D0\u10E1\u10D0\u10E6\u10D4\u10D1\u10D8 ${issue2.origin}-\u10E8\u10D8`;
          case "invalid_union":
            return "\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0";
          case "invalid_element":
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10DB\u10DC\u10D8\u10E8\u10D5\u10DC\u10D4\u10DA\u10DD\u10D1\u10D0 ${issue2.origin}-\u10E8\u10D8`;
          default:
            return `\u10D0\u10E0\u10D0\u10E1\u10EC\u10DD\u10E0\u10D8 \u10E8\u10D4\u10E7\u10D5\u10D0\u10DC\u10D0`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/km.js
function km_default() {
  return {
    localeError: error24()
  };
}
var error24;
var init_km = __esm({
  "node_modules/zod/v4/locales/km.js"() {
    init_util();
    error24 = () => {
      const Sizable = {
        string: { unit: "\u178F\u17BD\u17A2\u1780\u17D2\u179F\u179A", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        file: { unit: "\u1794\u17C3", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        array: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" },
        set: { unit: "\u1792\u17B6\u178F\u17BB", verb: "\u1782\u17BD\u179A\u1798\u17B6\u1793" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "\u1798\u17B7\u1793\u1798\u17C2\u1793\u1787\u17B6\u179B\u17C1\u1781 (NaN)" : "\u179B\u17C1\u1781";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u17A2\u17B6\u179A\u17C1 (Array)";
            }
            if (data === null) {
              return "\u1782\u17D2\u1798\u17B6\u1793\u178F\u1798\u17D2\u179B\u17C3 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B",
        email: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793\u17A2\u17CA\u17B8\u1798\u17C2\u179B",
        url: "URL",
        emoji: "\u179F\u1789\u17D2\u1789\u17B6\u17A2\u17B6\u179A\u1798\u17D2\u1798\u178E\u17CD",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 \u1793\u17B7\u1784\u1798\u17C9\u17C4\u1784 ISO",
        date: "\u1780\u17B6\u179B\u1794\u179A\u17B7\u1785\u17D2\u1786\u17C1\u1791 ISO",
        time: "\u1798\u17C9\u17C4\u1784 ISO",
        duration: "\u179A\u1799\u17C8\u1796\u17C1\u179B ISO",
        ipv4: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        ipv6: "\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        cidrv4: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv4",
        cidrv6: "\u178A\u17C2\u1793\u17A2\u17B6\u179F\u1799\u178A\u17D2\u178B\u17B6\u1793 IPv6",
        base64: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64",
        base64url: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u17A2\u17CA\u17B7\u1780\u17BC\u178A base64url",
        json_string: "\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A JSON",
        e164: "\u179B\u17C1\u1781 E.164",
        jwt: "JWT",
        template_literal: "\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.expected} \u1794\u17C9\u17BB\u1793\u17D2\u178F\u17C2\u1791\u1791\u17BD\u179B\u1794\u17B6\u1793 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1794\u1789\u17D2\u1785\u17BC\u179B\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${stringifyPrimitive(issue2.values[0])}`;
            return `\u1787\u1798\u17D2\u179A\u17BE\u179F\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1787\u17B6\u1798\u17BD\u1799\u1780\u17D2\u1793\u17BB\u1784\u1785\u17C6\u178E\u17C4\u1798 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u1792\u17B6\u178F\u17BB"}`;
            return `\u1792\u17C6\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin ?? "\u178F\u1798\u17D2\u179B\u17C3"} ${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u178F\u17BC\u1785\u1796\u17C1\u1780\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1780\u17B6\u179A ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1785\u17B6\u1794\u17CB\u1795\u17D2\u178F\u17BE\u1798\u178A\u17C4\u1799 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1794\u1789\u17D2\u1785\u1794\u17CB\u178A\u17C4\u1799 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u1798\u17B6\u1793 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1781\u17D2\u179F\u17C2\u17A2\u1780\u17D2\u179F\u179A\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1795\u17D2\u1782\u17BC\u1795\u17D2\u1782\u1784\u1793\u17B9\u1784\u1791\u1798\u17D2\u179A\u1784\u17CB\u178A\u17C2\u179B\u1794\u17B6\u1793\u1780\u17C6\u178E\u178F\u17CB ${_issue.pattern}`;
            return `\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u179B\u17C1\u1781\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u17D6 \u178F\u17D2\u179A\u17BC\u179C\u178F\u17C2\u1787\u17B6\u1796\u17A0\u17BB\u1782\u17BB\u178E\u1793\u17C3 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u179A\u1780\u1783\u17BE\u1789\u179F\u17C4\u1798\u17B7\u1793\u179F\u17D2\u1782\u17B6\u179B\u17CB\u17D6 ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u179F\u17C4\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          case "invalid_union":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
          case "invalid_element":
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C\u1793\u17C5\u1780\u17D2\u1793\u17BB\u1784 ${issue2.origin}`;
          default:
            return `\u1791\u17B7\u1793\u17D2\u1793\u1793\u17D0\u1799\u1798\u17B7\u1793\u178F\u17D2\u179A\u17B9\u1798\u178F\u17D2\u179A\u17BC\u179C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}
var init_kh = __esm({
  "node_modules/zod/v4/locales/kh.js"() {
    init_km();
  }
});

// node_modules/zod/v4/locales/ko.js
function ko_default() {
  return {
    localeError: error25()
  };
}
var error25;
var init_ko = __esm({
  "node_modules/zod/v4/locales/ko.js"() {
    init_util();
    error25 = () => {
      const Sizable = {
        string: { unit: "\uBB38\uC790", verb: "to have" },
        file: { unit: "\uBC14\uC774\uD2B8", verb: "to have" },
        array: { unit: "\uAC1C", verb: "to have" },
        set: { unit: "\uAC1C", verb: "to have" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\uC785\uB825",
        email: "\uC774\uBA54\uC77C \uC8FC\uC18C",
        url: "URL",
        emoji: "\uC774\uBAA8\uC9C0",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \uB0A0\uC9DC\uC2DC\uAC04",
        date: "ISO \uB0A0\uC9DC",
        time: "ISO \uC2DC\uAC04",
        duration: "ISO \uAE30\uAC04",
        ipv4: "IPv4 \uC8FC\uC18C",
        ipv6: "IPv6 \uC8FC\uC18C",
        cidrv4: "IPv4 \uBC94\uC704",
        cidrv6: "IPv6 \uBC94\uC704",
        base64: "base64 \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        base64url: "base64url \uC778\uCF54\uB529 \uBB38\uC790\uC5F4",
        json_string: "JSON \uBB38\uC790\uC5F4",
        e164: "E.164 \uBC88\uD638",
        jwt: "JWT",
        template_literal: "\uC785\uB825"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\uC798\uBABB\uB41C \uC785\uB825: \uC608\uC0C1 \uD0C0\uC785\uC740 ${issue2.expected}, \uBC1B\uC740 \uD0C0\uC785\uC740 ${parsedType8(issue2.input)}\uC785\uB2C8\uB2E4`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\uC798\uBABB\uB41C \uC785\uB825: \uAC12\uC740 ${stringifyPrimitive(issue2.values[0])} \uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C \uC635\uC158: ${joinValues(issue2.values, "\uB610\uB294 ")} \uC911 \uD558\uB098\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "too_big": {
            const adj = issue2.inclusive ? "\uC774\uD558" : "\uBBF8\uB9CC";
            const suffix = adj === "\uBBF8\uB9CC" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing)
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uD07D\uB2C8\uB2E4: ${issue2.maximum.toString()} ${adj}${suffix}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\uC774\uC0C1" : "\uCD08\uACFC";
            const suffix = adj === "\uC774\uC0C1" ? "\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4" : "\uC5EC\uC57C \uD569\uB2C8\uB2E4";
            const sizing = getSizing(issue2.origin);
            const unit = sizing?.unit ?? "\uC694\uC18C";
            if (sizing) {
              return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
            }
            return `${issue2.origin ?? "\uAC12"}\uC774 \uB108\uBB34 \uC791\uC2B5\uB2C8\uB2E4: ${issue2.minimum.toString()} ${adj}${suffix}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.prefix}"(\uC73C)\uB85C \uC2DC\uC791\uD574\uC57C \uD569\uB2C8\uB2E4`;
            }
            if (_issue.format === "ends_with")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.suffix}"(\uC73C)\uB85C \uB05D\uB098\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "includes")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: "${_issue.includes}"\uC744(\uB97C) \uD3EC\uD568\uD574\uC57C \uD569\uB2C8\uB2E4`;
            if (_issue.format === "regex")
              return `\uC798\uBABB\uB41C \uBB38\uC790\uC5F4: \uC815\uADDC\uC2DD ${_issue.pattern} \uD328\uD134\uACFC \uC77C\uCE58\uD574\uC57C \uD569\uB2C8\uB2E4`;
            return `\uC798\uBABB\uB41C ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\uC798\uBABB\uB41C \uC22B\uC790: ${issue2.divisor}\uC758 \uBC30\uC218\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
          case "unrecognized_keys":
            return `\uC778\uC2DD\uD560 \uC218 \uC5C6\uB294 \uD0A4: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\uC798\uBABB\uB41C \uD0A4: ${issue2.origin}`;
          case "invalid_union":
            return `\uC798\uBABB\uB41C \uC785\uB825`;
          case "invalid_element":
            return `\uC798\uBABB\uB41C \uAC12: ${issue2.origin}`;
          default:
            return `\uC798\uBABB\uB41C \uC785\uB825`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/lt.js
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
function lt_default() {
  return {
    localeError: error26()
  };
}
var parsedType6, parsedTypeFromType, capitalizeFirstCharacter, error26;
var init_lt = __esm({
  "node_modules/zod/v4/locales/lt.js"() {
    init_util();
    parsedType6 = (data) => {
      const t2 = typeof data;
      return parsedTypeFromType(t2, data);
    };
    parsedTypeFromType = (t2, data = void 0) => {
      switch (t2) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "skai\u010Dius";
        }
        case "bigint": {
          return "sveikasis skai\u010Dius";
        }
        case "string": {
          return "eilut\u0117";
        }
        case "boolean": {
          return "login\u0117 reik\u0161m\u0117";
        }
        case "undefined":
        case "void": {
          return "neapibr\u0117\u017Eta reik\u0161m\u0117";
        }
        case "function": {
          return "funkcija";
        }
        case "symbol": {
          return "simbolis";
        }
        case "object": {
          if (data === void 0)
            return "ne\u017Einomas objektas";
          if (data === null)
            return "nulin\u0117 reik\u0161m\u0117";
          if (Array.isArray(data))
            return "masyvas";
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
          return "objektas";
        }
        case "null": {
          return "nulin\u0117 reik\u0161m\u0117";
        }
      }
      return t2;
    };
    capitalizeFirstCharacter = (text2) => {
      return text2.charAt(0).toUpperCase() + text2.slice(1);
    };
    error26 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "simbolis",
            few: "simboliai",
            many: "simboli\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne ilgesn\u0117 kaip",
              notInclusive: "turi b\u016Bti trumpesn\u0117 kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne trumpesn\u0117 kaip",
              notInclusive: "turi b\u016Bti ilgesn\u0117 kaip"
            }
          }
        },
        file: {
          unit: {
            one: "baitas",
            few: "baitai",
            many: "bait\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi b\u016Bti ne didesnis kaip",
              notInclusive: "turi b\u016Bti ma\u017Eesnis kaip"
            },
            bigger: {
              inclusive: "turi b\u016Bti ne ma\u017Eesnis kaip",
              notInclusive: "turi b\u016Bti didesnis kaip"
            }
          }
        },
        array: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        },
        set: {
          unit: {
            one: "element\u0105",
            few: "elementus",
            many: "element\u0173"
          },
          verb: {
            smaller: {
              inclusive: "turi tur\u0117ti ne daugiau kaip",
              notInclusive: "turi tur\u0117ti ma\u017Eiau kaip"
            },
            bigger: {
              inclusive: "turi tur\u0117ti ne ma\u017Eiau kaip",
              notInclusive: "turi tur\u0117ti daugiau kaip"
            }
          }
        }
      };
      function getSizing(origin, unitType, inclusive, targetShouldBe) {
        const result = Sizable[origin] ?? null;
        if (result === null)
          return result;
        return {
          unit: result.unit[unitType],
          verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
        };
      }
      const Nouns = {
        regex: "\u012Fvestis",
        email: "el. pa\u0161to adresas",
        url: "URL",
        emoji: "jaustukas",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO data ir laikas",
        date: "ISO data",
        time: "ISO laikas",
        duration: "ISO trukm\u0117",
        ipv4: "IPv4 adresas",
        ipv6: "IPv6 adresas",
        cidrv4: "IPv4 tinklo prefiksas (CIDR)",
        cidrv6: "IPv6 tinklo prefiksas (CIDR)",
        base64: "base64 u\u017Ekoduota eilut\u0117",
        base64url: "base64url u\u017Ekoduota eilut\u0117",
        json_string: "JSON eilut\u0117",
        e164: "E.164 numeris",
        jwt: "JWT",
        template_literal: "\u012Fvestis"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Gautas tipas ${parsedType6(issue2.input)}, o tik\u0117tasi - ${parsedTypeFromType(issue2.expected)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Privalo b\u016Bti ${stringifyPrimitive(issue2.values[0])}`;
            return `Privalo b\u016Bti vienas i\u0161 ${joinValues(issue2.values, "|")} pasirinkim\u0173`;
          case "too_big": {
            const origin = parsedTypeFromType(issue2.origin);
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne didesnis kaip" : "ma\u017Eesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.maximum.toString()} ${sizing?.unit}`;
          }
          case "too_small": {
            const origin = parsedTypeFromType(issue2.origin);
            const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
            if (sizing?.verb)
              return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element\u0173"}`;
            const adj = issue2.inclusive ? "ne ma\u017Eesnis kaip" : "didesnis kaip";
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi b\u016Bti ${adj} ${issue2.minimum.toString()} ${sizing?.unit}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Eilut\u0117 privalo prasid\u0117ti "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Eilut\u0117 privalo pasibaigti "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Eilut\u0117 privalo \u012Ftraukti "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Eilut\u0117 privalo atitikti ${_issue.pattern}`;
            return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Skai\u010Dius privalo b\u016Bti ${issue2.divisor} kartotinis.`;
          case "unrecognized_keys":
            return `Neatpa\u017Eint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return "Rastas klaidingas raktas";
          case "invalid_union":
            return "Klaidinga \u012Fvestis";
          case "invalid_element": {
            const origin = parsedTypeFromType(issue2.origin);
            return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reik\u0161m\u0117")} turi klaiding\u0105 \u012Fvest\u012F`;
          }
          default:
            return "Klaidinga \u012Fvestis";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/mk.js
function mk_default() {
  return {
    localeError: error27()
  };
}
var error27;
var init_mk = __esm({
  "node_modules/zod/v4/locales/mk.js"() {
    init_util();
    error27 = () => {
      const Sizable = {
        string: { unit: "\u0437\u043D\u0430\u0446\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        file: { unit: "\u0431\u0430\u0458\u0442\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        array: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" },
        set: { unit: "\u0441\u0442\u0430\u0432\u043A\u0438", verb: "\u0434\u0430 \u0438\u043C\u0430\u0430\u0442" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0431\u0440\u043E\u0458";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043D\u0438\u0437\u0430";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0432\u043D\u0435\u0441",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u043D\u0430 \u0435-\u043F\u043E\u0448\u0442\u0430",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u045F\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0443\u043C \u0438 \u0432\u0440\u0435\u043C\u0435",
        date: "ISO \u0434\u0430\u0442\u0443\u043C",
        time: "ISO \u0432\u0440\u0435\u043C\u0435",
        duration: "ISO \u0432\u0440\u0435\u043C\u0435\u0442\u0440\u0430\u0435\u045A\u0435",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441\u0430",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441\u0430",
        cidrv4: "IPv4 \u043E\u043F\u0441\u0435\u0433",
        cidrv6: "IPv6 \u043E\u043F\u0441\u0435\u0433",
        base64: "base64-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        base64url: "base64url-\u0435\u043D\u043A\u043E\u0434\u0438\u0440\u0430\u043D\u0430 \u043D\u0438\u0437\u0430",
        json_string: "JSON \u043D\u0438\u0437\u0430",
        e164: "E.164 \u0431\u0440\u043E\u0458",
        jwt: "JWT",
        template_literal: "\u0432\u043D\u0435\u0441"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.expected}, \u043F\u0440\u0438\u043C\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0413\u0440\u0435\u0448\u0430\u043D\u0430 \u043E\u043F\u0446\u0438\u0458\u0430: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 \u0435\u0434\u043D\u0430 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0438"}`;
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u0433\u043E\u043B\u0435\u043C: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin ?? "\u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442\u0430"} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0438\u043C\u0430 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u041F\u0440\u0435\u043C\u043D\u043E\u0433\u0443 \u043C\u0430\u043B: \u0441\u0435 \u043E\u0447\u0435\u043A\u0443\u0432\u0430 ${issue2.origin} \u0434\u0430 \u0431\u0438\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u043F\u043E\u0447\u043D\u0443\u0432\u0430 \u0441\u043E "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0437\u0430\u0432\u0440\u0448\u0443\u0432\u0430 \u0441\u043E "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0432\u043A\u043B\u0443\u0447\u0443\u0432\u0430 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0430\u0436\u0435\u0447\u043A\u0430 \u043D\u0438\u0437\u0430: \u043C\u043E\u0440\u0430 \u0434\u0430 \u043E\u0434\u0433\u043E\u0430\u0440\u0430 \u043D\u0430 \u043F\u0430\u0442\u0435\u0440\u043D\u043E\u0442 ${_issue.pattern}`;
            return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0431\u0440\u043E\u0458: \u043C\u043E\u0440\u0430 \u0434\u0430 \u0431\u0438\u0434\u0435 \u0434\u0435\u043B\u0438\u0432 \u0441\u043E ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D\u0438 \u043A\u043B\u0443\u0447\u0435\u0432\u0438" : "\u041D\u0435\u043F\u0440\u0435\u043F\u043E\u0437\u043D\u0430\u0435\u043D \u043A\u043B\u0443\u0447"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u043A\u043B\u0443\u0447 \u0432\u043E ${issue2.origin}`;
          case "invalid_union":
            return "\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441";
          case "invalid_element":
            return `\u0413\u0440\u0435\u0448\u043D\u0430 \u0432\u0440\u0435\u0434\u043D\u043E\u0441\u0442 \u0432\u043E ${issue2.origin}`;
          default:
            return `\u0413\u0440\u0435\u0448\u0435\u043D \u0432\u043D\u0435\u0441`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ms.js
function ms_default() {
  return {
    localeError: error28()
  };
}
var error28;
var init_ms = __esm({
  "node_modules/zod/v4/locales/ms.js"() {
    init_util();
    error28 = () => {
      const Sizable = {
        string: { unit: "aksara", verb: "mempunyai" },
        file: { unit: "bait", verb: "mempunyai" },
        array: { unit: "elemen", verb: "mempunyai" },
        set: { unit: "elemen", verb: "mempunyai" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "nombor";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "input",
        email: "alamat e-mel",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "tarikh masa ISO",
        date: "tarikh ISO",
        time: "masa ISO",
        duration: "tempoh ISO",
        ipv4: "alamat IPv4",
        ipv6: "alamat IPv6",
        cidrv4: "julat IPv4",
        cidrv6: "julat IPv6",
        base64: "string dikodkan base64",
        base64url: "string dikodkan base64url",
        json_string: "string JSON",
        e164: "nombor E.164",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
            return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
            return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
          }
          case "not_multiple_of":
            return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kunci tidak sah dalam ${issue2.origin}`;
          case "invalid_union":
            return "Input tidak sah";
          case "invalid_element":
            return `Nilai tidak sah dalam ${issue2.origin}`;
          default:
            return `Input tidak sah`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/nl.js
function nl_default() {
  return {
    localeError: error29()
  };
}
var error29;
var init_nl = __esm({
  "node_modules/zod/v4/locales/nl.js"() {
    init_util();
    error29 = () => {
      const Sizable = {
        string: { unit: "tekens", verb: "te hebben" },
        file: { unit: "bytes", verb: "te hebben" },
        array: { unit: "elementen", verb: "te hebben" },
        set: { unit: "elementen", verb: "te hebben" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "getal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "invoer",
        email: "emailadres",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum en tijd",
        date: "ISO datum",
        time: "ISO tijd",
        duration: "ISO duur",
        ipv4: "IPv4-adres",
        ipv6: "IPv6-adres",
        cidrv4: "IPv4-bereik",
        cidrv6: "IPv6-bereik",
        base64: "base64-gecodeerde tekst",
        base64url: "base64 URL-gecodeerde tekst",
        json_string: "JSON string",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "invoer"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
            return `Ongeldige optie: verwacht \xE9\xE9n van ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Te groot: verwacht dat ${issue2.origin ?? "waarde"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"}`;
            return `Te groot: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Te klein: verwacht dat ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Te klein: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
            }
            if (_issue.format === "ends_with")
              return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
            if (_issue.format === "includes")
              return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
            if (_issue.format === "regex")
              return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
            return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
          case "unrecognized_keys":
            return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ongeldige key in ${issue2.origin}`;
          case "invalid_union":
            return "Ongeldige invoer";
          case "invalid_element":
            return `Ongeldige waarde in ${issue2.origin}`;
          default:
            return `Ongeldige invoer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/no.js
function no_default() {
  return {
    localeError: error30()
  };
}
var error30;
var init_no = __esm({
  "node_modules/zod/v4/locales/no.js"() {
    init_util();
    error30 = () => {
      const Sizable = {
        string: { unit: "tegn", verb: "\xE5 ha" },
        file: { unit: "bytes", verb: "\xE5 ha" },
        array: { unit: "elementer", verb: "\xE5 inneholde" },
        set: { unit: "elementer", verb: "\xE5 inneholde" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "tall";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "liste";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "input",
        email: "e-postadresse",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO dato- og klokkeslett",
        date: "ISO-dato",
        time: "ISO-klokkeslett",
        duration: "ISO-varighet",
        ipv4: "IPv4-omr\xE5de",
        ipv6: "IPv6-omr\xE5de",
        cidrv4: "IPv4-spekter",
        cidrv6: "IPv6-spekter",
        base64: "base64-enkodet streng",
        base64url: "base64url-enkodet streng",
        json_string: "JSON-streng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
            return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
            return `For stor(t): forventet ${issue2.origin ?? "value"} til \xE5 ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `For lite(n): forventet ${issue2.origin} til \xE5 ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ugyldig streng: m\xE5 starte med "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Ugyldig streng: m\xE5 ende med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ugyldig streng: m\xE5 inneholde "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ugyldig streng: m\xE5 matche m\xF8nsteret ${_issue.pattern}`;
            return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ugyldig tall: m\xE5 v\xE6re et multiplum av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ukjente n\xF8kler" : "Ukjent n\xF8kkel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ugyldig n\xF8kkel i ${issue2.origin}`;
          case "invalid_union":
            return "Ugyldig input";
          case "invalid_element":
            return `Ugyldig verdi i ${issue2.origin}`;
          default:
            return `Ugyldig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ota.js
function ota_default() {
  return {
    localeError: error31()
  };
}
var error31;
var init_ota = __esm({
  "node_modules/zod/v4/locales/ota.js"() {
    init_util();
    error31 = () => {
      const Sizable = {
        string: { unit: "harf", verb: "olmal\u0131d\u0131r" },
        file: { unit: "bayt", verb: "olmal\u0131d\u0131r" },
        array: { unit: "unsur", verb: "olmal\u0131d\u0131r" },
        set: { unit: "unsur", verb: "olmal\u0131d\u0131r" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "numara";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "saf";
            }
            if (data === null) {
              return "gayb";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "giren",
        email: "epostag\xE2h",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO heng\xE2m\u0131",
        date: "ISO tarihi",
        time: "ISO zaman\u0131",
        duration: "ISO m\xFCddeti",
        ipv4: "IPv4 ni\u015F\xE2n\u0131",
        ipv6: "IPv6 ni\u015F\xE2n\u0131",
        cidrv4: "IPv4 menzili",
        cidrv6: "IPv6 menzili",
        base64: "base64-\u015Fifreli metin",
        base64url: "base64url-\u015Fifreli metin",
        json_string: "JSON metin",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "giren"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `F\xE2sit giren: umulan ${issue2.expected}, al\u0131nan ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `F\xE2sit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
            return `F\xE2sit tercih: m\xFBteberler ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmal\u0131yd\u0131.`;
            return `Fazla b\xFCy\xFCk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmal\u0131yd\u0131.`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmal\u0131yd\u0131.`;
            }
            return `Fazla k\xFC\xE7\xFCk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmal\u0131yd\u0131.`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `F\xE2sit metin: "${_issue.prefix}" ile ba\u015Flamal\u0131.`;
            if (_issue.format === "ends_with")
              return `F\xE2sit metin: "${_issue.suffix}" ile bitmeli.`;
            if (_issue.format === "includes")
              return `F\xE2sit metin: "${_issue.includes}" ihtiv\xE2 etmeli.`;
            if (_issue.format === "regex")
              return `F\xE2sit metin: ${_issue.pattern} nak\u015F\u0131na uymal\u0131.`;
            return `F\xE2sit ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `F\xE2sit say\u0131: ${issue2.divisor} kat\u0131 olmal\u0131yd\u0131.`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7in tan\u0131nmayan anahtar var.`;
          case "invalid_union":
            return "Giren tan\u0131namad\u0131.";
          case "invalid_element":
            return `${issue2.origin} i\xE7in tan\u0131nmayan k\u0131ymet var.`;
          default:
            return `K\u0131ymet tan\u0131namad\u0131.`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ps.js
function ps_default() {
  return {
    localeError: error32()
  };
}
var error32;
var init_ps = __esm({
  "node_modules/zod/v4/locales/ps.js"() {
    init_util();
    error32 = () => {
      const Sizable = {
        string: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        file: { unit: "\u0628\u0627\u06CC\u067C\u0633", verb: "\u0648\u0644\u0631\u064A" },
        array: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" },
        set: { unit: "\u062A\u0648\u06A9\u064A", verb: "\u0648\u0644\u0631\u064A" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0639\u062F\u062F";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0627\u0631\u06D0";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0648\u0631\u0648\u062F\u064A",
        email: "\u0628\u0631\u06CC\u069A\u0646\u0627\u0644\u06CC\u06A9",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u064A",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0646\u06CC\u067C\u0647 \u0627\u0648 \u0648\u062E\u062A",
        date: "\u0646\u06D0\u067C\u0647",
        time: "\u0648\u062E\u062A",
        duration: "\u0645\u0648\u062F\u0647",
        ipv4: "\u062F IPv4 \u067E\u062A\u0647",
        ipv6: "\u062F IPv6 \u067E\u062A\u0647",
        cidrv4: "\u062F IPv4 \u0633\u0627\u062D\u0647",
        cidrv6: "\u062F IPv6 \u0633\u0627\u062D\u0647",
        base64: "base64-encoded \u0645\u062A\u0646",
        base64url: "base64url-encoded \u0645\u062A\u0646",
        json_string: "JSON \u0645\u062A\u0646",
        e164: "\u062F E.164 \u0634\u0645\u06D0\u0631\u0647",
        jwt: "JWT",
        template_literal: "\u0648\u0631\u0648\u062F\u064A"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${issue2.expected} \u0648\u0627\u06CC, \u0645\u06AB\u0631 ${parsedType8(issue2.input)} \u062A\u0631\u0644\u0627\u0633\u0647 \u0634\u0648`;
          case "invalid_value":
            if (issue2.values.length === 1) {
              return `\u0646\u0627\u0633\u0645 \u0648\u0631\u0648\u062F\u064A: \u0628\u0627\u06CC\u062F ${stringifyPrimitive(issue2.values[0])} \u0648\u0627\u06CC`;
            }
            return `\u0646\u0627\u0633\u0645 \u0627\u0646\u062A\u062E\u0627\u0628: \u0628\u0627\u06CC\u062F \u06CC\u0648 \u0644\u0647 ${joinValues(issue2.values, "|")} \u0685\u062E\u0647 \u0648\u0627\u06CC`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0635\u0631\u0648\u0646\u0647"} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u0644\u0648\u06CC: ${issue2.origin ?? "\u0627\u0631\u0632\u069A\u062A"} \u0628\u0627\u06CC\u062F ${adj}${issue2.maximum.toString()} \u0648\u064A`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0648\u0644\u0631\u064A`;
            }
            return `\u0689\u06CC\u0631 \u06A9\u0648\u0686\u0646\u06CC: ${issue2.origin} \u0628\u0627\u06CC\u062F ${adj}${issue2.minimum.toString()} \u0648\u064A`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.prefix}" \u0633\u0631\u0647 \u067E\u06CC\u0644 \u0634\u064A`;
            }
            if (_issue.format === "ends_with") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F "${_issue.suffix}" \u0633\u0631\u0647 \u067E\u0627\u06CC \u062A\u0647 \u0648\u0631\u0633\u064A\u0696\u064A`;
            }
            if (_issue.format === "includes") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F "${_issue.includes}" \u0648\u0644\u0631\u064A`;
            }
            if (_issue.format === "regex") {
              return `\u0646\u0627\u0633\u0645 \u0645\u062A\u0646: \u0628\u0627\u06CC\u062F \u062F ${_issue.pattern} \u0633\u0631\u0647 \u0645\u0637\u0627\u0628\u0642\u062A \u0648\u0644\u0631\u064A`;
            }
            return `${Nouns[_issue.format] ?? issue2.format} \u0646\u0627\u0633\u0645 \u062F\u06CC`;
          }
          case "not_multiple_of":
            return `\u0646\u0627\u0633\u0645 \u0639\u062F\u062F: \u0628\u0627\u06CC\u062F \u062F ${issue2.divisor} \u0645\u0636\u0631\u0628 \u0648\u064A`;
          case "unrecognized_keys":
            return `\u0646\u0627\u0633\u0645 ${issue2.keys.length > 1 ? "\u06A9\u0644\u06CC\u0689\u0648\u0646\u0647" : "\u06A9\u0644\u06CC\u0689"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0646\u0627\u0633\u0645 \u06A9\u0644\u06CC\u0689 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          case "invalid_union":
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
          case "invalid_element":
            return `\u0646\u0627\u0633\u0645 \u0639\u0646\u0635\u0631 \u067E\u0647 ${issue2.origin} \u06A9\u06D0`;
          default:
            return `\u0646\u0627\u0633\u0645\u0647 \u0648\u0631\u0648\u062F\u064A`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pl.js
function pl_default() {
  return {
    localeError: error33()
  };
}
var error33;
var init_pl = __esm({
  "node_modules/zod/v4/locales/pl.js"() {
    init_util();
    error33 = () => {
      const Sizable = {
        string: { unit: "znak\xF3w", verb: "mie\u0107" },
        file: { unit: "bajt\xF3w", verb: "mie\u0107" },
        array: { unit: "element\xF3w", verb: "mie\u0107" },
        set: { unit: "element\xF3w", verb: "mie\u0107" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "liczba";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tablica";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "wyra\u017Cenie",
        email: "adres email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data i godzina w formacie ISO",
        date: "data w formacie ISO",
        time: "godzina w formacie ISO",
        duration: "czas trwania ISO",
        ipv4: "adres IPv4",
        ipv6: "adres IPv6",
        cidrv4: "zakres IPv4",
        cidrv6: "zakres IPv6",
        base64: "ci\u0105g znak\xF3w zakodowany w formacie base64",
        base64url: "ci\u0105g znak\xF3w zakodowany w formacie base64url",
        json_string: "ci\u0105g znak\xF3w w formacie JSON",
        e164: "liczba E.164",
        jwt: "JWT",
        template_literal: "wej\u015Bcie"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Nieprawid\u0142owe dane wej\u015Bciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
            return `Nieprawid\u0142owa opcja: oczekiwano jednej z warto\u015Bci ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za du\u017Ca warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt du\u017C(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Za ma\u0142a warto\u015B\u0107: oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie mie\u0107 ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "element\xF3w"}`;
            }
            return `Zbyt ma\u0142(y/a/e): oczekiwano, \u017Ce ${issue2.origin ?? "warto\u015B\u0107"} b\u0119dzie wynosi\u0107 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zaczyna\u0107 si\u0119 od "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi ko\u0144czy\u0107 si\u0119 na "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi zawiera\u0107 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Nieprawid\u0142owy ci\u0105g znak\xF3w: musi odpowiada\u0107 wzorcowi ${_issue.pattern}`;
            return `Nieprawid\u0142ow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Nieprawid\u0142owa liczba: musi by\u0107 wielokrotno\u015Bci\u0105 ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Nieprawid\u0142owy klucz w ${issue2.origin}`;
          case "invalid_union":
            return "Nieprawid\u0142owe dane wej\u015Bciowe";
          case "invalid_element":
            return `Nieprawid\u0142owa warto\u015B\u0107 w ${issue2.origin}`;
          default:
            return `Nieprawid\u0142owe dane wej\u015Bciowe`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/pt.js
function pt_default() {
  return {
    localeError: error34()
  };
}
var error34;
var init_pt = __esm({
  "node_modules/zod/v4/locales/pt.js"() {
    init_util();
    error34 = () => {
      const Sizable = {
        string: { unit: "caracteres", verb: "ter" },
        file: { unit: "bytes", verb: "ter" },
        array: { unit: "itens", verb: "ter" },
        set: { unit: "itens", verb: "ter" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\xFAmero";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "nulo";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "padr\xE3o",
        email: "endere\xE7o de e-mail",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "data e hora ISO",
        date: "data ISO",
        time: "hora ISO",
        duration: "dura\xE7\xE3o ISO",
        ipv4: "endere\xE7o IPv4",
        ipv6: "endere\xE7o IPv6",
        cidrv4: "faixa de IPv4",
        cidrv6: "faixa de IPv6",
        base64: "texto codificado em base64",
        base64url: "URL codificada em base64",
        json_string: "texto JSON",
        e164: "n\xFAmero E.164",
        jwt: "JWT",
        template_literal: "entrada"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Tipo inv\xE1lido: esperado ${issue2.expected}, recebido ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Entrada inv\xE1lida: esperado ${stringifyPrimitive(issue2.values[0])}`;
            return `Op\xE7\xE3o inv\xE1lida: esperada uma das ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
            return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Texto inv\xE1lido: deve come\xE7ar com "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Texto inv\xE1lido: deve terminar com "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Texto inv\xE1lido: deve incluir "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Texto inv\xE1lido: deve corresponder ao padr\xE3o ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} inv\xE1lido`;
          }
          case "not_multiple_of":
            return `N\xFAmero inv\xE1lido: deve ser m\xFAltiplo de ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Chave inv\xE1lida em ${issue2.origin}`;
          case "invalid_union":
            return "Entrada inv\xE1lida";
          case "invalid_element":
            return `Valor inv\xE1lido em ${issue2.origin}`;
          default:
            return `Campo inv\xE1lido`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
function ru_default() {
  return {
    localeError: error35()
  };
}
var error35;
var init_ru = __esm({
  "node_modules/zod/v4/locales/ru.js"() {
    init_util();
    error35 = () => {
      const Sizable = {
        string: {
          unit: {
            one: "\u0441\u0438\u043C\u0432\u043E\u043B",
            few: "\u0441\u0438\u043C\u0432\u043E\u043B\u0430",
            many: "\u0441\u0438\u043C\u0432\u043E\u043B\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        file: {
          unit: {
            one: "\u0431\u0430\u0439\u0442",
            few: "\u0431\u0430\u0439\u0442\u0430",
            many: "\u0431\u0430\u0439\u0442"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        array: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        },
        set: {
          unit: {
            one: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442",
            few: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430",
            many: "\u044D\u043B\u0435\u043C\u0435\u043D\u0442\u043E\u0432"
          },
          verb: "\u0438\u043C\u0435\u0442\u044C"
        }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0432\u0432\u043E\u0434",
        email: "email \u0430\u0434\u0440\u0435\u0441",
        url: "URL",
        emoji: "\u044D\u043C\u043E\u0434\u0437\u0438",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0434\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043C\u044F",
        date: "ISO \u0434\u0430\u0442\u0430",
        time: "ISO \u0432\u0440\u0435\u043C\u044F",
        duration: "ISO \u0434\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        ipv4: "IPv4 \u0430\u0434\u0440\u0435\u0441",
        ipv6: "IPv6 \u0430\u0434\u0440\u0435\u0441",
        cidrv4: "IPv4 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        cidrv6: "IPv6 \u0434\u0438\u0430\u043F\u0430\u0437\u043E\u043D",
        base64: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64",
        base64url: "\u0441\u0442\u0440\u043E\u043A\u0430 \u0432 \u0444\u043E\u0440\u043C\u0430\u0442\u0435 base64url",
        json_string: "JSON \u0441\u0442\u0440\u043E\u043A\u0430",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0432\u043E\u0434"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${issue2.expected}, \u043F\u043E\u043B\u0443\u0447\u0435\u043D\u043E ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0432\u043E\u0434: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0432\u0430\u0440\u0438\u0430\u043D\u0442: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0434\u043D\u043E \u0438\u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const maxValue = Number(issue2.maximum);
              const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.maximum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435"} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              const minValue = Number(issue2.minimum);
              const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
              return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 \u0438\u043C\u0435\u0442\u044C ${adj}${issue2.minimum.toString()} ${unit}`;
            }
            return `\u0421\u043B\u0438\u0448\u043A\u043E\u043C \u043C\u0430\u043B\u0435\u043D\u044C\u043A\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435: \u043E\u0436\u0438\u0434\u0430\u043B\u043E\u0441\u044C, \u0447\u0442\u043E ${issue2.origin} \u0431\u0443\u0434\u0435\u0442 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u0432\u0435\u0440\u043D\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430: \u0434\u043E\u043B\u0436\u043D\u0430 \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u043E\u0432\u0430\u0442\u044C \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0447\u0438\u0441\u043B\u043E: \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043A\u0440\u0430\u0442\u043D\u044B\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u0430\u0441\u043F\u043E\u0437\u043D\u0430\u043D\u043D${issue2.keys.length > 1 ? "\u044B\u0435" : "\u044B\u0439"} \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0438" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u043A\u043B\u044E\u0447 \u0432 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435";
          case "invalid_element":
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0432 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0435 \u0432\u0445\u043E\u0434\u043D\u044B\u0435 \u0434\u0430\u043D\u043D\u044B\u0435`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sl.js
function sl_default() {
  return {
    localeError: error36()
  };
}
var error36;
var init_sl = __esm({
  "node_modules/zod/v4/locales/sl.js"() {
    init_util();
    error36 = () => {
      const Sizable = {
        string: { unit: "znakov", verb: "imeti" },
        file: { unit: "bajtov", verb: "imeti" },
        array: { unit: "elementov", verb: "imeti" },
        set: { unit: "elementov", verb: "imeti" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0161tevilo";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "tabela";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "vnos",
        email: "e-po\u0161tni naslov",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO datum in \u010Das",
        date: "ISO datum",
        time: "ISO \u010Das",
        duration: "ISO trajanje",
        ipv4: "IPv4 naslov",
        ipv6: "IPv6 naslov",
        cidrv4: "obseg IPv4",
        cidrv6: "obseg IPv6",
        base64: "base64 kodiran niz",
        base64url: "base64url kodiran niz",
        json_string: "JSON niz",
        e164: "E.164 \u0161tevilka",
        jwt: "JWT",
        template_literal: "vnos"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Neveljaven vnos: pri\u010Dakovano ${issue2.expected}, prejeto ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Neveljaven vnos: pri\u010Dakovano ${stringifyPrimitive(issue2.values[0])}`;
            return `Neveljavna mo\u017Enost: pri\u010Dakovano eno izmed ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
            return `Preveliko: pri\u010Dakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Premajhno: pri\u010Dakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Neveljaven niz: mora se za\u010Deti z "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Neveljaven niz: mora se kon\u010Dati z "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
            return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Neveljavno \u0161tevilo: mora biti ve\u010Dkratnik ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Neprepoznan${issue2.keys.length > 1 ? "i klju\u010Di" : " klju\u010D"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Neveljaven klju\u010D v ${issue2.origin}`;
          case "invalid_union":
            return "Neveljaven vnos";
          case "invalid_element":
            return `Neveljavna vrednost v ${issue2.origin}`;
          default:
            return "Neveljaven vnos";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/sv.js
function sv_default() {
  return {
    localeError: error37()
  };
}
var error37;
var init_sv = __esm({
  "node_modules/zod/v4/locales/sv.js"() {
    init_util();
    error37 = () => {
      const Sizable = {
        string: { unit: "tecken", verb: "att ha" },
        file: { unit: "bytes", verb: "att ha" },
        array: { unit: "objekt", verb: "att inneh\xE5lla" },
        set: { unit: "objekt", verb: "att inneh\xE5lla" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "antal";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "lista";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "regulj\xE4rt uttryck",
        email: "e-postadress",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO-datum och tid",
        date: "ISO-datum",
        time: "ISO-tid",
        duration: "ISO-varaktighet",
        ipv4: "IPv4-intervall",
        ipv6: "IPv6-intervall",
        cidrv4: "IPv4-spektrum",
        cidrv6: "IPv6-spektrum",
        base64: "base64-kodad str\xE4ng",
        base64url: "base64url-kodad str\xE4ng",
        json_string: "JSON-str\xE4ng",
        e164: "E.164-nummer",
        jwt: "JWT",
        template_literal: "mall-literal"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ogiltig inmatning: f\xF6rv\xE4ntat ${issue2.expected}, fick ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ogiltig inmatning: f\xF6rv\xE4ntat ${stringifyPrimitive(issue2.values[0])}`;
            return `Ogiltigt val: f\xF6rv\xE4ntade en av ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r stor(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
            }
            return `F\xF6r stor(t): f\xF6rv\xE4ntat ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `F\xF6r lite(t): f\xF6rv\xE4ntade ${issue2.origin ?? "v\xE4rdet"} att ha ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `Ogiltig str\xE4ng: m\xE5ste b\xF6rja med "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `Ogiltig str\xE4ng: m\xE5ste sluta med "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Ogiltig str\xE4ng: m\xE5ste inneh\xE5lla "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Ogiltig str\xE4ng: m\xE5ste matcha m\xF6nstret "${_issue.pattern}"`;
            return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ogiltigt tal: m\xE5ste vara en multipel av ${issue2.divisor}`;
          case "unrecognized_keys":
            return `${issue2.keys.length > 1 ? "Ok\xE4nda nycklar" : "Ok\xE4nd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Ogiltig nyckel i ${issue2.origin ?? "v\xE4rdet"}`;
          case "invalid_union":
            return "Ogiltig input";
          case "invalid_element":
            return `Ogiltigt v\xE4rde i ${issue2.origin ?? "v\xE4rdet"}`;
          default:
            return `Ogiltig input`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ta.js
function ta_default() {
  return {
    localeError: error38()
  };
}
var error38;
var init_ta = __esm({
  "node_modules/zod/v4/locales/ta.js"() {
    init_util();
    error38 = () => {
      const Sizable = {
        string: { unit: "\u0B8E\u0BB4\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        file: { unit: "\u0BAA\u0BC8\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        array: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" },
        set: { unit: "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD", verb: "\u0B95\u0BCA\u0BA3\u0BCD\u0B9F\u0BBF\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "\u0B8E\u0BA3\u0BCD \u0B85\u0BB2\u0BCD\u0BB2\u0BBE\u0BA4\u0BA4\u0BC1" : "\u0B8E\u0BA3\u0BCD";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0B85\u0BA3\u0BBF";
            }
            if (data === null) {
              return "\u0BB5\u0BC6\u0BB1\u0BC1\u0BAE\u0BC8";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1",
        email: "\u0BAE\u0BBF\u0BA9\u0BCD\u0BA9\u0B9E\u0BCD\u0B9A\u0BB2\u0BCD \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u0BA4\u0BC7\u0BA4\u0BBF \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        date: "ISO \u0BA4\u0BC7\u0BA4\u0BBF",
        time: "ISO \u0BA8\u0BC7\u0BB0\u0BAE\u0BCD",
        duration: "ISO \u0B95\u0BBE\u0BB2 \u0B85\u0BB3\u0BB5\u0BC1",
        ipv4: "IPv4 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        ipv6: "IPv6 \u0BAE\u0BC1\u0B95\u0BB5\u0BB0\u0BBF",
        cidrv4: "IPv4 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        cidrv6: "IPv6 \u0BB5\u0BB0\u0BAE\u0BCD\u0BAA\u0BC1",
        base64: "base64-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        base64url: "base64url-encoded \u0B9A\u0BB0\u0BAE\u0BCD",
        json_string: "JSON \u0B9A\u0BB0\u0BAE\u0BCD",
        e164: "E.164 \u0B8E\u0BA3\u0BCD",
        jwt: "JWT",
        template_literal: "input"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.expected}, \u0BAA\u0BC6\u0BB1\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0BB0\u0BC1\u0BAA\u0BCD\u0BAA\u0BAE\u0BCD: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${joinValues(issue2.values, "|")} \u0B87\u0BB2\u0BCD \u0B92\u0BA9\u0BCD\u0BB1\u0BC1`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0B89\u0BB1\u0BC1\u0BAA\u0BCD\u0BAA\u0BC1\u0B95\u0BB3\u0BCD"} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95 \u0BAA\u0BC6\u0BB0\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin ?? "\u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1"} ${adj}${issue2.maximum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            }
            return `\u0BAE\u0BBF\u0B95\u0B9A\u0BCD \u0B9A\u0BBF\u0BB1\u0BBF\u0BAF\u0BA4\u0BC1: \u0B8E\u0BA4\u0BBF\u0BB0\u0BCD\u0BAA\u0BBE\u0BB0\u0BCD\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F\u0BA4\u0BC1 ${issue2.origin} ${adj}${issue2.minimum.toString()} \u0B86\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.prefix}" \u0B87\u0BB2\u0BCD \u0BA4\u0BCA\u0B9F\u0B99\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "ends_with")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.suffix}" \u0B87\u0BB2\u0BCD \u0BAE\u0BC1\u0B9F\u0BBF\u0BB5\u0B9F\u0BC8\u0BAF \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "includes")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: "${_issue.includes}" \u0B90 \u0B89\u0BB3\u0BCD\u0BB3\u0B9F\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            if (_issue.format === "regex")
              return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B9A\u0BB0\u0BAE\u0BCD: ${_issue.pattern} \u0BAE\u0BC1\u0BB1\u0BC8\u0BAA\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B9F\u0BA9\u0BCD \u0BAA\u0BCA\u0BB0\u0BC1\u0BA8\u0BCD\u0BA4 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B8E\u0BA3\u0BCD: ${issue2.divisor} \u0B87\u0BA9\u0BCD \u0BAA\u0BB2\u0BAE\u0BBE\u0B95 \u0B87\u0BB0\u0BC1\u0B95\u0BCD\u0B95 \u0BB5\u0BC7\u0BA3\u0BCD\u0B9F\u0BC1\u0BAE\u0BCD`;
          case "unrecognized_keys":
            return `\u0B85\u0B9F\u0BC8\u0BAF\u0BBE\u0BB3\u0BAE\u0BCD \u0BA4\u0BC6\u0BB0\u0BBF\u0BAF\u0BBE\u0BA4 \u0BB5\u0BBF\u0B9A\u0BC8${issue2.keys.length > 1 ? "\u0B95\u0BB3\u0BCD" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BB5\u0BBF\u0B9A\u0BC8`;
          case "invalid_union":
            return "\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1";
          case "invalid_element":
            return `${issue2.origin} \u0B87\u0BB2\u0BCD \u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0BAE\u0BA4\u0BBF\u0BAA\u0BCD\u0BAA\u0BC1`;
          default:
            return `\u0BA4\u0BB5\u0BB1\u0BBE\u0BA9 \u0B89\u0BB3\u0BCD\u0BB3\u0BC0\u0B9F\u0BC1`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/th.js
function th_default() {
  return {
    localeError: error39()
  };
}
var error39;
var init_th = __esm({
  "node_modules/zod/v4/locales/th.js"() {
    init_util();
    error39 = () => {
      const Sizable = {
        string: { unit: "\u0E15\u0E31\u0E27\u0E2D\u0E31\u0E01\u0E29\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        file: { unit: "\u0E44\u0E1A\u0E15\u0E4C", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        array: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" },
        set: { unit: "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23", verb: "\u0E04\u0E27\u0E23\u0E21\u0E35" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "\u0E44\u0E21\u0E48\u0E43\u0E0A\u0E48\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02 (NaN)" : "\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0E2D\u0E32\u0E23\u0E4C\u0E40\u0E23\u0E22\u0E4C (Array)";
            }
            if (data === null) {
              return "\u0E44\u0E21\u0E48\u0E21\u0E35\u0E04\u0E48\u0E32 (null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19",
        email: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48\u0E2D\u0E35\u0E40\u0E21\u0E25",
        url: "URL",
        emoji: "\u0E2D\u0E34\u0E42\u0E21\u0E08\u0E34",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        date: "\u0E27\u0E31\u0E19\u0E17\u0E35\u0E48\u0E41\u0E1A\u0E1A ISO",
        time: "\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        duration: "\u0E0A\u0E48\u0E27\u0E07\u0E40\u0E27\u0E25\u0E32\u0E41\u0E1A\u0E1A ISO",
        ipv4: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv4",
        ipv6: "\u0E17\u0E35\u0E48\u0E2D\u0E22\u0E39\u0E48 IPv6",
        cidrv4: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv4",
        cidrv6: "\u0E0A\u0E48\u0E27\u0E07 IP \u0E41\u0E1A\u0E1A IPv6",
        base64: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64",
        base64url: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A Base64 \u0E2A\u0E33\u0E2B\u0E23\u0E31\u0E1A URL",
        json_string: "\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E41\u0E1A\u0E1A JSON",
        e164: "\u0E40\u0E1A\u0E2D\u0E23\u0E4C\u0E42\u0E17\u0E23\u0E28\u0E31\u0E1E\u0E17\u0E4C\u0E23\u0E30\u0E2B\u0E27\u0E48\u0E32\u0E07\u0E1B\u0E23\u0E30\u0E40\u0E17\u0E28 (E.164)",
        jwt: "\u0E42\u0E17\u0E40\u0E04\u0E19 JWT",
        template_literal: "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E17\u0E35\u0E48\u0E1B\u0E49\u0E2D\u0E19"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0E1B\u0E23\u0E30\u0E40\u0E20\u0E17\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${issue2.expected} \u0E41\u0E15\u0E48\u0E44\u0E14\u0E49\u0E23\u0E31\u0E1A ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0E04\u0E48\u0E32\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19 ${stringifyPrimitive(issue2.values[0])}`;
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E37\u0E2D\u0E01\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E04\u0E27\u0E23\u0E40\u0E1B\u0E47\u0E19\u0E2B\u0E19\u0E36\u0E48\u0E07\u0E43\u0E19 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "\u0E44\u0E21\u0E48\u0E40\u0E01\u0E34\u0E19" : "\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "\u0E23\u0E32\u0E22\u0E01\u0E32\u0E23"}`;
            return `\u0E40\u0E01\u0E34\u0E19\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin ?? "\u0E04\u0E48\u0E32"} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? "\u0E2D\u0E22\u0E48\u0E32\u0E07\u0E19\u0E49\u0E2D\u0E22" : "\u0E21\u0E32\u0E01\u0E01\u0E27\u0E48\u0E32";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0E19\u0E49\u0E2D\u0E22\u0E01\u0E27\u0E48\u0E32\u0E01\u0E33\u0E2B\u0E19\u0E14: ${issue2.origin} \u0E04\u0E27\u0E23\u0E21\u0E35${adj} ${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E02\u0E36\u0E49\u0E19\u0E15\u0E49\u0E19\u0E14\u0E49\u0E27\u0E22 "${_issue.prefix}"`;
            }
            if (_issue.format === "ends_with")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E25\u0E07\u0E17\u0E49\u0E32\u0E22\u0E14\u0E49\u0E27\u0E22 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E21\u0E35 "${_issue.includes}" \u0E2D\u0E22\u0E39\u0E48\u0E43\u0E19\u0E02\u0E49\u0E2D\u0E04\u0E27\u0E32\u0E21`;
            if (_issue.format === "regex")
              return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14 ${_issue.pattern}`;
            return `\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u0E15\u0E31\u0E27\u0E40\u0E25\u0E02\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E15\u0E49\u0E2D\u0E07\u0E40\u0E1B\u0E47\u0E19\u0E08\u0E33\u0E19\u0E27\u0E19\u0E17\u0E35\u0E48\u0E2B\u0E32\u0E23\u0E14\u0E49\u0E27\u0E22 ${issue2.divisor} \u0E44\u0E14\u0E49\u0E25\u0E07\u0E15\u0E31\u0E27`;
          case "unrecognized_keys":
            return `\u0E1E\u0E1A\u0E04\u0E35\u0E22\u0E4C\u0E17\u0E35\u0E48\u0E44\u0E21\u0E48\u0E23\u0E39\u0E49\u0E08\u0E31\u0E01: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u0E04\u0E35\u0E22\u0E4C\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          case "invalid_union":
            return "\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07: \u0E44\u0E21\u0E48\u0E15\u0E23\u0E07\u0E01\u0E31\u0E1A\u0E23\u0E39\u0E1B\u0E41\u0E1A\u0E1A\u0E22\u0E39\u0E40\u0E19\u0E35\u0E22\u0E19\u0E17\u0E35\u0E48\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E44\u0E27\u0E49";
          case "invalid_element":
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07\u0E43\u0E19 ${issue2.origin}`;
          default:
            return `\u0E02\u0E49\u0E2D\u0E21\u0E39\u0E25\u0E44\u0E21\u0E48\u0E16\u0E39\u0E01\u0E15\u0E49\u0E2D\u0E07`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/tr.js
function tr_default() {
  return {
    localeError: error40()
  };
}
var parsedType7, error40;
var init_tr = __esm({
  "node_modules/zod/v4/locales/tr.js"() {
    init_util();
    parsedType7 = (data) => {
      const t2 = typeof data;
      switch (t2) {
        case "number": {
          return Number.isNaN(data) ? "NaN" : "number";
        }
        case "object": {
          if (Array.isArray(data)) {
            return "array";
          }
          if (data === null) {
            return "null";
          }
          if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
            return data.constructor.name;
          }
        }
      }
      return t2;
    };
    error40 = () => {
      const Sizable = {
        string: { unit: "karakter", verb: "olmal\u0131" },
        file: { unit: "bayt", verb: "olmal\u0131" },
        array: { unit: "\xF6\u011Fe", verb: "olmal\u0131" },
        set: { unit: "\xF6\u011Fe", verb: "olmal\u0131" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const Nouns = {
        regex: "girdi",
        email: "e-posta adresi",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO tarih ve saat",
        date: "ISO tarih",
        time: "ISO saat",
        duration: "ISO s\xFCre",
        ipv4: "IPv4 adresi",
        ipv6: "IPv6 adresi",
        cidrv4: "IPv4 aral\u0131\u011F\u0131",
        cidrv6: "IPv6 aral\u0131\u011F\u0131",
        base64: "base64 ile \u015Fifrelenmi\u015F metin",
        base64url: "base64url ile \u015Fifrelenmi\u015F metin",
        json_string: "JSON dizesi",
        e164: "E.164 say\u0131s\u0131",
        jwt: "JWT",
        template_literal: "\u015Eablon dizesi"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `Ge\xE7ersiz de\u011Fer: beklenen ${issue2.expected}, al\u0131nan ${parsedType7(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `Ge\xE7ersiz de\u011Fer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
            return `Ge\xE7ersiz se\xE7enek: a\u015Fa\u011F\u0131dakilerden biri olmal\u0131: ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\xF6\u011Fe"}`;
            return `\xC7ok b\xFCy\xFCk: beklenen ${issue2.origin ?? "de\u011Fer"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            return `\xC7ok k\xFC\xE7\xFCk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Ge\xE7ersiz metin: "${_issue.prefix}" ile ba\u015Flamal\u0131`;
            if (_issue.format === "ends_with")
              return `Ge\xE7ersiz metin: "${_issue.suffix}" ile bitmeli`;
            if (_issue.format === "includes")
              return `Ge\xE7ersiz metin: "${_issue.includes}" i\xE7ermeli`;
            if (_issue.format === "regex")
              return `Ge\xE7ersiz metin: ${_issue.pattern} desenine uymal\u0131`;
            return `Ge\xE7ersiz ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `Ge\xE7ersiz say\u0131: ${issue2.divisor} ile tam b\xF6l\xFCnebilmeli`;
          case "unrecognized_keys":
            return `Tan\u0131nmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz anahtar`;
          case "invalid_union":
            return "Ge\xE7ersiz de\u011Fer";
          case "invalid_element":
            return `${issue2.origin} i\xE7inde ge\xE7ersiz de\u011Fer`;
          default:
            return `Ge\xE7ersiz de\u011Fer`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/uk.js
function uk_default() {
  return {
    localeError: error41()
  };
}
var error41;
var init_uk = __esm({
  "node_modules/zod/v4/locales/uk.js"() {
    init_util();
    error41 = () => {
      const Sizable = {
        string: { unit: "\u0441\u0438\u043C\u0432\u043E\u043B\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        file: { unit: "\u0431\u0430\u0439\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        array: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" },
        set: { unit: "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432", verb: "\u043C\u0430\u0442\u0438\u043C\u0435" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0447\u0438\u0441\u043B\u043E";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u043C\u0430\u0441\u0438\u0432";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456",
        email: "\u0430\u0434\u0440\u0435\u0441\u0430 \u0435\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u043E\u0457 \u043F\u043E\u0448\u0442\u0438",
        url: "URL",
        emoji: "\u0435\u043C\u043E\u0434\u0437\u0456",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\u0434\u0430\u0442\u0430 \u0442\u0430 \u0447\u0430\u0441 ISO",
        date: "\u0434\u0430\u0442\u0430 ISO",
        time: "\u0447\u0430\u0441 ISO",
        duration: "\u0442\u0440\u0438\u0432\u0430\u043B\u0456\u0441\u0442\u044C ISO",
        ipv4: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv4",
        ipv6: "\u0430\u0434\u0440\u0435\u0441\u0430 IPv6",
        cidrv4: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv4",
        cidrv6: "\u0434\u0456\u0430\u043F\u0430\u0437\u043E\u043D IPv6",
        base64: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64",
        base64url: "\u0440\u044F\u0434\u043E\u043A \u0443 \u043A\u043E\u0434\u0443\u0432\u0430\u043D\u043D\u0456 base64url",
        json_string: "\u0440\u044F\u0434\u043E\u043A JSON",
        e164: "\u043D\u043E\u043C\u0435\u0440 E.164",
        jwt: "JWT",
        template_literal: "\u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${issue2.expected}, \u043E\u0442\u0440\u0438\u043C\u0430\u043D\u043E ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F ${stringifyPrimitive(issue2.values[0])}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0430 \u043E\u043F\u0446\u0456\u044F: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F \u043E\u0434\u043D\u0435 \u0437 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0435\u043B\u0435\u043C\u0435\u043D\u0442\u0456\u0432"}`;
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u0432\u0435\u043B\u0438\u043A\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin ?? "\u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F"} \u0431\u0443\u0434\u0435 ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u0417\u0430\u043D\u0430\u0434\u0442\u043E \u043C\u0430\u043B\u0435: \u043E\u0447\u0456\u043A\u0443\u0454\u0442\u044C\u0441\u044F, \u0449\u043E ${issue2.origin} \u0431\u0443\u0434\u0435 ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043F\u043E\u0447\u0438\u043D\u0430\u0442\u0438\u0441\u044F \u0437 "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0437\u0430\u043A\u0456\u043D\u0447\u0443\u0432\u0430\u0442\u0438\u0441\u044F \u043D\u0430 "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u043C\u0456\u0441\u0442\u0438\u0442\u0438 "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u0440\u044F\u0434\u043E\u043A: \u043F\u043E\u0432\u0438\u043D\u0435\u043D \u0432\u0456\u0434\u043F\u043E\u0432\u0456\u0434\u0430\u0442\u0438 \u0448\u0430\u0431\u043B\u043E\u043D\u0443 ${_issue.pattern}`;
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0447\u0438\u0441\u043B\u043E: \u043F\u043E\u0432\u0438\u043D\u043D\u043E \u0431\u0443\u0442\u0438 \u043A\u0440\u0430\u0442\u043D\u0438\u043C ${issue2.divisor}`;
          case "unrecognized_keys":
            return `\u041D\u0435\u0440\u043E\u0437\u043F\u0456\u0437\u043D\u0430\u043D\u0438\u0439 \u043A\u043B\u044E\u0447${issue2.keys.length > 1 ? "\u0456" : ""}: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0438\u0439 \u043A\u043B\u044E\u0447 \u0443 ${issue2.origin}`;
          case "invalid_union":
            return "\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456";
          case "invalid_element":
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F \u0443 ${issue2.origin}`;
          default:
            return `\u041D\u0435\u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u0456 \u0432\u0445\u0456\u0434\u043D\u0456 \u0434\u0430\u043D\u0456`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}
var init_ua = __esm({
  "node_modules/zod/v4/locales/ua.js"() {
    init_uk();
  }
});

// node_modules/zod/v4/locales/ur.js
function ur_default() {
  return {
    localeError: error42()
  };
}
var error42;
var init_ur = __esm({
  "node_modules/zod/v4/locales/ur.js"() {
    init_util();
    error42 = () => {
      const Sizable = {
        string: { unit: "\u062D\u0631\u0648\u0641", verb: "\u06C1\u0648\u0646\u0627" },
        file: { unit: "\u0628\u0627\u0626\u0679\u0633", verb: "\u06C1\u0648\u0646\u0627" },
        array: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" },
        set: { unit: "\u0622\u0626\u0679\u0645\u0632", verb: "\u06C1\u0648\u0646\u0627" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "\u0646\u0645\u0628\u0631";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u0622\u0631\u06D2";
            }
            if (data === null) {
              return "\u0646\u0644";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0627\u0646 \u067E\u0679",
        email: "\u0627\u06CC \u0645\u06CC\u0644 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        url: "\u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644",
        emoji: "\u0627\u06CC\u0645\u0648\u062C\u06CC",
        uuid: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        uuidv4: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 4",
        uuidv6: "\u06CC\u0648 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC \u0648\u06CC 6",
        nanoid: "\u0646\u06CC\u0646\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        guid: "\u062C\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        cuid2: "\u0633\u06CC \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC 2",
        ulid: "\u06CC\u0648 \u0627\u06CC\u0644 \u0622\u0626\u06CC \u0688\u06CC",
        xid: "\u0627\u06CC\u06A9\u0633 \u0622\u0626\u06CC \u0688\u06CC",
        ksuid: "\u06A9\u06D2 \u0627\u06CC\u0633 \u06CC\u0648 \u0622\u0626\u06CC \u0688\u06CC",
        datetime: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0688\u06CC\u0679 \u0679\u0627\u0626\u0645",
        date: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u062A\u0627\u0631\u06CC\u062E",
        time: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0648\u0642\u062A",
        duration: "\u0622\u0626\u06CC \u0627\u06CC\u0633 \u0627\u0648 \u0645\u062F\u062A",
        ipv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        ipv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0627\u06CC\u0688\u0631\u06CC\u0633",
        cidrv4: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 4 \u0631\u06CC\u0646\u062C",
        cidrv6: "\u0622\u0626\u06CC \u067E\u06CC \u0648\u06CC 6 \u0631\u06CC\u0646\u062C",
        base64: "\u0628\u06CC\u0633 64 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        base64url: "\u0628\u06CC\u0633 64 \u06CC\u0648 \u0622\u0631 \u0627\u06CC\u0644 \u0627\u0646 \u06A9\u0648\u0688\u0688 \u0633\u0679\u0631\u0646\u06AF",
        json_string: "\u062C\u06D2 \u0627\u06CC\u0633 \u0627\u0648 \u0627\u06CC\u0646 \u0633\u0679\u0631\u0646\u06AF",
        e164: "\u0627\u06CC 164 \u0646\u0645\u0628\u0631",
        jwt: "\u062C\u06D2 \u0688\u0628\u0644\u06CC\u0648 \u0679\u06CC",
        template_literal: "\u0627\u0646 \u067E\u0679"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${issue2.expected} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627\u060C ${parsedType8(issue2.input)} \u0645\u0648\u0635\u0648\u0644 \u06C1\u0648\u0627`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679: ${stringifyPrimitive(issue2.values[0])} \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
            return `\u063A\u0644\u0637 \u0622\u067E\u0634\u0646: ${joinValues(issue2.values, "|")} \u0645\u06CC\u06BA \u0633\u06D2 \u0627\u06CC\u06A9 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u06D2 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u0639\u0646\u0627\u0635\u0631"} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            return `\u0628\u06C1\u062A \u0628\u0691\u0627: ${issue2.origin ?? "\u0648\u06CC\u0644\u06CC\u0648"} \u06A9\u0627 ${adj}${issue2.maximum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u06D2 ${adj}${issue2.minimum.toString()} ${sizing.unit} \u06C1\u0648\u0646\u06D2 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u06D2`;
            }
            return `\u0628\u06C1\u062A \u0686\u06BE\u0648\u0679\u0627: ${issue2.origin} \u06A9\u0627 ${adj}${issue2.minimum.toString()} \u06C1\u0648\u0646\u0627 \u0645\u062A\u0648\u0642\u0639 \u062A\u06BE\u0627`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.prefix}" \u0633\u06D2 \u0634\u0631\u0648\u0639 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            }
            if (_issue.format === "ends_with")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.suffix}" \u067E\u0631 \u062E\u062A\u0645 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "includes")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: "${_issue.includes}" \u0634\u0627\u0645\u0644 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            if (_issue.format === "regex")
              return `\u063A\u0644\u0637 \u0633\u0679\u0631\u0646\u06AF: \u067E\u06CC\u0679\u0631\u0646 ${_issue.pattern} \u0633\u06D2 \u0645\u06CC\u0686 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
            return `\u063A\u0644\u0637 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u063A\u0644\u0637 \u0646\u0645\u0628\u0631: ${issue2.divisor} \u06A9\u0627 \u0645\u0636\u0627\u0639\u0641 \u06C1\u0648\u0646\u0627 \u0686\u0627\u06C1\u06CC\u06D2`;
          case "unrecognized_keys":
            return `\u063A\u06CC\u0631 \u062A\u0633\u0644\u06CC\u0645 \u0634\u062F\u06C1 \u06A9\u06CC${issue2.keys.length > 1 ? "\u0632" : ""}: ${joinValues(issue2.keys, "\u060C ")}`;
          case "invalid_key":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u06A9\u06CC`;
          case "invalid_union":
            return "\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679";
          case "invalid_element":
            return `${issue2.origin} \u0645\u06CC\u06BA \u063A\u0644\u0637 \u0648\u06CC\u0644\u06CC\u0648`;
          default:
            return `\u063A\u0644\u0637 \u0627\u0646 \u067E\u0679`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/vi.js
function vi_default() {
  return {
    localeError: error43()
  };
}
var error43;
var init_vi = __esm({
  "node_modules/zod/v4/locales/vi.js"() {
    init_util();
    error43 = () => {
      const Sizable = {
        string: { unit: "k\xFD t\u1EF1", verb: "c\xF3" },
        file: { unit: "byte", verb: "c\xF3" },
        array: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" },
        set: { unit: "ph\u1EA7n t\u1EED", verb: "c\xF3" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "s\u1ED1";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "m\u1EA3ng";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u0111\u1EA7u v\xE0o",
        email: "\u0111\u1ECBa ch\u1EC9 email",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ng\xE0y gi\u1EDD ISO",
        date: "ng\xE0y ISO",
        time: "gi\u1EDD ISO",
        duration: "kho\u1EA3ng th\u1EDDi gian ISO",
        ipv4: "\u0111\u1ECBa ch\u1EC9 IPv4",
        ipv6: "\u0111\u1ECBa ch\u1EC9 IPv6",
        cidrv4: "d\u1EA3i IPv4",
        cidrv6: "d\u1EA3i IPv6",
        base64: "chu\u1ED7i m\xE3 h\xF3a base64",
        base64url: "chu\u1ED7i m\xE3 h\xF3a base64url",
        json_string: "chu\u1ED7i JSON",
        e164: "s\u1ED1 E.164",
        jwt: "JWT",
        template_literal: "\u0111\u1EA7u v\xE0o"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${issue2.expected}, nh\u1EADn \u0111\u01B0\u1EE3c ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i ${stringifyPrimitive(issue2.values[0])}`;
            return `T\xF9y ch\u1ECDn kh\xF4ng h\u1EE3p l\u1EC7: mong \u0111\u1EE3i m\u1ED9t trong c\xE1c gi\xE1 tr\u1ECB ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "ph\u1EA7n t\u1EED"}`;
            return `Qu\xE1 l\u1EDBn: mong \u0111\u1EE3i ${issue2.origin ?? "gi\xE1 tr\u1ECB"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `Qu\xE1 nh\u1ECF: mong \u0111\u1EE3i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i b\u1EAFt \u0111\u1EA7u b\u1EB1ng "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i k\u1EBFt th\xFAc b\u1EB1ng "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i bao g\u1ED3m "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `Chu\u1ED7i kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i kh\u1EDBp v\u1EDBi m\u1EABu ${_issue.pattern}`;
            return `${Nouns[_issue.format] ?? issue2.format} kh\xF4ng h\u1EE3p l\u1EC7`;
          }
          case "not_multiple_of":
            return `S\u1ED1 kh\xF4ng h\u1EE3p l\u1EC7: ph\u1EA3i l\xE0 b\u1ED9i s\u1ED1 c\u1EE7a ${issue2.divisor}`;
          case "unrecognized_keys":
            return `Kh\xF3a kh\xF4ng \u0111\u01B0\u1EE3c nh\u1EADn d\u1EA1ng: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `Kh\xF3a kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          case "invalid_union":
            return "\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7";
          case "invalid_element":
            return `Gi\xE1 tr\u1ECB kh\xF4ng h\u1EE3p l\u1EC7 trong ${issue2.origin}`;
          default:
            return `\u0110\u1EA7u v\xE0o kh\xF4ng h\u1EE3p l\u1EC7`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-CN.js
function zh_CN_default() {
  return {
    localeError: error44()
  };
}
var error44;
var init_zh_CN = __esm({
  "node_modules/zod/v4/locales/zh-CN.js"() {
    init_util();
    error44 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u7B26", verb: "\u5305\u542B" },
        file: { unit: "\u5B57\u8282", verb: "\u5305\u542B" },
        array: { unit: "\u9879", verb: "\u5305\u542B" },
        set: { unit: "\u9879", verb: "\u5305\u542B" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "\u975E\u6570\u5B57(NaN)" : "\u6570\u5B57";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "\u6570\u7EC4";
            }
            if (data === null) {
              return "\u7A7A\u503C(null)";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u8F93\u5165",
        email: "\u7535\u5B50\u90AE\u4EF6",
        url: "URL",
        emoji: "\u8868\u60C5\u7B26\u53F7",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO\u65E5\u671F\u65F6\u95F4",
        date: "ISO\u65E5\u671F",
        time: "ISO\u65F6\u95F4",
        duration: "ISO\u65F6\u957F",
        ipv4: "IPv4\u5730\u5740",
        ipv6: "IPv6\u5730\u5740",
        cidrv4: "IPv4\u7F51\u6BB5",
        cidrv6: "IPv6\u7F51\u6BB5",
        base64: "base64\u7F16\u7801\u5B57\u7B26\u4E32",
        base64url: "base64url\u7F16\u7801\u5B57\u7B26\u4E32",
        json_string: "JSON\u5B57\u7B26\u4E32",
        e164: "E.164\u53F7\u7801",
        jwt: "JWT",
        template_literal: "\u8F93\u5165"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${issue2.expected}\uFF0C\u5B9E\u9645\u63A5\u6536 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u65E0\u6548\u8F93\u5165\uFF1A\u671F\u671B ${stringifyPrimitive(issue2.values[0])}`;
            return `\u65E0\u6548\u9009\u9879\uFF1A\u671F\u671B\u4EE5\u4E0B\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u4E2A\u5143\u7D20"}`;
            return `\u6570\u503C\u8FC7\u5927\uFF1A\u671F\u671B ${issue2.origin ?? "\u503C"} ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6570\u503C\u8FC7\u5C0F\uFF1A\u671F\u671B ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.prefix}" \u5F00\u5934`;
            if (_issue.format === "ends_with")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u4EE5 "${_issue.suffix}" \u7ED3\u5C3E`;
            if (_issue.format === "includes")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u65E0\u6548\u5B57\u7B26\u4E32\uFF1A\u5FC5\u987B\u6EE1\u8DB3\u6B63\u5219\u8868\u8FBE\u5F0F ${_issue.pattern}`;
            return `\u65E0\u6548${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u65E0\u6548\u6570\u5B57\uFF1A\u5FC5\u987B\u662F ${issue2.divisor} \u7684\u500D\u6570`;
          case "unrecognized_keys":
            return `\u51FA\u73B0\u672A\u77E5\u7684\u952E(key): ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u7684\u952E(key)\u65E0\u6548`;
          case "invalid_union":
            return "\u65E0\u6548\u8F93\u5165";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u5305\u542B\u65E0\u6548\u503C(value)`;
          default:
            return `\u65E0\u6548\u8F93\u5165`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/zh-TW.js
function zh_TW_default() {
  return {
    localeError: error45()
  };
}
var error45;
var init_zh_TW = __esm({
  "node_modules/zod/v4/locales/zh-TW.js"() {
    init_util();
    error45 = () => {
      const Sizable = {
        string: { unit: "\u5B57\u5143", verb: "\u64C1\u6709" },
        file: { unit: "\u4F4D\u5143\u7D44", verb: "\u64C1\u6709" },
        array: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" },
        set: { unit: "\u9805\u76EE", verb: "\u64C1\u6709" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "number";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "array";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u8F38\u5165",
        email: "\u90F5\u4EF6\u5730\u5740",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "ISO \u65E5\u671F\u6642\u9593",
        date: "ISO \u65E5\u671F",
        time: "ISO \u6642\u9593",
        duration: "ISO \u671F\u9593",
        ipv4: "IPv4 \u4F4D\u5740",
        ipv6: "IPv6 \u4F4D\u5740",
        cidrv4: "IPv4 \u7BC4\u570D",
        cidrv6: "IPv6 \u7BC4\u570D",
        base64: "base64 \u7DE8\u78BC\u5B57\u4E32",
        base64url: "base64url \u7DE8\u78BC\u5B57\u4E32",
        json_string: "JSON \u5B57\u4E32",
        e164: "E.164 \u6578\u503C",
        jwt: "JWT",
        template_literal: "\u8F38\u5165"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${issue2.expected}\uFF0C\u4F46\u6536\u5230 ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\u7121\u6548\u7684\u8F38\u5165\u503C\uFF1A\u9810\u671F\u70BA ${stringifyPrimitive(issue2.values[0])}`;
            return `\u7121\u6548\u7684\u9078\u9805\uFF1A\u9810\u671F\u70BA\u4EE5\u4E0B\u5176\u4E2D\u4E4B\u4E00 ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "\u500B\u5143\u7D20"}`;
            return `\u6578\u503C\u904E\u5927\uFF1A\u9810\u671F ${issue2.origin ?? "\u503C"} \u61C9\u70BA ${adj}${issue2.maximum.toString()}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing) {
              return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
            }
            return `\u6578\u503C\u904E\u5C0F\uFF1A\u9810\u671F ${issue2.origin} \u61C9\u70BA ${adj}${issue2.minimum.toString()}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with") {
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.prefix}" \u958B\u982D`;
            }
            if (_issue.format === "ends_with")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u4EE5 "${_issue.suffix}" \u7D50\u5C3E`;
            if (_issue.format === "includes")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u5305\u542B "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u7121\u6548\u7684\u5B57\u4E32\uFF1A\u5FC5\u9808\u7B26\u5408\u683C\u5F0F ${_issue.pattern}`;
            return `\u7121\u6548\u7684 ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `\u7121\u6548\u7684\u6578\u5B57\uFF1A\u5FC5\u9808\u70BA ${issue2.divisor} \u7684\u500D\u6578`;
          case "unrecognized_keys":
            return `\u7121\u6CD5\u8B58\u5225\u7684\u9375\u503C${issue2.keys.length > 1 ? "\u5011" : ""}\uFF1A${joinValues(issue2.keys, "\u3001")}`;
          case "invalid_key":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u9375\u503C`;
          case "invalid_union":
            return "\u7121\u6548\u7684\u8F38\u5165\u503C";
          case "invalid_element":
            return `${issue2.origin} \u4E2D\u6709\u7121\u6548\u7684\u503C`;
          default:
            return `\u7121\u6548\u7684\u8F38\u5165\u503C`;
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/yo.js
function yo_default() {
  return {
    localeError: error46()
  };
}
var error46;
var init_yo = __esm({
  "node_modules/zod/v4/locales/yo.js"() {
    init_util();
    error46 = () => {
      const Sizable = {
        string: { unit: "\xE0mi", verb: "n\xED" },
        file: { unit: "bytes", verb: "n\xED" },
        array: { unit: "nkan", verb: "n\xED" },
        set: { unit: "nkan", verb: "n\xED" }
      };
      function getSizing(origin) {
        return Sizable[origin] ?? null;
      }
      const parsedType8 = (data) => {
        const t2 = typeof data;
        switch (t2) {
          case "number": {
            return Number.isNaN(data) ? "NaN" : "n\u1ECD\u0301mb\xE0";
          }
          case "object": {
            if (Array.isArray(data)) {
              return "akop\u1ECD";
            }
            if (data === null) {
              return "null";
            }
            if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
              return data.constructor.name;
            }
          }
        }
        return t2;
      };
      const Nouns = {
        regex: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9",
        email: "\xE0d\xEDr\u1EB9\u0301s\xEC \xECm\u1EB9\u0301l\xEC",
        url: "URL",
        emoji: "emoji",
        uuid: "UUID",
        uuidv4: "UUIDv4",
        uuidv6: "UUIDv6",
        nanoid: "nanoid",
        guid: "GUID",
        cuid: "cuid",
        cuid2: "cuid2",
        ulid: "ULID",
        xid: "XID",
        ksuid: "KSUID",
        datetime: "\xE0k\xF3k\xF2 ISO",
        date: "\u1ECDj\u1ECD\u0301 ISO",
        time: "\xE0k\xF3k\xF2 ISO",
        duration: "\xE0k\xF3k\xF2 t\xF3 p\xE9 ISO",
        ipv4: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv4",
        ipv6: "\xE0d\xEDr\u1EB9\u0301s\xEC IPv6",
        cidrv4: "\xE0gb\xE8gb\xE8 IPv4",
        cidrv6: "\xE0gb\xE8gb\xE8 IPv6",
        base64: "\u1ECD\u0300r\u1ECD\u0300 t\xED a k\u1ECD\u0301 n\xED base64",
        base64url: "\u1ECD\u0300r\u1ECD\u0300 base64url",
        json_string: "\u1ECD\u0300r\u1ECD\u0300 JSON",
        e164: "n\u1ECD\u0301mb\xE0 E.164",
        jwt: "JWT",
        template_literal: "\u1EB9\u0300r\u1ECD \xECb\xE1w\u1ECDl\xE9"
      };
      return (issue2) => {
        switch (issue2.code) {
          case "invalid_type":
            return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${issue2.expected}, \xE0m\u1ECD\u0300 a r\xED ${parsedType8(issue2.input)}`;
          case "invalid_value":
            if (issue2.values.length === 1)
              return `\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e: a n\xED l\xE1ti fi ${stringifyPrimitive(issue2.values[0])}`;
            return `\xC0\u1E63\xE0y\xE0n a\u1E63\xEC\u1E63e: yan \u1ECD\u0300kan l\xE1ra ${joinValues(issue2.values, "|")}`;
          case "too_big": {
            const adj = issue2.inclusive ? "<=" : "<";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
            return `T\xF3 p\u1ECD\u0300 j\xF9: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.maximum}`;
          }
          case "too_small": {
            const adj = issue2.inclusive ? ">=" : ">";
            const sizing = getSizing(issue2.origin);
            if (sizing)
              return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 p\xE9 ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
            return `K\xE9r\xE9 ju: a n\xED l\xE1ti j\u1EB9\u0301 ${adj}${issue2.minimum}`;
          }
          case "invalid_format": {
            const _issue = issue2;
            if (_issue.format === "starts_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\u1EB9\u0300r\u1EB9\u0300 p\u1EB9\u0300l\xFA "${_issue.prefix}"`;
            if (_issue.format === "ends_with")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 par\xED p\u1EB9\u0300l\xFA "${_issue.suffix}"`;
            if (_issue.format === "includes")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 n\xED "${_issue.includes}"`;
            if (_issue.format === "regex")
              return `\u1ECC\u0300r\u1ECD\u0300 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 b\xE1 \xE0p\u1EB9\u1EB9r\u1EB9 mu ${_issue.pattern}`;
            return `A\u1E63\xEC\u1E63e: ${Nouns[_issue.format] ?? issue2.format}`;
          }
          case "not_multiple_of":
            return `N\u1ECD\u0301mb\xE0 a\u1E63\xEC\u1E63e: gb\u1ECD\u0301d\u1ECD\u0300 j\u1EB9\u0301 \xE8y\xE0 p\xEDp\xEDn ti ${issue2.divisor}`;
          case "unrecognized_keys":
            return `B\u1ECDt\xECn\xEC \xE0\xECm\u1ECD\u0300: ${joinValues(issue2.keys, ", ")}`;
          case "invalid_key":
            return `B\u1ECDt\xECn\xEC a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          case "invalid_union":
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
          case "invalid_element":
            return `Iye a\u1E63\xEC\u1E63e n\xEDn\xFA ${issue2.origin}`;
          default:
            return "\xCCb\xE1w\u1ECDl\xE9 a\u1E63\xEC\u1E63e";
        }
      };
    };
  }
});

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});
var init_locales = __esm({
  "node_modules/zod/v4/locales/index.js"() {
    init_ar();
    init_az();
    init_be();
    init_bg();
    init_ca();
    init_cs();
    init_da();
    init_de();
    init_en();
    init_eo();
    init_es();
    init_fa();
    init_fi();
    init_fr();
    init_fr_CA();
    init_he();
    init_hu();
    init_id();
    init_is();
    init_it();
    init_ja();
    init_ka();
    init_kh();
    init_km();
    init_ko();
    init_lt();
    init_mk();
    init_ms();
    init_nl();
    init_no();
    init_ota();
    init_ps();
    init_pl();
    init_pt();
    init_ru();
    init_sl();
    init_sv();
    init_ta();
    init_th();
    init_tr();
    init_ua();
    init_uk();
    init_ur();
    init_vi();
    init_zh_CN();
    init_zh_TW();
    init_yo();
  }
});

// node_modules/zod/v4/core/registries.js
function registry() {
  return new $ZodRegistry();
}
var _a, $output, $input, $ZodRegistry, globalRegistry;
var init_registries = __esm({
  "node_modules/zod/v4/core/registries.js"() {
    $output = Symbol("ZodOutput");
    $input = Symbol("ZodInput");
    $ZodRegistry = class {
      constructor() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
      }
      add(schema, ..._meta) {
        const meta3 = _meta[0];
        this._map.set(schema, meta3);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          if (this._idmap.has(meta3.id)) {
            throw new Error(`ID ${meta3.id} already exists in the registry`);
          }
          this._idmap.set(meta3.id, schema);
        }
        return this;
      }
      clear() {
        this._map = /* @__PURE__ */ new WeakMap();
        this._idmap = /* @__PURE__ */ new Map();
        return this;
      }
      remove(schema) {
        const meta3 = this._map.get(schema);
        if (meta3 && typeof meta3 === "object" && "id" in meta3) {
          this._idmap.delete(meta3.id);
        }
        this._map.delete(schema);
        return this;
      }
      get(schema) {
        const p = schema._zod.parent;
        if (p) {
          const pm = { ...this.get(p) ?? {} };
          delete pm.id;
          const f = { ...pm, ...this._map.get(schema) };
          return Object.keys(f).length ? f : void 0;
        }
        return this._map.get(schema);
      }
      has(schema) {
        return this._map.has(schema);
      }
    };
    (_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
    globalRegistry = globalThis.__zod_globalRegistry;
  }
});

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern2, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern: pattern2
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec2;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}
var TimePrecision;
var init_api = __esm({
  "node_modules/zod/v4/core/api.js"() {
    init_checks();
    init_registries();
    init_schemas();
    init_util();
    TimePrecision = {
      Any: null,
      Minute: -1,
      Second: 0,
      Millisecond: 3,
      Microsecond: 6
    };
  }
});

// node_modules/zod/v4/core/to-json-schema.js
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key2, schema] = entry;
      schemas[key2] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key2 in def.shape) {
      if (isTransforming(def.shape[key2], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var JSONSchemaGenerator;
var init_to_json_schema = __esm({
  "node_modules/zod/v4/core/to-json-schema.js"() {
    init_registries();
    init_util();
    JSONSchemaGenerator = class {
      constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => {
        });
        this.io = params?.io ?? "output";
        this.seen = /* @__PURE__ */ new Map();
      }
      process(schema, _params = { path: [], schemaPath: [] }) {
        var _a2;
        const def = schema._zod.def;
        const formatMap = {
          guid: "uuid",
          url: "uri",
          datetime: "date-time",
          json_string: "json-string",
          regex: ""
          // do not set
        };
        const seen = this.seen.get(schema);
        if (seen) {
          seen.count++;
          const isCycle = _params.schemaPath.includes(schema);
          if (isCycle) {
            seen.cycle = _params.path;
          }
          return seen.schema;
        }
        const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
        this.seen.set(schema, result);
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
          result.schema = overrideSchema;
        } else {
          const params = {
            ..._params,
            schemaPath: [..._params.schemaPath, schema],
            path: _params.path
          };
          const parent = schema._zod.parent;
          if (parent) {
            result.ref = parent;
            this.process(parent, params);
            this.seen.get(parent).isParent = true;
          } else {
            const _json = result.schema;
            switch (def.type) {
              case "string": {
                const json3 = _json;
                json3.type = "string";
                const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minLength = minimum;
                if (typeof maximum === "number")
                  json3.maxLength = maximum;
                if (format) {
                  json3.format = formatMap[format] ?? format;
                  if (json3.format === "")
                    delete json3.format;
                }
                if (contentEncoding)
                  json3.contentEncoding = contentEncoding;
                if (patterns && patterns.size > 0) {
                  const regexes = [...patterns];
                  if (regexes.length === 1)
                    json3.pattern = regexes[0].source;
                  else if (regexes.length > 1) {
                    result.schema.allOf = [
                      ...regexes.map((regex) => ({
                        ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                        pattern: regex.source
                      }))
                    ];
                  }
                }
                break;
              }
              case "number": {
                const json3 = _json;
                const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                if (typeof format === "string" && format.includes("int"))
                  json3.type = "integer";
                else
                  json3.type = "number";
                if (typeof exclusiveMinimum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.minimum = exclusiveMinimum;
                    json3.exclusiveMinimum = true;
                  } else {
                    json3.exclusiveMinimum = exclusiveMinimum;
                  }
                }
                if (typeof minimum === "number") {
                  json3.minimum = minimum;
                  if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                    if (exclusiveMinimum >= minimum)
                      delete json3.minimum;
                    else
                      delete json3.exclusiveMinimum;
                  }
                }
                if (typeof exclusiveMaximum === "number") {
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.maximum = exclusiveMaximum;
                    json3.exclusiveMaximum = true;
                  } else {
                    json3.exclusiveMaximum = exclusiveMaximum;
                  }
                }
                if (typeof maximum === "number") {
                  json3.maximum = maximum;
                  if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                    if (exclusiveMaximum <= maximum)
                      delete json3.maximum;
                    else
                      delete json3.exclusiveMaximum;
                  }
                }
                if (typeof multipleOf === "number")
                  json3.multipleOf = multipleOf;
                break;
              }
              case "boolean": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "bigint": {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt cannot be represented in JSON Schema");
                }
                break;
              }
              case "symbol": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Symbols cannot be represented in JSON Schema");
                }
                break;
              }
              case "null": {
                if (this.target === "openapi-3.0") {
                  _json.type = "string";
                  _json.nullable = true;
                  _json.enum = [null];
                } else
                  _json.type = "null";
                break;
              }
              case "any": {
                break;
              }
              case "unknown": {
                break;
              }
              case "undefined": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Undefined cannot be represented in JSON Schema");
                }
                break;
              }
              case "void": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Void cannot be represented in JSON Schema");
                }
                break;
              }
              case "never": {
                _json.not = {};
                break;
              }
              case "date": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Date cannot be represented in JSON Schema");
                }
                break;
              }
              case "array": {
                const json3 = _json;
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                json3.type = "array";
                json3.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                break;
              }
              case "object": {
                const json3 = _json;
                json3.type = "object";
                json3.properties = {};
                const shape = def.shape;
                for (const key2 in shape) {
                  json3.properties[key2] = this.process(shape[key2], {
                    ...params,
                    path: [...params.path, "properties", key2]
                  });
                }
                const allKeys = new Set(Object.keys(shape));
                const requiredKeys = new Set([...allKeys].filter((key2) => {
                  const v = def.shape[key2]._zod;
                  if (this.io === "input") {
                    return v.optin === void 0;
                  } else {
                    return v.optout === void 0;
                  }
                }));
                if (requiredKeys.size > 0) {
                  json3.required = Array.from(requiredKeys);
                }
                if (def.catchall?._zod.def.type === "never") {
                  json3.additionalProperties = false;
                } else if (!def.catchall) {
                  if (this.io === "output")
                    json3.additionalProperties = false;
                } else if (def.catchall) {
                  json3.additionalProperties = this.process(def.catchall, {
                    ...params,
                    path: [...params.path, "additionalProperties"]
                  });
                }
                break;
              }
              case "union": {
                const json3 = _json;
                const isDiscriminated = def.discriminator !== void 0;
                const options2 = def.options.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, isDiscriminated ? "oneOf" : "anyOf", i]
                }));
                if (isDiscriminated) {
                  json3.oneOf = options2;
                } else {
                  json3.anyOf = options2;
                }
                break;
              }
              case "intersection": {
                const json3 = _json;
                const a = this.process(def.left, {
                  ...params,
                  path: [...params.path, "allOf", 0]
                });
                const b = this.process(def.right, {
                  ...params,
                  path: [...params.path, "allOf", 1]
                });
                const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                const allOf = [
                  ...isSimpleIntersection(a) ? a.allOf : [a],
                  ...isSimpleIntersection(b) ? b.allOf : [b]
                ];
                json3.allOf = allOf;
                break;
              }
              case "tuple": {
                const json3 = _json;
                json3.type = "array";
                const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                const prefixItems = def.items.map((x, i) => this.process(x, {
                  ...params,
                  path: [...params.path, prefixPath, i]
                }));
                const rest = def.rest ? this.process(def.rest, {
                  ...params,
                  path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
                }) : null;
                if (this.target === "draft-2020-12") {
                  json3.prefixItems = prefixItems;
                  if (rest) {
                    json3.items = rest;
                  }
                } else if (this.target === "openapi-3.0") {
                  json3.items = {
                    anyOf: prefixItems
                  };
                  if (rest) {
                    json3.items.anyOf.push(rest);
                  }
                  json3.minItems = prefixItems.length;
                  if (!rest) {
                    json3.maxItems = prefixItems.length;
                  }
                } else {
                  json3.items = prefixItems;
                  if (rest) {
                    json3.additionalItems = rest;
                  }
                }
                const { minimum, maximum } = schema._zod.bag;
                if (typeof minimum === "number")
                  json3.minItems = minimum;
                if (typeof maximum === "number")
                  json3.maxItems = maximum;
                break;
              }
              case "record": {
                const json3 = _json;
                json3.type = "object";
                if (this.target === "draft-7" || this.target === "draft-2020-12") {
                  json3.propertyNames = this.process(def.keyType, {
                    ...params,
                    path: [...params.path, "propertyNames"]
                  });
                }
                json3.additionalProperties = this.process(def.valueType, {
                  ...params,
                  path: [...params.path, "additionalProperties"]
                });
                break;
              }
              case "map": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Map cannot be represented in JSON Schema");
                }
                break;
              }
              case "set": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Set cannot be represented in JSON Schema");
                }
                break;
              }
              case "enum": {
                const json3 = _json;
                const values = getEnumValues(def.entries);
                if (values.every((v) => typeof v === "number"))
                  json3.type = "number";
                if (values.every((v) => typeof v === "string"))
                  json3.type = "string";
                json3.enum = values;
                break;
              }
              case "literal": {
                const json3 = _json;
                const vals = [];
                for (const val of def.values) {
                  if (val === void 0) {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                    } else {
                    }
                  } else if (typeof val === "bigint") {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt literals cannot be represented in JSON Schema");
                    } else {
                      vals.push(Number(val));
                    }
                  } else {
                    vals.push(val);
                  }
                }
                if (vals.length === 0) {
                } else if (vals.length === 1) {
                  const val = vals[0];
                  json3.type = val === null ? "null" : typeof val;
                  if (this.target === "draft-4" || this.target === "openapi-3.0") {
                    json3.enum = [val];
                  } else {
                    json3.const = val;
                  }
                } else {
                  if (vals.every((v) => typeof v === "number"))
                    json3.type = "number";
                  if (vals.every((v) => typeof v === "string"))
                    json3.type = "string";
                  if (vals.every((v) => typeof v === "boolean"))
                    json3.type = "string";
                  if (vals.every((v) => v === null))
                    json3.type = "null";
                  json3.enum = vals;
                }
                break;
              }
              case "file": {
                const json3 = _json;
                const file2 = {
                  type: "string",
                  format: "binary",
                  contentEncoding: "binary"
                };
                const { minimum, maximum, mime } = schema._zod.bag;
                if (minimum !== void 0)
                  file2.minLength = minimum;
                if (maximum !== void 0)
                  file2.maxLength = maximum;
                if (mime) {
                  if (mime.length === 1) {
                    file2.contentMediaType = mime[0];
                    Object.assign(json3, file2);
                  } else {
                    json3.anyOf = mime.map((m) => {
                      const mFile = { ...file2, contentMediaType: m };
                      return mFile;
                    });
                  }
                } else {
                  Object.assign(json3, file2);
                }
                break;
              }
              case "transform": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Transforms cannot be represented in JSON Schema");
                }
                break;
              }
              case "nullable": {
                const inner = this.process(def.innerType, params);
                if (this.target === "openapi-3.0") {
                  result.ref = def.innerType;
                  _json.nullable = true;
                } else {
                  _json.anyOf = [inner, { type: "null" }];
                }
                break;
              }
              case "nonoptional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "success": {
                const json3 = _json;
                json3.type = "boolean";
                break;
              }
              case "default": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "prefault": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                if (this.io === "input")
                  _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                break;
              }
              case "catch": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                let catchValue;
                try {
                  catchValue = def.catchValue(void 0);
                } catch {
                  throw new Error("Dynamic catch values are not supported in JSON Schema");
                }
                _json.default = catchValue;
                break;
              }
              case "nan": {
                if (this.unrepresentable === "throw") {
                  throw new Error("NaN cannot be represented in JSON Schema");
                }
                break;
              }
              case "template_literal": {
                const json3 = _json;
                const pattern2 = schema._zod.pattern;
                if (!pattern2)
                  throw new Error("Pattern not found in template literal");
                json3.type = "string";
                json3.pattern = pattern2.source;
                break;
              }
              case "pipe": {
                const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "readonly": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                _json.readOnly = true;
                break;
              }
              case "promise": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "optional": {
                this.process(def.innerType, params);
                result.ref = def.innerType;
                break;
              }
              case "lazy": {
                const innerType = schema._zod.innerType;
                this.process(innerType, params);
                result.ref = innerType;
                break;
              }
              case "custom": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Custom types cannot be represented in JSON Schema");
                }
                break;
              }
              case "function": {
                if (this.unrepresentable === "throw") {
                  throw new Error("Function types cannot be represented in JSON Schema");
                }
                break;
              }
              default: {
                def;
              }
            }
          }
        }
        const meta3 = this.metadataRegistry.get(schema);
        if (meta3)
          Object.assign(result.schema, meta3);
        if (this.io === "input" && isTransforming(schema)) {
          delete result.schema.examples;
          delete result.schema.default;
        }
        if (this.io === "input" && result.schema._prefault)
          (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
        delete result.schema._prefault;
        const _result = this.seen.get(schema);
        return _result.schema;
      }
      emit(schema, _params) {
        const params = {
          cycles: _params?.cycles ?? "ref",
          reused: _params?.reused ?? "inline",
          // unrepresentable: _params?.unrepresentable ?? "throw",
          // uri: _params?.uri ?? ((id) => `${id}`),
          external: _params?.external ?? void 0
        };
        const root = this.seen.get(schema);
        if (!root)
          throw new Error("Unprocessed schema. This is a bug in Zod.");
        const makeURI = (entry) => {
          const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
          if (params.external) {
            const externalId = params.external.registry.get(entry[0])?.id;
            const uriGenerator = params.external.uri ?? ((id2) => id2);
            if (externalId) {
              return { ref: uriGenerator(externalId) };
            }
            const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
            entry[1].defId = id;
            return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
          }
          if (entry[1] === root) {
            return { ref: "#" };
          }
          const uriPrefix = `#`;
          const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
          const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
          return { defId, ref: defUriPrefix + defId };
        };
        const extractToDef = (entry) => {
          if (entry[1].schema.$ref) {
            return;
          }
          const seen = entry[1];
          const { ref, defId } = makeURI(entry);
          seen.def = { ...seen.schema };
          if (defId)
            seen.defId = defId;
          const schema2 = seen.schema;
          for (const key2 in schema2) {
            delete schema2[key2];
          }
          schema2.$ref = ref;
        };
        if (params.cycles === "throw") {
          for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.cycle) {
              throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
            }
          }
        }
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (schema === entry[0]) {
            extractToDef(entry);
            continue;
          }
          if (params.external) {
            const ext = params.external.registry.get(entry[0])?.id;
            if (schema !== entry[0] && ext) {
              extractToDef(entry);
              continue;
            }
          }
          const id = this.metadataRegistry.get(entry[0])?.id;
          if (id) {
            extractToDef(entry);
            continue;
          }
          if (seen.cycle) {
            extractToDef(entry);
            continue;
          }
          if (seen.count > 1) {
            if (params.reused === "ref") {
              extractToDef(entry);
              continue;
            }
          }
        }
        const flattenRef = (zodSchema, params2) => {
          const seen = this.seen.get(zodSchema);
          const schema2 = seen.def ?? seen.schema;
          const _cached = { ...schema2 };
          if (seen.ref === null) {
            return;
          }
          const ref = seen.ref;
          seen.ref = null;
          if (ref) {
            flattenRef(ref, params2);
            const refSchema = this.seen.get(ref).schema;
            if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
              schema2.allOf = schema2.allOf ?? [];
              schema2.allOf.push(refSchema);
            } else {
              Object.assign(schema2, refSchema);
              Object.assign(schema2, _cached);
            }
          }
          if (!seen.isParent)
            this.override({
              zodSchema,
              jsonSchema: schema2,
              path: seen.path ?? []
            });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
          flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
          result.$schema = "https://json-schema.org/draft/2020-12/schema";
        } else if (this.target === "draft-7") {
          result.$schema = "http://json-schema.org/draft-07/schema#";
        } else if (this.target === "draft-4") {
          result.$schema = "http://json-schema.org/draft-04/schema#";
        } else if (this.target === "openapi-3.0") {
        } else {
          console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
          const id = params.external.registry.get(schema)?.id;
          if (!id)
            throw new Error("Schema is missing an `id` property");
          result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
          const seen = entry[1];
          if (seen.def && seen.defId) {
            defs[seen.defId] = seen.def;
          }
        }
        if (params.external) {
        } else {
          if (Object.keys(defs).length > 0) {
            if (this.target === "draft-2020-12") {
              result.$defs = defs;
            } else {
              result.definitions = defs;
            }
          }
        }
        try {
          return JSON.parse(JSON.stringify(result));
        } catch (_err) {
          throw new Error("Error converting schema to JSON.");
        }
      }
    };
  }
});

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};
var init_json_schema = __esm({
  "node_modules/zod/v4/core/json-schema.js"() {
  }
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode2,
  encodeAsync: () => encodeAsync,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse3,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});
var init_core2 = __esm({
  "node_modules/zod/v4/core/index.js"() {
    init_core();
    init_parse2();
    init_errors();
    init_schemas();
    init_checks();
    init_versions();
    init_util();
    init_regexes();
    init_locales();
    init_registries();
    init_doc();
    init_api();
    init_to_json_schema();
    init_json_schema();
  }
});

// node_modules/zod/v4/classic/checks.js
var init_checks2 = __esm({
  "node_modules/zod/v4/classic/checks.js"() {
    init_core2();
  }
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
function date2(params) {
  return _isoDate(ZodISODate, params);
}
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}
var ZodISODateTime, ZodISODate, ZodISOTime, ZodISODuration;
var init_iso = __esm({
  "node_modules/zod/v4/classic/iso.js"() {
    init_core2();
    init_schemas2();
    ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
      $ZodISODateTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
      $ZodISODate.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
      $ZodISOTime.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
      $ZodISODuration.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
  }
});

// node_modules/zod/v4/classic/errors.js
var initializer2, ZodError, ZodRealError;
var init_errors2 = __esm({
  "node_modules/zod/v4/classic/errors.js"() {
    init_core2();
    init_core2();
    init_util();
    initializer2 = (inst, issues) => {
      $ZodError.init(inst, issues);
      inst.name = "ZodError";
      Object.defineProperties(inst, {
        format: {
          value: (mapper) => formatError(inst, mapper)
          // enumerable: false,
        },
        flatten: {
          value: (mapper) => flattenError(inst, mapper)
          // enumerable: false,
        },
        addIssue: {
          value: (issue2) => {
            inst.issues.push(issue2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        addIssues: {
          value: (issues2) => {
            inst.issues.push(...issues2);
            inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
          }
          // enumerable: false,
        },
        isEmpty: {
          get() {
            return inst.issues.length === 0;
          }
          // enumerable: false,
        }
      });
    };
    ZodError = $constructor("ZodError", initializer2);
    ZodRealError = $constructor("ZodError", initializer2, {
      Parent: Error
    });
  }
});

// node_modules/zod/v4/classic/parse.js
var parse4, parseAsync2, safeParse2, safeParseAsync2, encode3, decode2, encodeAsync2, decodeAsync2, safeEncode2, safeDecode2, safeEncodeAsync2, safeDecodeAsync2;
var init_parse3 = __esm({
  "node_modules/zod/v4/classic/parse.js"() {
    init_core2();
    init_errors2();
    parse4 = /* @__PURE__ */ _parse(ZodRealError);
    parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
    safeParse2 = /* @__PURE__ */ _safeParse(ZodRealError);
    safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);
    encode3 = /* @__PURE__ */ _encode(ZodRealError);
    decode2 = /* @__PURE__ */ _decode(ZodRealError);
    encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError);
    decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError);
    safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError);
    safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError);
    safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
    safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);
  }
});

// node_modules/zod/v4/classic/schemas.js
function string2(params) {
  return _string(ZodString, params);
}
function email2(params) {
  return _email(ZodEmail, params);
}
function guid2(params) {
  return _guid(ZodGUID, params);
}
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
function ulid2(params) {
  return _ulid(ZodULID, params);
}
function xid2(params) {
  return _xid(ZodXID, params);
}
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
function mac2(params) {
  return _mac(ZodMAC, params);
}
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
function base643(params) {
  return _base64(ZodBase64, params);
}
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
function e1642(params) {
  return _e164(ZodE164, params);
}
function jwt(params) {
  return _jwt(ZodJWT, params);
}
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash3(alg, params) {
  const enc = params?.enc ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
function number2(params) {
  return _number(ZodNumber, params);
}
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
function _null3(params) {
  return _null2(ZodNull, params);
}
function any() {
  return _any(ZodAny);
}
function unknown() {
  return _unknown(ZodUnknown);
}
function never(params) {
  return _never(ZodNever, params);
}
function _void2(params) {
  return _void(ZodVoid, params);
}
function date3(params) {
  return _date(ZodDate, params);
}
function array2(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function union(options2, params) {
  return new ZodUnion({
    type: "union",
    options: options2,
    ...util_exports.normalizeParams(params)
  });
}
function discriminatedUnion(discriminator, options2, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options: options2,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
function file(params) {
  return _file(ZodFile, params);
}
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function nan(params) {
  return _nan(ZodNaN, params);
}
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array2(unknown()),
    output: params?.output ?? unknown()
  });
}
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
function json2(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array2(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}
var ZodType, _ZodString, ZodString, ZodStringFormat, ZodEmail, ZodGUID, ZodUUID, ZodURL, ZodEmoji, ZodNanoID, ZodCUID, ZodCUID2, ZodULID, ZodXID, ZodKSUID, ZodIPv4, ZodMAC, ZodIPv6, ZodCIDRv4, ZodCIDRv6, ZodBase64, ZodBase64URL, ZodE164, ZodJWT, ZodCustomStringFormat, ZodNumber, ZodNumberFormat, ZodBoolean, ZodBigInt, ZodBigIntFormat, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodDate, ZodArray, ZodObject, ZodUnion, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodEnum, ZodLiteral, ZodFile, ZodTransform, ZodOptional, ZodNullable, ZodDefault, ZodPrefault, ZodNonOptional, ZodSuccess, ZodCatch, ZodNaN, ZodPipe, ZodCodec, ZodReadonly, ZodTemplateLiteral, ZodLazy, ZodPromise, ZodFunction, ZodCustom, describe2, meta2, stringbool;
var init_schemas2 = __esm({
  "node_modules/zod/v4/classic/schemas.js"() {
    init_core2();
    init_core2();
    init_checks2();
    init_iso();
    init_parse3();
    ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
      $ZodType.init(inst, def);
      inst.def = def;
      inst.type = def.type;
      Object.defineProperty(inst, "_def", { value: def });
      inst.check = (...checks) => {
        return inst.clone(util_exports.mergeDefs(def, {
          checks: [
            ...def.checks ?? [],
            ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
          ]
        }));
      };
      inst.clone = (def2, params) => clone(inst, def2, params);
      inst.brand = () => inst;
      inst.register = (reg, meta3) => {
        reg.add(inst, meta3);
        return inst;
      };
      inst.parse = (data, params) => parse4(inst, data, params, { callee: inst.parse });
      inst.safeParse = (data, params) => safeParse2(inst, data, params);
      inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
      inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
      inst.spa = inst.safeParseAsync;
      inst.encode = (data, params) => encode3(inst, data, params);
      inst.decode = (data, params) => decode2(inst, data, params);
      inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
      inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
      inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
      inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
      inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
      inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
      inst.refine = (check2, params) => inst.check(refine(check2, params));
      inst.superRefine = (refinement) => inst.check(superRefine(refinement));
      inst.overwrite = (fn) => inst.check(_overwrite(fn));
      inst.optional = () => optional(inst);
      inst.nullable = () => nullable(inst);
      inst.nullish = () => optional(nullable(inst));
      inst.nonoptional = (params) => nonoptional(inst, params);
      inst.array = () => array2(inst);
      inst.or = (arg) => union([inst, arg]);
      inst.and = (arg) => intersection(inst, arg);
      inst.transform = (tx) => pipe(inst, transform(tx));
      inst.default = (def2) => _default2(inst, def2);
      inst.prefault = (def2) => prefault(inst, def2);
      inst.catch = (params) => _catch2(inst, params);
      inst.pipe = (target) => pipe(inst, target);
      inst.readonly = () => readonly(inst);
      inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
      };
      Object.defineProperty(inst, "description", {
        get() {
          return globalRegistry.get(inst)?.description;
        },
        configurable: true
      });
      inst.meta = (...args) => {
        if (args.length === 0) {
          return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
      };
      inst.isOptional = () => inst.safeParse(void 0).success;
      inst.isNullable = () => inst.safeParse(null).success;
      return inst;
    });
    _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      ZodType.init(inst, def);
      const bag = inst._zod.bag;
      inst.format = bag.format ?? null;
      inst.minLength = bag.minimum ?? null;
      inst.maxLength = bag.maximum ?? null;
      inst.regex = (...args) => inst.check(_regex(...args));
      inst.includes = (...args) => inst.check(_includes(...args));
      inst.startsWith = (...args) => inst.check(_startsWith(...args));
      inst.endsWith = (...args) => inst.check(_endsWith(...args));
      inst.min = (...args) => inst.check(_minLength(...args));
      inst.max = (...args) => inst.check(_maxLength(...args));
      inst.length = (...args) => inst.check(_length(...args));
      inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
      inst.lowercase = (params) => inst.check(_lowercase(params));
      inst.uppercase = (params) => inst.check(_uppercase(params));
      inst.trim = () => inst.check(_trim());
      inst.normalize = (...args) => inst.check(_normalize(...args));
      inst.toLowerCase = () => inst.check(_toLowerCase());
      inst.toUpperCase = () => inst.check(_toUpperCase());
      inst.slugify = () => inst.check(_slugify());
    });
    ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
      $ZodString.init(inst, def);
      _ZodString.init(inst, def);
      inst.email = (params) => inst.check(_email(ZodEmail, params));
      inst.url = (params) => inst.check(_url(ZodURL, params));
      inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
      inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
      inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
      inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
      inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
      inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
      inst.guid = (params) => inst.check(_guid(ZodGUID, params));
      inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
      inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
      inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
      inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
      inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
      inst.xid = (params) => inst.check(_xid(ZodXID, params));
      inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
      inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
      inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
      inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
      inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
      inst.e164 = (params) => inst.check(_e164(ZodE164, params));
      inst.datetime = (params) => inst.check(datetime2(params));
      inst.date = (params) => inst.check(date2(params));
      inst.time = (params) => inst.check(time2(params));
      inst.duration = (params) => inst.check(duration2(params));
    });
    ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
      $ZodStringFormat.init(inst, def);
      _ZodString.init(inst, def);
    });
    ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
      $ZodEmail.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
      $ZodGUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
      $ZodUUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
      $ZodURL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
      $ZodEmoji.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
      $ZodNanoID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
      $ZodCUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
      $ZodCUID2.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
      $ZodULID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
      $ZodXID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
      $ZodKSUID.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
      $ZodIPv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
      $ZodMAC.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
      $ZodIPv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
      $ZodCIDRv4.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
      $ZodCIDRv6.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
      $ZodBase64.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
      $ZodBase64URL.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
      $ZodE164.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
      $ZodJWT.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
      $ZodCustomStringFormat.init(inst, def);
      ZodStringFormat.init(inst, def);
    });
    ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
      $ZodNumber.init(inst, def);
      ZodType.init(inst, def);
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.int = (params) => inst.check(int(params));
      inst.safe = (params) => inst.check(int(params));
      inst.positive = (params) => inst.check(_gt(0, params));
      inst.nonnegative = (params) => inst.check(_gte(0, params));
      inst.negative = (params) => inst.check(_lt(0, params));
      inst.nonpositive = (params) => inst.check(_lte(0, params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      inst.step = (value, params) => inst.check(_multipleOf(value, params));
      inst.finite = () => inst;
      const bag = inst._zod.bag;
      inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
      inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
      inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
      inst.isFinite = true;
      inst.format = bag.format ?? null;
    });
    ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
      $ZodNumberFormat.init(inst, def);
      ZodNumber.init(inst, def);
    });
    ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
      $ZodBoolean.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
      $ZodBigInt.init(inst, def);
      ZodType.init(inst, def);
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.gt = (value, params) => inst.check(_gt(value, params));
      inst.gte = (value, params) => inst.check(_gte(value, params));
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.lt = (value, params) => inst.check(_lt(value, params));
      inst.lte = (value, params) => inst.check(_lte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      inst.positive = (params) => inst.check(_gt(BigInt(0), params));
      inst.negative = (params) => inst.check(_lt(BigInt(0), params));
      inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
      inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
      inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
      const bag = inst._zod.bag;
      inst.minValue = bag.minimum ?? null;
      inst.maxValue = bag.maximum ?? null;
      inst.format = bag.format ?? null;
    });
    ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
      $ZodBigIntFormat.init(inst, def);
      ZodBigInt.init(inst, def);
    });
    ZodSymbol = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
      $ZodSymbol.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodUndefined = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
      $ZodUndefined.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
      $ZodNull.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
      $ZodAny.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
      $ZodUnknown.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
      $ZodNever.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodVoid = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
      $ZodVoid.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
      $ZodDate.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (value, params) => inst.check(_gte(value, params));
      inst.max = (value, params) => inst.check(_lte(value, params));
      const c2 = inst._zod.bag;
      inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
      inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
    });
    ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
      $ZodArray.init(inst, def);
      ZodType.init(inst, def);
      inst.element = def.element;
      inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
      inst.nonempty = (params) => inst.check(_minLength(1, params));
      inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
      inst.length = (len, params) => inst.check(_length(len, params));
      inst.unwrap = () => inst.element;
    });
    ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
      $ZodObjectJIT.init(inst, def);
      ZodType.init(inst, def);
      util_exports.defineLazy(inst, "shape", () => {
        return def.shape;
      });
      inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
      inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
      inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
      inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
      inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
      inst.extend = (incoming) => {
        return util_exports.extend(inst, incoming);
      };
      inst.safeExtend = (incoming) => {
        return util_exports.safeExtend(inst, incoming);
      };
      inst.merge = (other) => util_exports.merge(inst, other);
      inst.pick = (mask) => util_exports.pick(inst, mask);
      inst.omit = (mask) => util_exports.omit(inst, mask);
      inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
      inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
    });
    ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
      $ZodUnion.init(inst, def);
      ZodType.init(inst, def);
      inst.options = def.options;
    });
    ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
      ZodUnion.init(inst, def);
      $ZodDiscriminatedUnion.init(inst, def);
    });
    ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
      $ZodIntersection.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodTuple = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
      $ZodTuple.init(inst, def);
      ZodType.init(inst, def);
      inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest
      });
    });
    ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
      $ZodRecord.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodMap = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
      $ZodMap.init(inst, def);
      ZodType.init(inst, def);
      inst.keyType = def.keyType;
      inst.valueType = def.valueType;
    });
    ZodSet = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
      $ZodSet.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (...args) => inst.check(_minSize(...args));
      inst.nonempty = (params) => inst.check(_minSize(1, params));
      inst.max = (...args) => inst.check(_maxSize(...args));
      inst.size = (...args) => inst.check(_size(...args));
    });
    ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
      $ZodEnum.init(inst, def);
      ZodType.init(inst, def);
      inst.enum = def.entries;
      inst.options = Object.values(def.entries);
      const keys = new Set(Object.keys(def.entries));
      inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
          if (keys.has(value)) {
            newEntries[value] = def.entries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
      inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
          if (keys.has(value)) {
            delete newEntries[value];
          } else
            throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
          ...def,
          checks: [],
          ...util_exports.normalizeParams(params),
          entries: newEntries
        });
      };
    });
    ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
      $ZodLiteral.init(inst, def);
      ZodType.init(inst, def);
      inst.values = new Set(def.values);
      Object.defineProperty(inst, "value", {
        get() {
          if (def.values.length > 1) {
            throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
          }
          return def.values[0];
        }
      });
    });
    ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
      $ZodFile.init(inst, def);
      ZodType.init(inst, def);
      inst.min = (size, params) => inst.check(_minSize(size, params));
      inst.max = (size, params) => inst.check(_maxSize(size, params));
      inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
    });
    ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
      $ZodTransform.init(inst, def);
      ZodType.init(inst, def);
      inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
          throw new $ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue2) => {
          if (typeof issue2 === "string") {
            payload.issues.push(util_exports.issue(issue2, payload.value, def));
          } else {
            const _issue = issue2;
            if (_issue.fatal)
              _issue.continue = false;
            _issue.code ?? (_issue.code = "custom");
            _issue.input ?? (_issue.input = payload.value);
            _issue.inst ?? (_issue.inst = inst);
            payload.issues.push(util_exports.issue(_issue));
          }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
          return output.then((output2) => {
            payload.value = output2;
            return payload;
          });
        }
        payload.value = output;
        return payload;
      };
    });
    ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
      $ZodOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
      $ZodNullable.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
      $ZodDefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeDefault = inst.unwrap;
    });
    ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
      $ZodPrefault.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
      $ZodNonOptional.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
      $ZodSuccess.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
      $ZodCatch.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
      inst.removeCatch = inst.unwrap;
    });
    ZodNaN = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
      $ZodNaN.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
      $ZodPipe.init(inst, def);
      ZodType.init(inst, def);
      inst.in = def.in;
      inst.out = def.out;
    });
    ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
      ZodPipe.init(inst, def);
      $ZodCodec.init(inst, def);
    });
    ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
      $ZodReadonly.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
      $ZodTemplateLiteral.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodLazy = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
      $ZodLazy.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.getter();
    });
    ZodPromise = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
      $ZodPromise.init(inst, def);
      ZodType.init(inst, def);
      inst.unwrap = () => inst._zod.def.innerType;
    });
    ZodFunction = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
      $ZodFunction.init(inst, def);
      ZodType.init(inst, def);
    });
    ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
      $ZodCustom.init(inst, def);
      ZodType.init(inst, def);
    });
    describe2 = describe;
    meta2 = meta;
    stringbool = (...args) => _stringbool({
      Codec: ZodCodec,
      Boolean: ZodBoolean,
      String: ZodString
    }, ...args);
  }
});

// node_modules/zod/v4/classic/compat.js
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodIssueCode, ZodFirstPartyTypeKind;
var init_compat = __esm({
  "node_modules/zod/v4/classic/compat.js"() {
    init_core2();
    init_core2();
    ZodIssueCode = {
      invalid_type: "invalid_type",
      too_big: "too_big",
      too_small: "too_small",
      invalid_format: "invalid_format",
      not_multiple_of: "not_multiple_of",
      unrecognized_keys: "unrecognized_keys",
      invalid_union: "invalid_union",
      invalid_key: "invalid_key",
      invalid_element: "invalid_element",
      invalid_value: "invalid_value",
      custom: "custom"
    };
    /* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  }
});

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}
var init_coerce = __esm({
  "node_modules/zod/v4/classic/coerce.js"() {
    init_core2();
    init_schemas2();
  }
});

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array2,
  base64: () => base643,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode3,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash3,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json2,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse4,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});
var init_external = __esm({
  "node_modules/zod/v4/classic/external.js"() {
    init_core2();
    init_schemas2();
    init_checks2();
    init_errors2();
    init_parse3();
    init_compat();
    init_core2();
    init_en();
    init_core2();
    init_locales();
    init_iso();
    init_iso();
    init_coerce();
    config(en_default());
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// .svelte-kit/output/server/chunks/validation.js
function validateInput(schema, data) {
  const result = schema.safeParse(data);
  if (!result.success) {
    const errors = {};
    result.error.issues.forEach((issue2) => {
      const key2 = issue2.path[0];
      if (typeof key2 === "string") {
        errors[key2] = issue2.message;
      }
    });
    return { success: false, errors };
  }
  return { success: true, data: result.data };
}
var passwordPatterns, errorMessages, registerSchema, createOrganizationSchema, joinOrganizationSchema, loginSchema, assetSchema, workOrderCommentSchema, workOrderChecklistSchema, workOrderTemplateItemSchema, workOrderTemplateSchema, workOrderTemplateUpdateSchema, passwordResetSchema;
var init_validation = __esm({
  ".svelte-kit/output/server/chunks/validation.js"() {
    init_zod();
    passwordPatterns = {
      uppercase: /[A-Z]/,
      lowercase: /[a-z]/,
      number: /[0-9]/,
      special: /[^A-Za-z0-9]/
    };
    errorMessages = {
      email: "Please enter a valid email address",
      password: {
        minLength: "Password must be at least 8 characters long",
        uppercase: "Password must contain at least one uppercase letter",
        lowercase: "Password must contain at least one lowercase letter",
        number: "Password must contain at least one number",
        special: "Password must contain at least one special character"
      },
      orgName: "Organization name must be between 2 and 100 characters",
      name: "Name must be between 1 and 50 characters"
    };
    registerSchema = external_exports.object({
      firstName: external_exports.string().min(1, errorMessages.name).max(50, errorMessages.name).trim(),
      lastName: external_exports.string().max(50, errorMessages.name).trim().optional(),
      email: external_exports.string().email(errorMessages.email).trim().toLowerCase(),
      password: external_exports.string().min(8, errorMessages.password.minLength).regex(passwordPatterns.uppercase, errorMessages.password.uppercase).regex(passwordPatterns.lowercase, errorMessages.password.lowercase).regex(passwordPatterns.number, errorMessages.password.number).regex(passwordPatterns.special, errorMessages.password.special)
    });
    createOrganizationSchema = external_exports.object({
      orgName: external_exports.string().min(2, errorMessages.orgName).max(100, errorMessages.orgName).trim()
    });
    joinOrganizationSchema = external_exports.object({
      inviteToken: external_exports.string().min(1, "Invite token is required").trim()
    });
    loginSchema = external_exports.object({
      email: external_exports.string().email(errorMessages.email).trim().toLowerCase(),
      password: external_exports.string().min(1, "Password is required")
    });
    external_exports.object({
      name: external_exports.string().min(1, "Site name is required").max(100, "Site name must be less than 100 characters").trim()
    });
    external_exports.object({
      name: external_exports.string().min(1, "Room name is required").max(100, "Room name must be less than 100 characters").trim(),
      building: external_exports.string().max(10, "Building identifier must be less than 10 characters").trim().optional(),
      floor: external_exports.number().int().min(0, "Floor must be 0 or higher").max(100, "Floor must be less than 100").optional()
    });
    assetSchema = external_exports.object({
      name: external_exports.string().min(1, "Asset name is required").max(100, "Asset name must be less than 100 characters").trim(),
      unitId: external_exports.string().min(1, "Please select a unit").cuid("Invalid unit selection"),
      type: external_exports.enum(["HVAC", "ELECTRICAL", "PLUMBING", "FIRE_SAFETY", "ELEVATOR", "SECURITY_SYSTEM", "OTHER"]).optional(),
      status: external_exports.enum(["OPERATIONAL", "NEEDS_MAINTENANCE", "OUT_OF_SERVICE"]).optional(),
      description: external_exports.string().max(1e3, "Description must be less than 1000 characters").trim().optional(),
      purchaseDate: external_exports.string().datetime("Invalid date format").optional(),
      warrantyExpiry: external_exports.string().datetime("Invalid date format").optional()
    });
    external_exports.object({
      title: external_exports.string().min(1, "Title is required").max(200, "Title must be less than 200 characters").trim(),
      description: external_exports.string().max(5e3, "Description must be less than 5000 characters").trim().optional(),
      priority: external_exports.enum(["LOW", "MEDIUM", "HIGH", "EMERGENCY"]).optional(),
      dueDate: external_exports.string().datetime("Invalid due date format").optional(),
      assignedToId: external_exports.string().cuid("Invalid user selection").optional(),
      selectionMode: external_exports.enum(["asset", "unit", "building", "site"]).optional(),
      assetId: external_exports.string().cuid("Invalid asset selection").optional(),
      unitId: external_exports.string().cuid("Invalid unit selection").optional(),
      buildingId: external_exports.string().cuid("Invalid building selection").optional(),
      siteId: external_exports.string().cuid("Invalid site selection").optional()
    });
    external_exports.object({
      title: external_exports.string().min(1, "Title is required").max(200, "Title must be less than 200 characters").trim(),
      description: external_exports.string().max(5e3, "Description must be less than 5000 characters").trim().optional(),
      assetId: external_exports.string().min(1, "Asset is required").cuid("Invalid asset selection")
    });
    external_exports.object({
      workOrderId: external_exports.string().min(1, "Work order ID is required").cuid("Invalid work order ID"),
      status: external_exports.enum(["PENDING", "IN_PROGRESS", "ON_HOLD", "COMPLETED", "CANCELLED"])
    });
    external_exports.object({
      workOrderId: external_exports.string().min(1, "Work order ID is required").cuid("Invalid work order ID"),
      assignedToId: external_exports.string().cuid("Invalid user selection").optional()
    });
    workOrderCommentSchema = external_exports.object({
      content: external_exports.string().min(1, "Comment cannot be empty").max(5e3, "Comment must be less than 5000 characters").trim(),
      parentId: external_exports.string().min(1, "Invalid parent comment ID").optional()
    });
    workOrderChecklistSchema = external_exports.object({
      title: external_exports.string().min(1, "Title is required").max(200, "Title must be less than 200 characters").trim()
    });
    workOrderTemplateItemSchema = external_exports.object({
      title: external_exports.string().min(1, "Item title is required").max(200, "Item title must be less than 200 characters").trim(),
      id: external_exports.string().optional()
      // For updates - existing items have IDs
    });
    workOrderTemplateSchema = external_exports.object({
      name: external_exports.string().min(1, "Template name is required").max(100, "Name must be less than 100 characters").trim(),
      description: external_exports.string().max(500, "Description must be less than 500 characters").trim().optional(),
      title: external_exports.string().min(1, "Default title is required").max(200, "Title must be less than 200 characters").trim().optional(),
      workDescription: external_exports.string().max(5e3, "Description must be less than 5000 characters").trim().optional(),
      priority: external_exports.enum(["LOW", "MEDIUM", "HIGH", "EMERGENCY"]).optional(),
      isGlobal: external_exports.boolean().optional(),
      items: external_exports.array(workOrderTemplateItemSchema).min(1, "At least one checklist item is required")
    });
    workOrderTemplateUpdateSchema = workOrderTemplateSchema.partial();
    external_exports.object({
      email: external_exports.string().email(errorMessages.email).trim().toLowerCase(),
      passphrase: external_exports.string().min(1, "Passphrase is required").trim()
    });
    passwordResetSchema = external_exports.object({
      token: external_exports.string().min(1, "Reset token is required").trim(),
      password: external_exports.string().min(8, errorMessages.password.minLength).regex(passwordPatterns.uppercase, errorMessages.password.uppercase).regex(passwordPatterns.lowercase, errorMessages.password.lowercase).regex(passwordPatterns.number, errorMessages.password.number).regex(passwordPatterns.special, errorMessages.password.special),
      confirmPassword: external_exports.string().min(1, "Please confirm your password")
    }).refine((data) => data.password === data.confirmPassword, {
      message: "Passwords don't match",
      path: ["confirmPassword"]
    });
    external_exports.object({
      firstName: external_exports.string().min(1, errorMessages.name).max(50, errorMessages.name).trim().optional(),
      lastName: external_exports.string().max(50, errorMessages.name).trim().optional(),
      email: external_exports.string().email(errorMessages.email).trim().toLowerCase().optional(),
      phoneNumber: external_exports.string().regex(/^[+]?[\d\s\-\(\)]+$/, "Please enter a valid phone number").optional()
    });
  }
});

// .svelte-kit/output/server/entries/pages/assets/_page.server.ts.js
var page_server_ts_exports2 = {};
__export(page_server_ts_exports2, {
  actions: () => actions2,
  load: () => load2
});
var load2, actions2;
var init_page_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/pages/assets/_page.server.ts.js"() {
    init_prisma();
    init_chunks();
    init_guards();
    init_audit();
    init_validation();
    load2 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const organizationId = event.locals.user.organizationId;
      const typeFilter = event.url.searchParams.get("type");
      const statusFilter = event.url.searchParams.get("status");
      const siteFilter = event.url.searchParams.get("siteId");
      const sortFilter = event.url.searchParams.get("sort") || "created";
      const search = event.url.searchParams.get("search");
      const where = {
        Unit: {
          Site: {
            organizationId: organizationId ?? void 0
          }
        }
      };
      if (typeFilter)
        where.type = typeFilter;
      if (statusFilter)
        where.status = statusFilter;
      if (siteFilter)
        where.siteId = siteFilter;
      if (search && search.trim()) {
        where.OR = [
          { name: { contains: search.trim(), mode: "insensitive" } },
          { description: { contains: search.trim(), mode: "insensitive" } }
        ];
      }
      let orderBy = { createdAt: "desc" };
      switch (sortFilter) {
        case "name":
          orderBy = { name: "asc" };
          break;
        case "type":
          orderBy = [{ type: "asc" }, { createdAt: "desc" }];
          break;
        case "status":
          orderBy = [{ status: "asc" }, { createdAt: "desc" }];
          break;
        case "created":
        default:
          orderBy = { createdAt: "desc" };
          break;
      }
      const assets2 = await prisma.asset.findMany({
        where,
        orderBy,
        include: {
          Unit: {
            include: {
              Site: {
                select: { name: true }
              },
              Building: {
                select: { name: true }
              }
            }
          },
          _count: {
            select: { WorkOrder: true }
          }
        }
      });
      const units = await prisma.unit.findMany({
        where: {
          Site: {
            organizationId: organizationId ?? void 0
          }
        },
        orderBy: [
          { Site: { name: "asc" } },
          { Building: { name: "asc" } },
          { roomNumber: "asc" }
        ],
        include: {
          Site: {
            select: { name: true }
          },
          Building: {
            select: { name: true }
          }
        }
      });
      const sites = await prisma.site.findMany({
        where: {
          organizationId: organizationId ?? void 0
        },
        orderBy: { name: "asc" },
        select: {
          id: true,
          name: true
        }
      });
      return {
        assets: assets2,
        units,
        sites,
        type: typeFilter,
        status: statusFilter,
        siteId: siteFilter,
        sort: sortFilter,
        search
      };
    };
    actions2 = {
      create: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const organizationId = event.locals.user.organizationId;
        const rawData = {
          name: formData.get("name"),
          unitId: formData.get("unitId"),
          type: formData.get("type"),
          status: formData.get("status") || "OPERATIONAL",
          description: formData.get("description"),
          purchaseDate: formData.get("purchaseDate"),
          warrantyExpiry: formData.get("warrantyExpiry")
        };
        const validationResult = assetSchema.safeParse(rawData);
        if (!validationResult.success) {
          const firstError = validationResult.error.issues[0];
          return fail(400, { error: firstError.message });
        }
        const data = validationResult.data;
        const unit = await prisma.unit.findFirst({
          where: {
            id: data.unitId,
            Site: {
              organizationId: organizationId ?? void 0
            }
          }
        });
        if (!unit) {
          return fail(404, { error: "Unit not found" });
        }
        const asset = await prisma.asset.create({
          data: {
            name: data.name.trim(),
            type: data.type || "OTHER",
            status: data.status || "OPERATIONAL",
            description: data.description?.trim() || null,
            purchaseDate: data.purchaseDate ? new Date(data.purchaseDate) : null,
            warrantyExpiry: data.warrantyExpiry ? new Date(data.warrantyExpiry) : null,
            unitId: data.unitId,
            siteId: unit.siteId,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        await logAudit(event.locals.user.id, "ASSET_CREATED", {
          assetId: asset.id,
          name: asset.name,
          unitId: data.unitId
        });
        return { success: true, asset };
      },
      delete: async (event) => {
        if (!isManagerOrAbove(event)) {
          return fail(403, { error: "Permission denied. Only managers can delete assets." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const organizationId = event.locals.user.organizationId;
        const assetId = formData.get("assetId");
        if (!assetId) {
          return fail(400, { error: "Asset ID is required" });
        }
        const asset = await prisma.asset.findFirst({
          where: {
            id: assetId,
            Unit: {
              Site: {
                organizationId: organizationId ?? void 0
              }
            }
          },
          select: { name: true }
        });
        if (!asset) {
          return fail(404, { error: "Asset not found" });
        }
        await prisma.asset.delete({
          where: { id: assetId }
        });
        await logAudit(event.locals.user.id, "ASSET_DELETED", {
          assetId,
          name: asset?.name
        });
        return { success: true };
      },
      update: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const organizationId = event.locals.user.organizationId;
        const assetId = formData.get("assetId");
        const rawData = {
          name: formData.get("name"),
          unitId: formData.get("unitId"),
          type: formData.get("type"),
          status: formData.get("status"),
          description: formData.get("description"),
          purchaseDate: formData.get("purchaseDate"),
          warrantyExpiry: formData.get("warrantyExpiry")
        };
        const validationResult = assetSchema.safeParse(rawData);
        if (!validationResult.success) {
          const firstError = validationResult.error.issues[0];
          return fail(400, { error: firstError.message });
        }
        const data = validationResult.data;
        if (!assetId) {
          return fail(400, { error: "Asset ID is required" });
        }
        const existingAsset = await prisma.asset.findFirst({
          where: {
            id: assetId,
            Unit: {
              Site: {
                organizationId: organizationId ?? void 0
              }
            }
          }
        });
        if (!existingAsset) {
          return fail(404, { error: "Asset not found" });
        }
        const unit = await prisma.unit.findFirst({
          where: {
            id: data.unitId,
            Site: {
              organizationId: organizationId ?? void 0
            }
          }
        });
        if (!unit) {
          return fail(404, { error: "Unit not found" });
        }
        const asset = await prisma.asset.update({
          where: { id: assetId },
          data: {
            name: data.name.trim(),
            type: data.type ? data.type : void 0,
            status: data.status ? data.status : void 0,
            description: data.description ? data.description.trim() : void 0,
            purchaseDate: data.purchaseDate ? new Date(data.purchaseDate) : null,
            warrantyExpiry: data.warrantyExpiry ? new Date(data.warrantyExpiry) : null,
            unitId: data.unitId,
            siteId: unit.siteId
          }
        });
        return { success: true, asset };
      }
    };
  }
});

// .svelte-kit/output/server/chunks/FilterBar.js
function client_method(key2) {
  {
    if (key2 === "before_navigate" || key2 === "after_navigate" || key2 === "on_navigate") {
      return () => {
      };
    } else {
      const name_lookup = {
        disable_scroll_handling: "disableScrollHandling",
        preload_data: "preloadData",
        preload_code: "preloadCode",
        invalidate_all: "invalidateAll"
      };
      return () => {
        throw new Error(`Cannot call ${name_lookup[key2] ?? key2}(...) on the server`);
      };
    }
  }
}
var goto, invalidateAll, FilterBar;
var init_FilterBar = __esm({
  ".svelte-kit/output/server/chunks/FilterBar.js"() {
    init_ssr();
    goto = /* @__PURE__ */ client_method("goto");
    invalidateAll = /* @__PURE__ */ client_method("invalidate_all");
    FilterBar = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { showFilters = false } = $$props;
      let { onClear = void 0 } = $$props;
      let { clearLabel = "Reset" } = $$props;
      let { mobileTitle = "Filters & Sort" } = $$props;
      let { searchValue = "" } = $$props;
      let { searchPlaceholder = "Search..." } = $$props;
      let { onSearch = void 0 } = $$props;
      let { searchTitle = "Search" } = $$props;
      let { toggleButtons = [] } = $$props;
      let { filters = [] } = $$props;
      let { sortOptions } = $$props;
      let { sortValue } = $$props;
      let { onSortChange } = $$props;
      let { sortPlaceholder = "Sort..." } = $$props;
      createEventDispatcher();
      function hasActiveFilters() {
        return searchValue.trim() !== "" || toggleButtons.some((b) => b.active) || filters.some((f) => f.value && f.value !== "" && f.value !== false);
      }
      if ($$props.showFilters === void 0 && $$bindings.showFilters && showFilters !== void 0)
        $$bindings.showFilters(showFilters);
      if ($$props.onClear === void 0 && $$bindings.onClear && onClear !== void 0)
        $$bindings.onClear(onClear);
      if ($$props.clearLabel === void 0 && $$bindings.clearLabel && clearLabel !== void 0)
        $$bindings.clearLabel(clearLabel);
      if ($$props.mobileTitle === void 0 && $$bindings.mobileTitle && mobileTitle !== void 0)
        $$bindings.mobileTitle(mobileTitle);
      if ($$props.searchValue === void 0 && $$bindings.searchValue && searchValue !== void 0)
        $$bindings.searchValue(searchValue);
      if ($$props.searchPlaceholder === void 0 && $$bindings.searchPlaceholder && searchPlaceholder !== void 0)
        $$bindings.searchPlaceholder(searchPlaceholder);
      if ($$props.onSearch === void 0 && $$bindings.onSearch && onSearch !== void 0)
        $$bindings.onSearch(onSearch);
      if ($$props.searchTitle === void 0 && $$bindings.searchTitle && searchTitle !== void 0)
        $$bindings.searchTitle(searchTitle);
      if ($$props.toggleButtons === void 0 && $$bindings.toggleButtons && toggleButtons !== void 0)
        $$bindings.toggleButtons(toggleButtons);
      if ($$props.filters === void 0 && $$bindings.filters && filters !== void 0)
        $$bindings.filters(filters);
      if ($$props.sortOptions === void 0 && $$bindings.sortOptions && sortOptions !== void 0)
        $$bindings.sortOptions(sortOptions);
      if ($$props.sortValue === void 0 && $$bindings.sortValue && sortValue !== void 0)
        $$bindings.sortValue(sortValue);
      if ($$props.onSortChange === void 0 && $$bindings.onSortChange && onSortChange !== void 0)
        $$bindings.onSortChange(onSortChange);
      if ($$props.sortPlaceholder === void 0 && $$bindings.sortPlaceholder && sortPlaceholder !== void 0)
        $$bindings.sortPlaceholder(sortPlaceholder);
      return `<div class="bg-spore-white rounded-xl mb-6 shadow-sm border border-spore-cream/50"> <div class="p-4 border-b border-spore-cream/30"><div class="relative"><input type="text"${add_attribute("placeholder", searchPlaceholder, 0)}${add_attribute("title", searchTitle, 0)} class="w-full pl-10 pr-4 py-2 bg-spore-cream/10 border border-spore-cream/30 rounded-lg text-sm text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", searchValue, 0)}> <svg class="absolute left-3 top-1/2 -translate-y-1/2 w-4 h-4 text-spore-steel" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg> ${searchValue ? `<button type="button" class="absolute right-3 top-1/2 -translate-y-1/2 text-spore-steel hover:text-spore-dark" title="Clear search"><svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg></button>` : ``}</div></div>  <div class="md:hidden p-4 border-b border-spore-cream/30 flex justify-between items-center bg-spore-cream/10"><span class="text-sm font-bold text-spore-dark uppercase tracking-wide">${escape(mobileTitle)}</span> <button class="text-spore-orange font-bold text-sm" type="button" title="Toggle filters">${escape(showFilters ? "Hide" : "Show")}</button></div>  <div class="${escape(showFilters ? "block" : "hidden", true) + " md:block p-4 space-y-4 md:space-y-0"}"><div class="flex flex-col md:flex-row md:items-center gap-4"> ${each(toggleButtons, (btn) => {
        return `<button type="button" class="${"flex items-center gap-2 px-3 py-2 rounded-lg transition-colors " + escape(
          btn.active ? "bg-spore-orange/10 text-spore-orange ring-1 ring-spore-orange" : "bg-spore-cream/20 text-spore-steel hover:bg-spore-cream/30",
          true
        )}"${add_attribute("title", btn.title, 0)}><span class="w-4 h-4 rounded-full border border-current flex items-center justify-center">${btn.active ? `<span class="w-2 h-2 rounded-full bg-current"></span>` : ``}</span> <span class="text-sm font-bold">${escape(btn.label)}</span> </button>`;
      })} ${toggleButtons.length > 0 ? `<div class="h-6 w-px bg-spore-cream/50 hidden md:block"></div>` : ``}  ${hasActiveFilters() ? `<button type="button" class="text-xs font-bold text-red-500 hover:text-red-600 px-2" title="Clear all filters">${escape(clearLabel)}</button> <div class="h-6 w-px bg-spore-cream/50 hidden md:block"></div>` : ``}  <div class="grid grid-cols-2 md:flex md:items-center gap-2 md:gap-4 flex-1">${each(filters, (filter) => {
        return `${filter.show !== false ? `<select class="w-full md:w-auto bg-spore-cream/10 border border-spore-cream/30 rounded-lg px-3 py-2 text-sm text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("title", filter.title, 0)}><option value="">${escape(filter.placeholder)}</option>${each(filter.options, (opt) => {
          return `<option${add_attribute("value", opt.value, 0)}>${escape(opt.label)}</option>`;
        })}</select>` : ``}`;
      })}  <select class="w-full md:w-auto bg-spore-cream/10 border border-spore-cream/30 rounded-lg px-3 py-2 text-sm text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange" title="Sort results">${each(sortOptions, (opt) => {
        return `<option${add_attribute("value", opt.value, 0)}>${escape(opt.label)}</option>`;
      })}</select></div></div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/chunks/constants.js
function getStatusColor(status) {
  return WORK_ORDER_STATUS_COLORS[status] || WORK_ORDER_STATUS_COLORS.PENDING;
}
function formatStatus(status) {
  return status.replace(/_/g, " ");
}
function formatAssetStatus(status) {
  return status?.replace("_", " ") || "Unknown";
}
var WORK_ORDER_STATUSES, PRIORITIES, DEFAULT_SORT_OPTION, DEFAULT_PRIORITY, DEFAULT_SELECTION_MODE, PRIORITY_ORDER, WORK_ORDER_STATUS_COLORS, STATUSES_REQUIRING_REASON, WORK_ORDER_PRIORITY_COLORS, ASSET_TYPES, ASSET_STATUSES, ASSET_STATUS_COLORS;
var init_constants2 = __esm({
  ".svelte-kit/output/server/chunks/constants.js"() {
    WORK_ORDER_STATUSES = [
      "PENDING",
      "IN_PROGRESS",
      "ON_HOLD",
      "COMPLETED",
      "CANCELLED"
    ];
    PRIORITIES = [
      "LOW",
      "MEDIUM",
      "HIGH",
      "EMERGENCY"
    ];
    DEFAULT_SORT_OPTION = "dueDate";
    DEFAULT_PRIORITY = "MEDIUM";
    DEFAULT_SELECTION_MODE = "asset";
    PRIORITY_ORDER = {
      EMERGENCY: 0,
      HIGH: 1,
      MEDIUM: 2,
      LOW: 3
    };
    WORK_ORDER_STATUS_COLORS = {
      PENDING: "bg-spore-steel text-white",
      IN_PROGRESS: "bg-spore-orange text-white",
      COMPLETED: "bg-spore-forest text-white",
      ON_HOLD: "bg-spore-cream text-spore-steel",
      CANCELLED: "bg-red-600 text-white"
    };
    STATUSES_REQUIRING_REASON = ["ON_HOLD", "COMPLETED", "CANCELLED"];
    WORK_ORDER_PRIORITY_COLORS = {
      LOW: "bg-gray-100 text-gray-600",
      MEDIUM: "bg-blue-100 text-blue-600",
      HIGH: "bg-orange-100 text-orange-600",
      EMERGENCY: "bg-red-100 text-red-600"
    };
    ASSET_TYPES = [
      "HVAC",
      "ELECTRICAL",
      "PLUMBING",
      "FIRE_SAFETY",
      "ELEVATOR",
      "SECURITY_SYSTEM",
      "OTHER"
    ];
    ASSET_STATUSES = [
      "OPERATIONAL",
      "NEEDS_MAINTENANCE",
      "OUT_OF_SERVICE"
    ];
    ASSET_STATUS_COLORS = {
      OPERATIONAL: "bg-green-100 text-green-800",
      NEEDS_MAINTENANCE: "bg-yellow-100 text-yellow-800",
      OUT_OF_SERVICE: "bg-red-100 text-red-800"
    };
  }
});

// .svelte-kit/output/server/chunks/AssetStatusBadge.js
var AssetStatusBadge;
var init_AssetStatusBadge = __esm({
  ".svelte-kit/output/server/chunks/AssetStatusBadge.js"() {
    init_ssr();
    init_constants2();
    AssetStatusBadge = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { status } = $$props;
      let { size = "md" } = $$props;
      const sizeClasses = size === "sm" ? "px-2 py-1 text-xs" : "px-3 py-1 text-sm";
      const colorClass = ASSET_STATUS_COLORS[status] || "bg-gray-100 text-gray-800";
      const statusLabel = formatAssetStatus(status);
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.size === void 0 && $$bindings.size && size !== void 0)
        $$bindings.size(size);
      return `<span class="${escape(sizeClasses, true) + " font-semibold rounded-full " + escape(colorClass, true)}"${add_attribute("title", statusLabel, 0)}>${escape(statusLabel)}</span>`;
    });
  }
});

// .svelte-kit/output/server/entries/pages/assets/_page.svelte.js
var page_svelte_exports2 = {};
__export(page_svelte_exports2, {
  default: () => Page2
});
function getUnitLabel(unit) {
  const parts = [unit.site?.name, `Unit ${unit.roomNumber}`];
  if (unit.building)
    parts.push(`(${unit.building.name})`);
  if (unit.name)
    parts.push(`- ${unit.name}`);
  return parts.filter(Boolean).join(" ");
}
var AssetForm, Page2;
var init_page_svelte2 = __esm({
  ".svelte-kit/output/server/entries/pages/assets/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    init_FilterBar();
    init_constants2();
    init_AssetStatusBadge();
    AssetForm = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { units = [] } = $$props;
      let { name = "" } = $$props;
      let { unitId = "" } = $$props;
      let { type = "OTHER" } = $$props;
      let { status = "OPERATIONAL" } = $$props;
      let { description = "" } = $$props;
      let { purchaseDate = "" } = $$props;
      let { warrantyExpiry = "" } = $$props;
      let { submitLabel = "SAVE" } = $$props;
      let { isSubmitting = false } = $$props;
      let { showCancel = false } = $$props;
      let { onCancel = void 0 } = $$props;
      if ($$props.units === void 0 && $$bindings.units && units !== void 0)
        $$bindings.units(units);
      if ($$props.name === void 0 && $$bindings.name && name !== void 0)
        $$bindings.name(name);
      if ($$props.unitId === void 0 && $$bindings.unitId && unitId !== void 0)
        $$bindings.unitId(unitId);
      if ($$props.type === void 0 && $$bindings.type && type !== void 0)
        $$bindings.type(type);
      if ($$props.status === void 0 && $$bindings.status && status !== void 0)
        $$bindings.status(status);
      if ($$props.description === void 0 && $$bindings.description && description !== void 0)
        $$bindings.description(description);
      if ($$props.purchaseDate === void 0 && $$bindings.purchaseDate && purchaseDate !== void 0)
        $$bindings.purchaseDate(purchaseDate);
      if ($$props.warrantyExpiry === void 0 && $$bindings.warrantyExpiry && warrantyExpiry !== void 0)
        $$bindings.warrantyExpiry(warrantyExpiry);
      if ($$props.submitLabel === void 0 && $$bindings.submitLabel && submitLabel !== void 0)
        $$bindings.submitLabel(submitLabel);
      if ($$props.isSubmitting === void 0 && $$bindings.isSubmitting && isSubmitting !== void 0)
        $$bindings.isSubmitting(isSubmitting);
      if ($$props.showCancel === void 0 && $$bindings.showCancel && showCancel !== void 0)
        $$bindings.showCancel(showCancel);
      if ($$props.onCancel === void 0 && $$bindings.onCancel && onCancel !== void 0)
        $$bindings.onCancel(onCancel);
      return `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"><input type="text" name="name" placeholder="Asset name (e.g., HVAC Unit #1)" title="Enter a descriptive name for this asset" class="px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange" required${add_attribute("value", name, 0)}> <select name="unitId" title="Select the unit where this asset is located" class="px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange" required><option value="" data-svelte-h="svelte-1v0ye9v">Select a unit...</option>${each(units, (unit) => {
        return `<option${add_attribute("value", unit.id, 0)}>${escape(getUnitLabel(unit))}</option>`;
      })}</select> <select name="type" title="Choose the asset type/category" class="px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange">${each(ASSET_TYPES, (typeOption) => {
        return `<option${add_attribute("value", typeOption, 0)}>${escape(typeOption.replace("_", " "))}</option>`;
      })}</select> <select name="status" title="Set the current operational status of this asset" class="px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange">${each(ASSET_STATUSES, (statusOption) => {
        return `<option${add_attribute("value", statusOption, 0)}>${escape(statusOption.replace("_", " "))}</option>`;
      })}</select> <input type="date" name="purchaseDate" title="Enter the date this asset was purchased" class="px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", purchaseDate, 0)}> <input type="date" name="warrantyExpiry" title="Enter the warranty expiration date" class="px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", warrantyExpiry, 0)}> <textarea name="description" placeholder="Description (optional)" title="Add additional details about this asset" rows="3" class="px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange md:col-span-2">${escape(description || "")}</textarea> <div class="flex gap-2 md:col-span-3"><button type="submit" ${isSubmitting || !name.trim() || !unitId ? "disabled" : ""} title="Save this asset" class="bg-spore-forest text-white px-6 py-3 rounded-lg font-bold text-sm tracking-wide hover:bg-spore-forest/90 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">${escape(isSubmitting ? "SAVING..." : submitLabel)}</button> ${showCancel && onCancel ? `<button type="button" title="Cancel and return to view mode" class="px-6 py-3 rounded-lg font-bold text-sm text-spore-steel hover:bg-spore-cream transition-colors" data-svelte-h="svelte-ez49ph">CANCEL</button>` : ``}</div></div>`;
    });
    Page2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let assets2;
      let units;
      let sites;
      let { data } = $$props;
      let isSubmitting = false;
      let showFilters = false;
      let editingAssetId = null;
      let editingAsset = {
        name: "",
        unitId: "",
        type: "OTHER",
        status: "OPERATIONAL",
        description: "",
        purchaseDate: "",
        warrantyExpiry: ""
      };
      let filterType = data.type || "";
      let filterStatus = data.status || "";
      let filterSite = data.siteId || "";
      let sortOption = data.sort || "created";
      let searchValue = data.search || "";
      function applyFilters() {
        const params = new URLSearchParams();
        if (filterType)
          params.set("type", filterType);
        if (filterStatus)
          params.set("status", filterStatus);
        if (filterSite)
          params.set("siteId", filterSite);
        if (sortOption && sortOption !== "created")
          params.set("sort", sortOption);
        if (searchValue)
          params.set("search", searchValue);
        goto(`?${params.toString()}`, { keepFocus: true });
      }
      function clearFilters() {
        filterType = "";
        filterStatus = "";
        filterSite = "";
        sortOption = "created";
        searchValue = "";
        applyFilters();
      }
      function cancelEdit() {
        editingAssetId = null;
        editingAsset = {
          name: "",
          unitId: "",
          type: "OTHER",
          status: "OPERATIONAL",
          description: "",
          purchaseDate: "",
          warrantyExpiry: ""
        };
      }
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        assets2 = data.assets || [];
        units = data.units || [];
        sites = data.sites || [];
        $$rendered = `${$$result.head += `<!-- HEAD_svelte-5egb08_START -->${$$result.title = `<title>Assets \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-5egb08_END -->`, ""} <div class="max-w-7xl mx-auto px-4 py-10"> <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 mb-10"><div><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-b9dnm5">Assets</h1> <p class="text-spore-cream/60 mt-2 text-sm font-medium">${escape(assets2.length)} total asset${escape(assets2.length !== 1 ? "s" : "")}</p></div> <button${add_attribute(
          "title",
          "Create a new asset",
          0
        )} class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold tracking-wide">${escape("+ NEW ASSET")}</button></div>  ${validate_component(FilterBar, "FilterBar").$$render(
          $$result,
          {
            searchPlaceholder: "Search assets...",
            searchTitle: "Search by name or description",
            onSearch: (v) => {
              searchValue = v;
              applyFilters();
            },
            toggleButtons: [],
            filters: [
              {
                value: filterType,
                placeholder: "All Types",
                title: "Filter by asset type",
                onChange: (v) => {
                  filterType = v;
                  applyFilters();
                },
                options: ASSET_TYPES.map((t2) => ({ value: t2, label: t2.replace("_", " ") }))
              },
              {
                value: filterStatus,
                placeholder: "All Statuses",
                title: "Filter by status",
                onChange: (v) => {
                  filterStatus = v;
                  applyFilters();
                },
                options: ASSET_STATUSES.map((s3) => ({ value: s3, label: s3.replace("_", " ") }))
              },
              {
                value: filterSite,
                placeholder: "All Sites",
                title: "Filter by site",
                onChange: (v) => {
                  filterSite = v;
                  applyFilters();
                },
                show: sites.length > 0,
                options: sites.map((s3) => ({ value: s3.id, label: s3.name }))
              }
            ],
            sortOptions: [
              { value: "created", label: "Newest" },
              { value: "name", label: "Name" },
              { value: "type", label: "Type" },
              { value: "status", label: "Status" }
            ],
            onSortChange: (v) => {
              sortOption = v;
              applyFilters();
            },
            onClear: clearFilters,
            clearLabel: "Reset",
            showFilters,
            searchValue,
            sortValue: sortOption
          },
          {
            showFilters: ($$value) => {
              showFilters = $$value;
              $$settled = false;
            },
            searchValue: ($$value) => {
              searchValue = $$value;
              $$settled = false;
            },
            sortValue: ($$value) => {
              sortOption = $$value;
              $$settled = false;
            }
          },
          {}
        )}  ${``}  ${assets2.length > 0 ? `<div class="bg-spore-white rounded-xl overflow-hidden"><div class="overflow-x-auto"><table class="min-w-full"><thead class="bg-spore-dark"><tr><th class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-eph96p">Asset</th> <th class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1skifmx">Type</th> <th class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1wy5e1r">Status</th> <th class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider hidden md:table-cell" data-svelte-h="svelte-2ejboa">Location</th> <th class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider text-center" data-svelte-h="svelte-1creitc">WO</th> <th class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider hidden lg:table-cell" data-svelte-h="svelte-4skpp3">Created</th> <th class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-vmrd6s">Actions</th></tr></thead> <tbody class="divide-y divide-spore-cream/50">${each(assets2, (asset) => {
          return `${editingAssetId === asset.id ? ` <tr class="bg-spore-orange/10"><td class="p-2" colspan="7"><form method="POST" action="?/update"><input type="hidden" name="assetId"${add_attribute("value", asset.id, 0)}> ${validate_component(AssetForm, "AssetForm").$$render(
            $$result,
            {
              units,
              submitLabel: "SAVE",
              isSubmitting,
              showCancel: true,
              onCancel: cancelEdit,
              name: editingAsset.name,
              unitId: editingAsset.unitId,
              type: editingAsset.type,
              status: editingAsset.status,
              description: editingAsset.description,
              purchaseDate: editingAsset.purchaseDate,
              warrantyExpiry: editingAsset.warrantyExpiry
            },
            {
              name: ($$value) => {
                editingAsset.name = $$value;
                $$settled = false;
              },
              unitId: ($$value) => {
                editingAsset.unitId = $$value;
                $$settled = false;
              },
              type: ($$value) => {
                editingAsset.type = $$value;
                $$settled = false;
              },
              status: ($$value) => {
                editingAsset.status = $$value;
                $$settled = false;
              },
              description: ($$value) => {
                editingAsset.description = $$value;
                $$settled = false;
              },
              purchaseDate: ($$value) => {
                editingAsset.purchaseDate = $$value;
                $$settled = false;
              },
              warrantyExpiry: ($$value) => {
                editingAsset.warrantyExpiry = $$value;
                $$settled = false;
              }
            },
            {}
          )} </form></td> </tr>` : ` <tr class="hover:bg-spore-cream/20 transition-colors group"><td class="px-4 py-3"><a href="${"/assets/" + escape(asset.id, true)}" class="text-sm font-bold text-spore-dark hover:text-spore-orange transition-colors block" title="View asset details">${escape(asset.name)} ${asset.description ? `<span class="text-xs text-spore-steel/70 font-normal block">${escape(asset.description.slice(0, 50))}${escape(asset.description.length > 50 ? "..." : "")}</span>` : ``} </a></td> <td class="px-4 py-3"><span class="px-2 py-1 text-xs font-semibold rounded-full bg-spore-cream/20 text-spore-steel" title="${"Asset type: " + escape(formatAssetStatus(asset.type || "OTHER"), true)}">${escape(formatAssetStatus(asset.type || "OTHER"))} </span></td> <td class="px-4 py-3">${validate_component(AssetStatusBadge, "AssetStatusBadge").$$render($$result, { status: asset.status, size: "sm" }, {}, {})}</td> <td class="px-4 py-3 hidden md:table-cell"><div class="text-sm text-spore-steel" title="${"Location: " + escape(asset.Unit?.Site?.name || "Unknown", true) + " - Unit " + escape(asset.Unit?.roomNumber || "N/A", true)}"><span class="font-medium">${escape(asset.Unit?.Site?.name || "Unknown")}</span> <br> <span class="text-xs">Unit ${escape(asset.Unit?.roomNumber || "N/A")} ${escape(asset.Unit?.name ? ` - ${asset.Unit.name}` : "")} ${escape(asset.Unit?.Building ? ` \u2022 Bldg ${asset.Unit.Building.name}` : "")} ${escape(asset.Unit?.floor ? ` \u2022 Floor ${asset.Unit.floor}` : "")}</span> </div></td> <td class="px-4 py-3 text-center">${asset._count?.WorkOrder > 0 ? `<span class="px-2 py-1 text-xs font-bold rounded-full bg-spore-orange/10 text-spore-orange" title="${escape(asset._count.WorkOrder, true) + " work order" + escape(asset._count.WorkOrder > 1 ? "s" : "", true) + " associated"}">${escape(asset._count.WorkOrder)} </span>` : `<span class="text-xs text-spore-steel/50" title="No work orders" data-svelte-h="svelte-taiusr">0</span>`}</td> <td class="px-4 py-3 text-sm text-spore-steel hidden lg:table-cell"><span title="${"Created on " + escape(new Date(asset.createdAt).toLocaleDateString(), true)}">${escape(new Date(asset.createdAt).toLocaleDateString())}</span></td> <td class="px-4 py-3 whitespace-nowrap text-xs font-medium space-x-2"><a href="${"/assets/" + escape(asset.id, true)}" class="text-spore-forest hover:text-spore-forest/70 transition-colors" title="View full details">View</a> <button class="text-spore-orange hover:text-spore-orange/70 transition-colors" title="Edit this asset" data-svelte-h="svelte-1utif9h">Edit</button> <form method="POST" action="?/delete" class="inline"><input type="hidden" name="assetId"${add_attribute("value", asset.id, 0)}> <button type="submit" class="text-red-500 hover:text-red-400 transition-colors" title="Delete this asset" data-svelte-h="svelte-70kg7d">Delete</button> </form></td> </tr>`}`;
        })}</tbody></table></div></div>` : `<div class="text-center py-16 bg-spore-white rounded-xl"><div class="text-5xl mb-4" data-svelte-h="svelte-1mat6ie">\u2699\uFE0F</div> <h3 class="text-xl font-bold text-spore-dark mb-2" data-svelte-h="svelte-vaoz6w">No assets found</h3> <p class="text-spore-steel mb-6" data-svelte-h="svelte-ba34d9">Try adjusting your filters or create your first asset to start tracking equipment</p> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold" title="Create your first asset" data-svelte-h="svelte-muj3ii">+ CREATE ASSET</button></div>`}</div>`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
  component: () => component4,
  fonts: () => fonts4,
  imports: () => imports4,
  index: () => index4,
  server: () => page_server_ts_exports2,
  server_id: () => server_id3,
  stylesheets: () => stylesheets4
});
var index4, component_cache4, component4, server_id3, imports4, stylesheets4, fonts4;
var init__4 = __esm({
  ".svelte-kit/output/server/nodes/3.js"() {
    init_page_server_ts2();
    index4 = 3;
    component4 = async () => component_cache4 ??= (await Promise.resolve().then(() => (init_page_svelte2(), page_svelte_exports2))).default;
    server_id3 = "src/routes/assets/+page.server.ts";
    imports4 = ["_app/immutable/nodes/3.83dbcc01.js", "_app/immutable/chunks/_page.7b2b618b.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/constants.cc7bddc0.js", "_app/immutable/chunks/AssetForm.f3459561.js", "_app/immutable/chunks/FilterBar.0110061d.js"];
    stylesheets4 = [];
    fonts4 = [];
  }
});

// .svelte-kit/output/server/entries/pages/assets/_id_/_page.server.ts.js
var page_server_ts_exports3 = {};
__export(page_server_ts_exports3, {
  actions: () => actions3,
  load: () => load3
});
var load3, actions3;
var init_page_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/pages/assets/_id_/_page.server.ts.js"() {
    init_prisma();
    init_chunks();
    init_guards();
    init_validation();
    load3 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const { id } = event.params;
      const organizationId = event.locals.user.organizationId;
      const asset = await prisma.asset.findFirst({
        where: {
          id,
          Unit: {
            Site: {
              organizationId: organizationId ?? void 0
            }
          }
        },
        include: {
          Unit: {
            include: {
              Site: { select: { id: true, name: true } },
              Building: { select: { id: true, name: true } }
            }
          },
          WorkOrder: {
            orderBy: { createdAt: "desc" },
            take: 20,
            select: {
              id: true,
              title: true,
              status: true,
              createdAt: true,
              updatedAt: true
            }
          },
          _count: {
            select: { WorkOrder: true }
          }
        }
      });
      if (!asset) {
        throw error(404, "Asset not found");
      }
      const units = await prisma.unit.findMany({
        where: {
          Site: {
            organizationId: organizationId ?? void 0
          }
        },
        orderBy: [
          { Site: { name: "asc" } },
          { Building: { name: "asc" } },
          { roomNumber: "asc" }
        ],
        include: {
          Site: { select: { name: true } },
          Building: { select: { name: true } }
        }
      });
      const woStatsByStatus = await prisma.workOrder.groupBy({
        by: ["status"],
        where: { assetId: id },
        _count: { status: true }
      });
      const statsMap = Object.fromEntries(
        woStatsByStatus.map((s3) => [s3.status, s3._count.status])
      );
      const woStats = {
        total: asset._count.WorkOrder,
        pending: statsMap["PENDING"] || 0,
        inProgress: statsMap["IN_PROGRESS"] || 0,
        completed: statsMap["COMPLETED"] || 0
      };
      return {
        asset,
        units,
        woStats
      };
    };
    actions3 = {
      update: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id } = event.params;
        const organizationId = event.locals.user.organizationId;
        const rawData = {
          name: formData.get("name"),
          unitId: formData.get("unitId"),
          type: formData.get("type"),
          status: formData.get("status"),
          description: formData.get("description"),
          purchaseDate: formData.get("purchaseDate"),
          warrantyExpiry: formData.get("warrantyExpiry")
        };
        const validationResult = assetSchema.safeParse(rawData);
        if (!validationResult.success) {
          const firstError = validationResult.error.issues[0];
          return fail(400, { error: firstError.message });
        }
        const data = validationResult.data;
        const existingAsset = await prisma.asset.findFirst({
          where: {
            id,
            Unit: {
              Site: {
                organizationId: organizationId ?? void 0
              }
            }
          }
        });
        if (!existingAsset) {
          return fail(404, { error: "Asset not found" });
        }
        const unit = await prisma.unit.findFirst({
          where: {
            id: data.unitId,
            Site: {
              organizationId: organizationId ?? void 0
            }
          }
        });
        if (!unit) {
          return fail(404, { error: "Unit not found" });
        }
        const asset = await prisma.asset.update({
          where: { id },
          data: {
            name: data.name.trim(),
            type: data.type ? data.type : void 0,
            status: data.status ? data.status : void 0,
            description: data.description ? data.description.trim() : void 0,
            purchaseDate: data.purchaseDate ? new Date(data.purchaseDate) : null,
            warrantyExpiry: data.warrantyExpiry ? new Date(data.warrantyExpiry) : null,
            unitId: data.unitId,
            siteId: unit.siteId
          }
        });
        return { success: true, asset };
      },
      delete: async (event) => {
        if (!isManagerOrAbove(event)) {
          return fail(403, { error: "Permission denied. Only managers can delete assets." });
        }
        const prisma = await createRequestPrisma(event);
        const { id } = event.params;
        const organizationId = event.locals.user.organizationId;
        const asset = await prisma.asset.findFirst({
          where: {
            id,
            Unit: {
              Site: {
                organizationId: organizationId ?? void 0
              }
            }
          }
        });
        if (!asset) {
          return fail(404, { error: "Asset not found" });
        }
        await prisma.asset.delete({
          where: { id }
        });
        throw redirect(303, "/assets");
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/assets/_id_/_page.svelte.js
var page_svelte_exports3 = {};
__export(page_svelte_exports3, {
  default: () => Page3
});
function getStatusColor2(status) {
  switch (status) {
    case "COMPLETED":
      return "bg-spore-forest text-white";
    case "IN_PROGRESS":
      return "bg-spore-orange text-white";
    case "PENDING":
      return "bg-spore-steel text-white";
    case "ON_HOLD":
      return "bg-spore-cream text-spore-steel";
    case "CANCELLED":
      return "bg-red-600 text-white";
    default:
      return "bg-spore-steel text-white";
  }
}
var Page3;
var init_page_svelte3 = __esm({
  ".svelte-kit/output/server/entries/pages/assets/_id_/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    init_constants2();
    init_AssetStatusBadge();
    Page3 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let asset;
      let woStats;
      let { data } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        asset = data.asset;
        data.units || [];
        woStats = data.woStats;
        $$rendered = `<div class="max-w-4xl mx-auto px-4 py-10">${` <div class="bg-spore-white rounded-xl overflow-hidden"> <div class="bg-spore-dark p-6"><div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4"><div><h1 class="text-2xl font-extrabold text-spore-cream">${escape(asset.name)}</h1> <p class="text-spore-cream/60 mt-1 text-sm">${escape(asset.Unit?.Site?.name)} \u2022 Unit ${escape(asset.Unit?.roomNumber || asset.Unit?.name || "N/A")} ${asset.Unit?.Building ? `\u2022 Bldg ${escape(asset.Unit.Building.name)}` : ``} ${asset.Unit?.floor ? `\u2022 Floor ${escape(asset.Unit.floor)}` : ``}</p></div> <div class="flex gap-2"><button class="bg-spore-forest text-white px-4 py-2 rounded-lg font-bold text-sm hover:bg-spore-forest/90 transition-colors" title="Edit asset details" data-svelte-h="svelte-5dr1pk">EDIT</button> <form method="POST" action="?/delete"><button type="submit" class="px-4 py-2 rounded-lg font-bold text-sm text-red-400 border border-red-400/30 hover:bg-red-400/10 transition-colors" title="Delete this asset" data-svelte-h="svelte-4gr9cf">DELETE</button></form></div></div></div>  <div class="grid grid-cols-2 sm:grid-cols-4 border-b border-spore-cream"><div class="p-4 border-r border-spore-cream"><p class="text-xs font-bold text-spore-steel uppercase mb-1" data-svelte-h="svelte-1eht0mz">Type</p> <p class="text-sm font-medium text-spore-dark">${escape(formatAssetStatus(asset.type || "OTHER"))}</p></div> <div class="p-4 border-r border-spore-cream"><p class="text-xs font-bold text-spore-steel uppercase mb-1" data-svelte-h="svelte-5ns9e1">Status</p> ${validate_component(AssetStatusBadge, "AssetStatusBadge").$$render($$result, { status: asset.status, size: "sm" }, {}, {})}</div> <div class="p-4 border-r border-spore-cream"><p class="text-xs font-bold text-spore-steel uppercase mb-1" data-svelte-h="svelte-sdqaom">Purchase Date</p> <p class="text-sm font-medium text-spore-dark">${escape(asset.purchaseDate ? new Date(asset.purchaseDate).toLocaleDateString() : "N/A")}</p></div> <div class="p-4"><p class="text-xs font-bold text-spore-steel uppercase mb-1" data-svelte-h="svelte-1d90ozn">Warranty</p> <p class="text-sm font-medium text-spore-dark">${escape(asset.warrantyExpiry ? new Date(asset.warrantyExpiry).toLocaleDateString() : "N/A")}</p></div></div> ${asset.description ? `<div class="p-4 border-b border-spore-cream bg-spore-cream/10"><p class="text-xs font-bold text-spore-steel uppercase mb-1" data-svelte-h="svelte-16yaad1">Description</p> <p class="text-sm text-spore-dark">${escape(asset.description)}</p></div>` : ``}  <div class="grid grid-cols-2 sm:grid-cols-4 border-b border-spore-cream"><div class="p-4 text-center border-r border-spore-cream"><p class="text-2xl font-extrabold text-spore-dark">${escape(woStats.total)}</p> <p class="text-xs font-bold text-spore-steel uppercase" data-svelte-h="svelte-14h9nd3">Total WOs</p></div> <div class="p-4 text-center border-r border-spore-cream"><p class="text-2xl font-extrabold text-spore-steel">${escape(woStats.pending)}</p> <p class="text-xs font-bold text-spore-steel uppercase" data-svelte-h="svelte-vg7ifd">Pending</p></div> <div class="p-4 text-center border-r border-spore-cream"><p class="text-2xl font-extrabold text-spore-orange">${escape(woStats.inProgress)}</p> <p class="text-xs font-bold text-spore-steel uppercase" data-svelte-h="svelte-bf56gq">In Progress</p></div> <div class="p-4 text-center"><p class="text-2xl font-extrabold text-spore-forest">${escape(woStats.completed)}</p> <p class="text-xs font-bold text-spore-steel uppercase" data-svelte-h="svelte-300hz3">Completed</p></div></div>  <div class="p-6"><div class="flex justify-between items-center mb-4"><h2 class="text-lg font-bold text-spore-dark" data-svelte-h="svelte-1ez9epy">Work Order History</h2> <a href="${"/work-orders?asset=" + escape(asset.id, true)}" class="text-sm font-bold text-spore-orange hover:text-spore-orange/80" title="View all work orders for this asset">View All \u2192</a></div> ${asset.WorkOrder && asset.WorkOrder.length > 0 ? `<div class="space-y-3">${each(asset.WorkOrder, (wo) => {
          return `<a href="${"/work-orders/" + escape(wo.id, true)}" class="flex items-center justify-between p-4 bg-spore-cream/20 rounded-lg hover:bg-spore-cream/40 transition-colors border border-spore-cream/50" title="${"View work order: " + escape(wo.title, true)}"><div class="flex-1 min-w-0"><p class="font-bold text-spore-dark truncate">${escape(wo.title)}</p> <p class="text-xs text-spore-steel mt-1">Created ${escape(new Date(wo.createdAt).toLocaleDateString())} </p></div> <span class="${"ml-4 px-3 py-1 text-xs font-bold uppercase tracking-wide rounded-full " + escape(getStatusColor2(wo.status), true)}" title="${"Status: " + escape(wo.status.replace("_", " "), true)}">${escape(wo.status.replace("_", " "))}</span> </a>`;
        })}</div>` : `<div class="text-center py-8 bg-spore-cream/20 rounded-lg"><p class="text-spore-steel" data-svelte-h="svelte-17d3vfe">No work orders for this asset</p> <a href="/work-orders" class="inline-block mt-4 bg-spore-orange text-white px-6 py-2 rounded-lg font-bold text-sm hover:bg-spore-orange/90 transition-colors" title="Create a new work order" data-svelte-h="svelte-1fwtl72">Create Work Order</a></div>`}</div></div>`}</div>`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});

// .svelte-kit/output/server/nodes/4.js
var __exports5 = {};
__export(__exports5, {
  component: () => component5,
  fonts: () => fonts5,
  imports: () => imports5,
  index: () => index5,
  server: () => page_server_ts_exports3,
  server_id: () => server_id4,
  stylesheets: () => stylesheets5
});
var index5, component_cache5, component5, server_id4, imports5, stylesheets5, fonts5;
var init__5 = __esm({
  ".svelte-kit/output/server/nodes/4.js"() {
    init_page_server_ts3();
    index5 = 4;
    component5 = async () => component_cache5 ??= (await Promise.resolve().then(() => (init_page_svelte3(), page_svelte_exports3))).default;
    server_id4 = "src/routes/assets/[id]/+page.server.ts";
    imports5 = ["_app/immutable/nodes/4.ce1012ee.js", "_app/immutable/chunks/_page.a02fb855.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/constants.cc7bddc0.js", "_app/immutable/chunks/AssetForm.f3459561.js"];
    stylesheets5 = [];
    fonts5 = [];
  }
});

// .svelte-kit/output/server/entries/pages/audit-log/_page.server.ts.js
var page_server_ts_exports4 = {};
__export(page_server_ts_exports4, {
  load: () => load4
});
var load4;
var init_page_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/pages/audit-log/_page.server.ts.js"() {
    init_prisma();
    init_chunks();
    init_guards();
    load4 = async (event) => {
      initEnvFromEvent(event);
      if (!isAdmin(event)) {
        throw error(403, "Access denied. Admin privileges required.");
      }
      const organizationId = event.locals.user.organizationId;
      const page2 = parseInt(event.url.searchParams.get("page") || "1");
      const limit = 50;
      const skip2 = (page2 - 1) * limit;
      const client = await getPrisma();
      const userIdsInOrg = await client.user.findMany({
        where: { organizationId: organizationId ?? void 0 },
        select: { id: true }
      }).then((users) => users.map((u) => u.id));
      const auditLogs = await client.auditLog.findMany({
        where: {
          userId: { in: userIdsInOrg }
        },
        orderBy: { createdAt: "desc" },
        skip: skip2,
        take: limit,
        include: {
          User: {
            select: {
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      });
      const totalCount = await client.auditLog.count({
        where: {
          userId: { in: userIdsInOrg }
        }
      });
      const totalPages = Math.ceil(totalCount / limit);
      return {
        auditLogs,
        page: page2,
        totalPages,
        totalCount
      };
    };
  }
});

// .svelte-kit/output/server/entries/pages/audit-log/_page.svelte.js
var page_svelte_exports4 = {};
__export(page_svelte_exports4, {
  default: () => Page4
});
function getUserName(user) {
  if (user.firstName || user.lastName) {
    return [user.firstName, user.lastName].filter(Boolean).join(" ");
  }
  return user.email;
}
function formatAction(action) {
  return action.replace(/_/g, " ").toLowerCase().replace(/^\w/, (c2) => c2.toUpperCase());
}
function getActionColor(action) {
  if (action.includes("DELETED"))
    return "text-red-500";
  if (action.includes("CREATED"))
    return "text-spore-forest";
  if (action.includes("CHANGED") || action.includes("ASSIGNED"))
    return "text-spore-orange";
  return "text-spore-steel";
}
function formatDetails(details) {
  if (!details)
    return "";
  if (typeof details === "object") {
    return Object.entries(details).filter(([_, v]) => v != null).map(([k, v]) => `${k}: ${v}`).join(", ");
  }
  return String(details);
}
var Page4;
var init_page_svelte4 = __esm({
  ".svelte-kit/output/server/entries/pages/audit-log/_page.svelte.js"() {
    init_ssr();
    Page4 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let auditLogs;
      let page2;
      let totalPages;
      let { data } = $$props;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      auditLogs = data.auditLogs || [];
      page2 = data.page;
      totalPages = data.totalPages;
      return `${$$result.head += `<!-- HEAD_svelte-111n33w_START -->${$$result.title = `<title>Audit Log \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-111n33w_END -->`, ""} <div class="max-w-7xl mx-auto px-4 py-10"><div class="mb-8"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-1fam30h">Audit Log</h1> <p class="text-spore-cream/60 mt-2" data-svelte-h="svelte-16iiojr">Track all changes made in your organization</p></div> ${auditLogs.length > 0 ? `<div class="bg-spore-white rounded-xl overflow-hidden"><div class="overflow-x-auto"><table class="min-w-full"><thead class="bg-spore-dark"><tr><th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1m6unqy">When</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-10vh90y">Who</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1tih4uw">Action</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1enb6fs">Details</th></tr></thead> <tbody class="divide-y divide-spore-cream/50">${each(auditLogs, (log2) => {
        return `<tr class="hover:bg-spore-cream/20 transition-colors"><td class="px-6 py-4 whitespace-nowrap text-sm text-spore-steel"><time${add_attribute("datetime", log2.createdAt.toString(), 0)}>${escape(new Date(log2.createdAt).toLocaleString())} </time></td> <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-spore-dark">${escape(getUserName(log2.User))}</td> <td class="px-6 py-4 whitespace-nowrap"><span class="${"text-sm font-bold " + escape(getActionColor(log2.action), true)}">${escape(formatAction(log2.action))} </span></td> <td class="px-6 py-4 text-sm text-spore-steel max-w-md truncate"${add_attribute("title", formatDetails(log2.details), 0)}>${escape(formatDetails(log2.details))}</td> </tr>`;
      })}</tbody></table></div></div>  ${totalPages > 1 ? `<div class="flex justify-center gap-2 mt-6">${page2 > 1 ? `<a href="${"/audit-log?page=" + escape(page2 - 1, true)}" class="px-4 py-2 bg-spore-white text-spore-steel rounded-lg hover:bg-spore-cream transition-colors text-sm font-bold">\u2190 Previous</a>` : ``} <span class="px-4 py-2 text-spore-cream/60 text-sm">Page ${escape(page2)} of ${escape(totalPages)}</span> ${page2 < totalPages ? `<a href="${"/audit-log?page=" + escape(page2 + 1, true)}" class="px-4 py-2 bg-spore-white text-spore-steel rounded-lg hover:bg-spore-cream transition-colors text-sm font-bold">Next \u2192</a>` : ``}</div>` : ``}` : `<div class="text-center py-16 bg-spore-white rounded-xl"><div class="text-5xl mb-4" data-svelte-h="svelte-7jlewd">\u{1F4DC}</div> <h3 class="text-xl font-bold text-spore-dark mb-2" data-svelte-h="svelte-z8atj6">No activity yet</h3> <p class="text-spore-steel" data-svelte-h="svelte-wb5xqh">Actions will be recorded here as users make changes</p></div>`}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/5.js
var __exports6 = {};
__export(__exports6, {
  component: () => component6,
  fonts: () => fonts6,
  imports: () => imports6,
  index: () => index6,
  server: () => page_server_ts_exports4,
  server_id: () => server_id5,
  stylesheets: () => stylesheets6
});
var index6, component_cache6, component6, server_id5, imports6, stylesheets6, fonts6;
var init__6 = __esm({
  ".svelte-kit/output/server/nodes/5.js"() {
    init_page_server_ts4();
    index6 = 5;
    component6 = async () => component_cache6 ??= (await Promise.resolve().then(() => (init_page_svelte4(), page_svelte_exports4))).default;
    server_id5 = "src/routes/audit-log/+page.server.ts";
    imports6 = ["_app/immutable/chunks/5.42a8da84.js", "_app/immutable/chunks/_page.8d06d9c2.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/globals.7f7f1b26.js", "_app/immutable/chunks/index.db98bb86.js"];
    stylesheets6 = [];
    fonts6 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/emergency-reset/_page.server.ts.js
var page_server_ts_exports5 = {};
__export(page_server_ts_exports5, {
  actions: () => actions4,
  load: () => load5
});
var load5, actions4;
var init_page_server_ts5 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/emergency-reset/_page.server.ts.js"() {
    init_chunks();
    init_auth();
    init_prisma();
    init_zod();
    load5 = async () => {
      return {};
    };
    actions4 = {
      default: async ({ request, getClientAddress }) => {
        getClientAddress();
        try {
          const formData = await request.formData();
          const email3 = formData.get("email");
          const passphrase = formData.get("passphrase");
          const requestSchema = external_exports.object({
            email: external_exports.string().email("Please enter a valid email address"),
            passphrase: external_exports.string().min(1, "Passphrase is required")
          });
          const validationResult = requestSchema.safeParse({
            email: email3,
            passphrase
          });
          if (!validationResult.success) {
            return fail(400, {
              errors: validationResult.error.issues.reduce((acc, issue2) => {
                const key2 = issue2.path[0];
                acc[key2] = issue2.message;
                return acc;
              }, {})
            });
          }
          const prisma = await getPrisma();
          const user = await prisma.user.findUnique({
            where: { email: email3 },
            select: {
              id: true,
              email: true,
              recoveryPassphrase: true
            }
          });
          if (!user || !user.recoveryPassphrase) {
            return {
              success: false,
              message: "If the email exists and has a recovery passphrase, a reset link has been sent."
            };
          }
          const isValidPassphrase = await verifyPassword(passphrase, user.recoveryPassphrase);
          if (!isValidPassphrase) {
            return {
              success: false,
              message: "If the email exists and has a recovery passphrase, a reset link has been sent."
            };
          }
          const resetToken = crypto.randomUUID();
          const expiresAt = new Date(Date.now() + 60 * 60 * 1e3);
          await prisma.user.update({
            where: { id: user.id },
            data: {
              passwordResetToken: resetToken,
              passwordResetExpiresAt: expiresAt
            }
          });
          const resetUrl = `/auth/reset-password/${resetToken}`;
          return {
            success: true,
            resetToken,
            resetUrl,
            message: "Password reset token generated successfully"
          };
        } catch (error47) {
          console.error("Emergency password reset error:", error47);
          return fail(500, {
            error: "An internal error occurred. Please try again later."
          });
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/emergency-reset/_page.svelte.js
var page_svelte_exports5 = {};
__export(page_svelte_exports5, {
  default: () => Page5
});
var Page5;
var init_page_svelte5 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/emergency-reset/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page5 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let form = { email: "", passphrase: "" };
      let errors = {};
      return `${$$result.head += `<!-- HEAD_svelte-1hgi8ho_START -->${$$result.title = `<title>Emergency Password Reset | Spore CMMS</title>`, ""}<!-- HEAD_svelte-1hgi8ho_END -->`, ""} <div class="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8"><div class="max-w-md w-full space-y-8"><div><div class="mx-auto h-12 w-12 flex items-center justify-center rounded-full bg-spore-orange"><svg class="h-8 w-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"></path></svg></div> <h2 class="mt-6 text-center text-3xl font-extrabold text-gray-900" data-svelte-h="svelte-1mvnnob">Emergency Password Reset</h2> <p class="mt-2 text-center text-sm text-gray-600" data-svelte-h="svelte-15tb0qq">Use your recovery passphrase to reset your password</p></div> <form method="POST" class="mt-8 space-y-6"><div class="space-y-4"><div><label for="email" class="block text-sm font-medium text-gray-700" data-svelte-h="svelte-10usu5b">Email Address</label> <input id="email" name="email" type="email" autocomplete="email" required class="${"mt-1 appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-spore-orange focus:border-spore-orange sm:text-sm " + escape(errors.email ? "border-red-500" : "", true)}" placeholder="Enter your email"${add_attribute("value", form.email, 0)}> ${errors.email ? `<p class="mt-1 text-sm text-red-600">${escape(errors.email)}</p>` : ``}</div> <div><label for="passphrase" class="block text-sm font-medium text-gray-700" data-svelte-h="svelte-nh8t6s">Recovery Passphrase</label> <div class="mt-1 relative">${`<input id="passphrase" name="passphrase" type="password" required class="${"appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-spore-orange focus:border-spore-orange sm:text-sm " + escape(errors.passphrase ? "border-red-500" : "", true)}" placeholder="Enter your recovery passphrase"${add_attribute("value", form.passphrase, 0)}>`} <button type="button" class="absolute inset-y-0 right-0 pr-3 flex items-center">${`<svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`}</button></div> ${errors.passphrase ? `<p class="mt-1 text-sm text-red-600">${escape(errors.passphrase)}</p>` : ``}</div></div> ${errors.general ? `<div class="rounded-md bg-red-50 p-4"><div class="flex"><div class="flex-shrink-0"><svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg></div> <div class="ml-3"><p class="text-sm font-medium text-red-800">${escape(errors.general)}</p></div></div></div>` : ``} ${``} <div><button type="submit" ${""} class="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-spore-orange hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-spore-orange disabled:opacity-50 disabled:cursor-not-allowed transition-colors">${`Request Password Reset`}</button></div></form> <div class="mt-6"><div class="relative"><div class="absolute inset-0 flex items-center"><div class="w-full border-t border-gray-300"></div></div> <div class="relative flex justify-center text-sm"><span class="px-2 bg-gray-50 text-gray-500" data-svelte-h="svelte-1ld5my3">or</span></div></div> <div class="mt-6 text-center"><a href="/auth/login" class="font-medium text-spore-orange hover:text-spore-orange/90 transition-colors" data-svelte-h="svelte-1b7g68d">Back to login</a></div></div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/6.js
var __exports7 = {};
__export(__exports7, {
  component: () => component7,
  fonts: () => fonts7,
  imports: () => imports7,
  index: () => index7,
  server: () => page_server_ts_exports5,
  server_id: () => server_id6,
  stylesheets: () => stylesheets7
});
var index7, component_cache7, component7, server_id6, imports7, stylesheets7, fonts7;
var init__7 = __esm({
  ".svelte-kit/output/server/nodes/6.js"() {
    init_page_server_ts5();
    index7 = 6;
    component7 = async () => component_cache7 ??= (await Promise.resolve().then(() => (init_page_svelte5(), page_svelte_exports5))).default;
    server_id6 = "src/routes/auth/emergency-reset/+page.server.ts";
    imports7 = ["_app/immutable/chunks/6.be3b2a02.js", "_app/immutable/chunks/_page.f8aa9021.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/globals.7f7f1b26.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets7 = [];
    fonts7 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/login/_page.server.ts.js
var page_server_ts_exports6 = {};
__export(page_server_ts_exports6, {
  actions: () => actions5,
  load: () => load6
});
var load6, actions5;
var init_page_server_ts6 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/login/_page.server.ts.js"() {
    init_chunks();
    init_auth();
    init_prisma();
    init_validation();
    init_security();
    load6 = async ({ locals }) => {
      if (locals.user) {
        throw redirect(303, "/dashboard");
      }
      return {};
    };
    actions5 = {
      default: async (event) => {
        const { request, cookies, getClientAddress } = event;
        let formData;
        initEnvFromEvent(event);
        const security = SecurityManager.getInstance();
        const ip = getClientAddress() || "unknown";
        try {
          const blockStatus = await security.isIPBlocked(ip);
          if (blockStatus.blocked) {
            await security.logSecurityEvent({
              ipAddress: ip,
              action: "LOGIN_BLOCKED",
              details: { reason: blockStatus.reason },
              severity: "WARNING"
            });
            return fail(403, { error: "Access denied. Your IP address has been blocked." });
          }
          const rateLimitResult = await security.checkRateLimit(
            { event: { request, getClientAddress: () => ip }, action: "login" },
            SECURITY_RATE_LIMITS.AUTH
          );
          if (!rateLimitResult.success) {
            if (rateLimitResult.blocked) {
              await security.logSecurityEvent({
                ipAddress: ip,
                action: "LOGIN_BLOCKED",
                details: { reason: "Too many login attempts" },
                severity: "WARNING"
              });
              return fail(429, { error: "Too many login attempts. Your IP has been temporarily blocked." });
            }
            return fail(429, { error: "Too many login attempts. Please try again later." });
          }
          formData = await request.formData();
          const validation = validateInput(loginSchema, {
            email: formData.get("email"),
            password: formData.get("password")
          });
          if (!validation.success) {
            const firstError = Object.values(validation.errors)[0];
            return fail(400, { error: firstError, email: formData.get("email") });
          }
          const client = await getPrisma();
          const user = await client.user.findUnique({
            where: { email: validation.data.email }
          });
          console.log(`[Auth Debug] User lookup for ${validation.data.email}:`, user ? "Found" : "Not Found");
          if (!user) {
            await security.logSecurityEvent({
              ipAddress: ip,
              action: "LOGIN_FAILED",
              details: { email: validation.data.email, reason: "User not found" },
              severity: "WARNING"
            });
            return fail(400, { error: "Invalid email or password", email: formData.get("email") });
          }
          const valid = await verifyPassword(validation.data.password, user.password);
          console.log(`[Auth Debug] Password verification for ${validation.data.email}:`, valid ? "Valid" : "Invalid");
          if (!valid) {
            await security.logSecurityEvent({
              ipAddress: ip,
              action: "LOGIN_FAILED",
              details: { email: validation.data.email, userId: user.id, reason: "Invalid password" },
              severity: "WARNING",
              userId: user.id
            });
            return fail(400, { error: "Invalid email or password", email: formData.get("email") });
          }
          const sessionId = await createSession(user.id);
          setSessionCookie(cookies, sessionId);
          await security.logSecurityEvent({
            ipAddress: ip,
            action: "LOGIN_SUCCESS",
            details: { email: user.email },
            severity: "INFO",
            userId: user.id
          });
          throw redirect(303, "/dashboard");
        } catch (error210) {
          if (error210 && typeof error210 === "object" && "location" in error210) {
            throw error210;
          }
          const errorType = error210?.constructor?.name || "Unknown";
          const errorMessage = error210?.message || "No message";
          console.error("[LOGIN ERROR] Type:", errorType);
          console.error("[LOGIN ERROR] Message:", errorMessage);
          console.error("[LOGIN ERROR] Full:", error210);
          const emailValue = formData?.get("email");
          if (errorMessage.includes("DATABASE_URL") || errorMessage.includes("ACCELERATE_URL") || errorMessage.includes("DIRECT_URL") || errorMessage.includes("environment variable")) {
            return fail(500, {
              error: "Database configuration error. Please contact support.",
              email: emailValue
            });
          }
          return fail(500, {
            error: "An unexpected error occurred. Please try again.",
            email: emailValue
          });
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/login/_page.svelte.js
var page_svelte_exports6 = {};
__export(page_svelte_exports6, {
  default: () => Page6
});
var Page6;
var init_page_svelte6 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/login/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page6 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { form } = $$props;
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      return `<div class="min-h-screen bg-spore-dark flex items-center justify-center px-4 py-8"><div class="w-full max-w-md"> <div class="text-center mb-8"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-8kgatc">\u{1F33F} SPORE</h1> <p class="text-spore-cream/60 mt-2 text-lg" data-svelte-h="svelte-n0i25d">CMMS for Technicians</p></div>  <div class="bg-spore-white rounded-2xl p-6 sm:p-8 shadow-2xl"><h2 class="text-2xl font-bold text-spore-dark mb-6" data-svelte-h="svelte-152vket">Welcome Back</h2> ${form?.error ? `<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-4 rounded-xl mb-6 text-base font-medium">${escape(form.error)}</div>` : ``} <form method="POST" class="space-y-5"><div><label for="email" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-dzhc20">Email</label> <input type="email" id="email" name="email"${add_attribute("value", form?.email ?? "", 0)} class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="Enter your email" autocapitalize="none" autocomplete="email" required></div> <div><label for="password" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-t385zo">Password</label> <input type="password" id="password" name="password" class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="Enter your password" autocomplete="current-password" required></div> <button type="submit" ${""} class="w-full bg-spore-forest text-white py-4 rounded-xl font-bold text-lg tracking-wide hover:bg-spore-forest/90 disabled:opacity-50 transition-all transform active:scale-95 touch-manipulation">${`SIGN IN`}</button></form> <div class="mt-6 text-center"><a href="/auth/emergency-reset" class="text-sm text-spore-steel hover:text-spore-orange transition-colors font-medium" data-svelte-h="svelte-9dxn82">Forgot password? Use recovery passphrase</a></div> <div class="mt-8 pt-6 border-t border-spore-cream/20 text-center"><p class="text-base text-spore-steel">Don&#39;t have an account?
					<a href="/auth/register" class="text-spore-orange font-bold hover:text-spore-orange/80 transition-colors" data-svelte-h="svelte-12zzf2e">Create one</a></p></div></div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/7.js
var __exports8 = {};
__export(__exports8, {
  component: () => component8,
  fonts: () => fonts8,
  imports: () => imports8,
  index: () => index8,
  server: () => page_server_ts_exports6,
  server_id: () => server_id7,
  stylesheets: () => stylesheets8
});
var index8, component_cache8, component8, server_id7, imports8, stylesheets8, fonts8;
var init__8 = __esm({
  ".svelte-kit/output/server/nodes/7.js"() {
    init_page_server_ts6();
    index8 = 7;
    component8 = async () => component_cache8 ??= (await Promise.resolve().then(() => (init_page_svelte6(), page_svelte_exports6))).default;
    server_id7 = "src/routes/auth/login/+page.server.ts";
    imports8 = ["_app/immutable/chunks/7.3aca7fcd.js", "_app/immutable/chunks/_page.b2dcc93a.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets8 = [];
    fonts8 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/register/_page.server.ts.js
var page_server_ts_exports7 = {};
__export(page_server_ts_exports7, {
  actions: () => actions6,
  load: () => load7
});
var load7, actions6;
var init_page_server_ts7 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/register/_page.server.ts.js"() {
    init_chunks();
    init_auth();
    init_prisma();
    init_validation();
    init_security();
    load7 = async ({ locals }) => {
      if (locals.user) {
        throw redirect(303, "/dashboard");
      }
      return {};
    };
    actions6 = {
      default: async ({ request, cookies, getClientAddress }) => {
        const security = SecurityManager.getInstance();
        const ip = getClientAddress() || "unknown";
        try {
          const blockStatus = await security.isIPBlocked(ip);
          if (blockStatus.blocked) {
            await security.logSecurityEvent({
              ipAddress: ip,
              action: "REGISTER_BLOCKED",
              details: { reason: blockStatus.reason },
              severity: "WARNING"
            });
            return fail(403, { error: "Access denied. Your IP address has been blocked." });
          }
          const rateLimitResult = await security.checkRateLimit(
            { event: { request, getClientAddress: () => ip }, action: "register" },
            SECURITY_RATE_LIMITS.AUTH
          );
          if (!rateLimitResult.success) {
            if (rateLimitResult.blocked) {
              await security.logSecurityEvent({
                ipAddress: ip,
                action: "REGISTER_BLOCKED",
                details: { reason: "Too many registration attempts" },
                severity: "WARNING"
              });
              return fail(429, { error: "Too many registration attempts. Your IP has been temporarily blocked." });
            }
            return fail(429, { error: "Too many registration attempts. Please try again later." });
          }
          const formData = await request.formData();
          const confirmPassword = formData.get("confirmPassword");
          const validation = validateInput(registerSchema, {
            firstName: formData.get("firstName"),
            lastName: formData.get("lastName"),
            email: formData.get("email"),
            password: formData.get("password")
          });
          if (!validation.success) {
            const firstError = Object.values(validation.errors)[0];
            return fail(400, {
              error: firstError,
              firstName: formData.get("firstName"),
              lastName: formData.get("lastName"),
              email: formData.get("email")
            });
          }
          if (validation.data.password !== confirmPassword) {
            return fail(400, {
              error: "Passwords do not match",
              firstName: formData.get("firstName"),
              lastName: formData.get("lastName"),
              email: formData.get("email")
            });
          }
          const client = await getPrisma();
          const existingUser = await client.user.findUnique({
            where: { email: validation.data.email }
          });
          if (existingUser) {
            return fail(400, {
              error: "An account with this email already exists",
              firstName: formData.get("firstName"),
              lastName: formData.get("lastName"),
              email: formData.get("email")
            });
          }
          const hashedPassword = await hashPassword(validation.data.password);
          const user = await client.user.create({
            data: {
              email: validation.data.email,
              password: hashedPassword,
              firstName: validation.data.firstName,
              lastName: validation.data.lastName,
              role: "TECHNICIAN",
              // Default role, can be changed when joining org
              organizationId: null,
              // Explicitly set to null for lobby state
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
          const sessionId = await createSession(user.id);
          setSessionCookie(cookies, sessionId);
          throw redirect(303, "/onboarding");
        } catch (error210) {
          console.error("[REGISTER] Error:", error210);
          const err = error210 instanceof Error ? error210 : new Error(String(error210));
          console.error("[REGISTER] Stack:", err.stack);
          return fail(500, {
            error: "Internal server error during registration. Please try again.",
            details: err.message
          });
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/register/_page.svelte.js
var page_svelte_exports7 = {};
__export(page_svelte_exports7, {
  default: () => Page7
});
var Page7;
var init_page_svelte7 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/register/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page7 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { form } = $$props;
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      return `<div class="min-h-screen bg-spore-dark flex items-center justify-center px-4 py-8"><div class="w-full max-w-md"> <div class="text-center mb-8"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-8kgatc">\u{1F33F} SPORE</h1> <p class="text-spore-cream/60 mt-2 text-lg" data-svelte-h="svelte-1unzueh">Create your account</p> <p class="text-spore-cream/40 mt-1 text-sm" data-svelte-h="svelte-3dbmy4">Join or create an organization later</p></div>  <div class="bg-spore-white rounded-2xl p-6 sm:p-8 shadow-2xl"><h2 class="text-2xl font-bold text-spore-dark mb-6" data-svelte-h="svelte-1kcjb2h">Get Started</h2> ${form?.error ? `<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-4 rounded-xl mb-6 text-base font-medium">${escape(form.error)}</div>` : ``} <form method="POST" class="space-y-5"> <div><label for="firstName" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-1yyjr3v">Full Name</label> <input type="text" id="firstName" name="firstName"${add_attribute("value", form?.firstName ?? "", 0)} class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="Enter your full name" autocapitalize="words" required></div>  <div><label for="email" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-dzhc20">Email</label> <input type="email" id="email" name="email"${add_attribute("value", form?.email ?? "", 0)} class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="you@example.com" autocapitalize="none" autocomplete="email" required></div>  <div><label for="password" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-t385zo">Password</label> <input type="password" id="password" name="password" class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="Create a strong password" minlength="8" autocomplete="new-password" required> <p class="text-sm text-spore-steel mt-2" data-svelte-h="svelte-1lqdaic">Minimum 8 characters</p></div>  <div><label for="confirmPassword" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-ibet7o">Confirm Password</label> <input type="password" id="confirmPassword" name="confirmPassword" class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="Confirm your password" autocomplete="new-password" required></div> <button type="submit" ${""} class="w-full bg-spore-forest text-white py-4 rounded-xl font-bold text-lg tracking-wide hover:bg-spore-forest/90 disabled:opacity-50 transition-all transform active:scale-95 touch-manipulation">${`CREATE ACCOUNT`}</button></form> <div class="mt-8 pt-6 border-t border-spore-cream/20 text-center"><p class="text-base text-spore-steel">Already have an account?
					<a href="/auth/login" class="text-spore-orange font-bold hover:text-spore-orange/80 transition-colors" data-svelte-h="svelte-1cue7fu">Sign in</a></p></div></div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/8.js
var __exports9 = {};
__export(__exports9, {
  component: () => component9,
  fonts: () => fonts9,
  imports: () => imports9,
  index: () => index9,
  server: () => page_server_ts_exports7,
  server_id: () => server_id8,
  stylesheets: () => stylesheets9
});
var index9, component_cache9, component9, server_id8, imports9, stylesheets9, fonts9;
var init__9 = __esm({
  ".svelte-kit/output/server/nodes/8.js"() {
    init_page_server_ts7();
    index9 = 8;
    component9 = async () => component_cache9 ??= (await Promise.resolve().then(() => (init_page_svelte7(), page_svelte_exports7))).default;
    server_id8 = "src/routes/auth/register/+page.server.ts";
    imports9 = ["_app/immutable/chunks/8.f5272396.js", "_app/immutable/chunks/_page.e281c412.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets9 = [];
    fonts9 = [];
  }
});

// .svelte-kit/output/server/entries/pages/auth/reset-password/_token_/_page.server.ts.js
var page_server_ts_exports8 = {};
__export(page_server_ts_exports8, {
  actions: () => actions7,
  load: () => load8
});
var load8, actions7;
var init_page_server_ts8 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/reset-password/_token_/_page.server.ts.js"() {
    init_chunks();
    init_auth();
    init_security();
    init_validation();
    load8 = async ({ params }) => {
      const { token } = params;
      const user = await validateResetToken(token);
      if (!user) {
        return {
          token: null,
          error: "This reset link is invalid or has expired. Please request a new one."
        };
      }
      return {
        token,
        email: user.email
      };
    };
    actions7 = {
      default: async ({ request, getClientAddress }) => {
        const security = SecurityManager.getInstance();
        const clientIP = getClientAddress();
        try {
          const formData = await request.formData();
          const token = formData.get("token");
          const password = formData.get("password");
          const confirmPassword = formData.get("confirmPassword");
          const validationResult = passwordResetSchema.safeParse({
            token,
            password,
            confirmPassword
          });
          if (!validationResult.success) {
            const errors = {};
            validationResult.error.issues.forEach((issue2) => {
              const key2 = issue2.path[0];
              errors[key2] = issue2.message;
            });
            return fail(400, {
              errors,
              token
            });
          }
          const user = await resetPassword(token, password);
          await security.logSecurityEvent({
            ipAddress: clientIP,
            action: "PASSWORD_RESET_COMPLETED",
            details: {
              userId: user.id,
              email: user.email
            },
            severity: "INFO"
          });
          return {
            success: true,
            message: "Password reset successfully"
          };
        } catch (error47) {
          console.error("Password reset error:", error47);
          await security.logSecurityEvent({
            ipAddress: clientIP,
            action: "PASSWORD_RESET_ERROR",
            details: {
              error: error47 instanceof Error ? error47.message : "Unknown error"
            },
            severity: "CRITICAL"
          });
          return fail(500, {
            errors: {
              general: "An error occurred while resetting your password. Please try again."
            }
          });
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/auth/reset-password/_token_/_page.svelte.js
var page_svelte_exports8 = {};
__export(page_svelte_exports8, {
  default: () => Page8
});
var Page8;
var init_page_svelte8 = __esm({
  ".svelte-kit/output/server/entries/pages/auth/reset-password/_token_/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    init_validation();
    Page8 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      let token = data.token;
      let form = { password: "", confirmPassword: "" };
      let errors = {};
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      return `${$$result.head += `<!-- HEAD_svelte-5alxut_START -->${$$result.title = `<title>Reset Password | Spore CMMS</title>`, ""}<!-- HEAD_svelte-5alxut_END -->`, ""} <div class="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8"><div class="max-w-md w-full space-y-8"><div><div class="mx-auto h-12 w-12 flex items-center justify-center rounded-full bg-spore-orange"><svg class="h-8 w-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z"></path></svg></div> <h2 class="mt-6 text-center text-3xl font-extrabold text-gray-900" data-svelte-h="svelte-1kmqc0l">Reset your password</h2> <p class="mt-2 text-center text-sm text-gray-600" data-svelte-h="svelte-pfqjbg">Enter your new password below</p></div> ${`<form method="POST" class="mt-8 space-y-6"><input type="hidden" name="token"${add_attribute("value", token, 0)}> <div class="space-y-4"><div><label for="password" class="block text-sm font-medium text-gray-700" data-svelte-h="svelte-t1lz5d">New Password</label> <div class="mt-1 relative">${`<input id="password" name="password" type="password" required class="${"appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-spore-orange focus:border-spore-orange sm:text-sm " + escape(errors.password ? "border-red-500" : "", true)}" placeholder="Enter your new password"${add_attribute("value", form.password, 0)}>`} <button type="button" class="absolute inset-y-0 right-0 pr-3 flex items-center">${`<svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`}</button></div> ${errors.password ? `<p class="mt-1 text-sm text-red-600">${escape(errors.password)}</p>` : ``}</div> <div><label for="confirmPassword" class="block text-sm font-medium text-gray-700" data-svelte-h="svelte-1ub4fed">Confirm Password</label> <div class="mt-1 relative">${`<input id="confirmPassword" name="confirmPassword" type="password" required class="${"appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-spore-orange focus:border-spore-orange sm:text-sm " + escape(errors.confirmPassword ? "border-red-500" : "", true)}" placeholder="Confirm your new password"${add_attribute("value", form.confirmPassword, 0)}>`} <button type="button" class="absolute inset-y-0 right-0 pr-3 flex items-center">${`<svg class="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path></svg>`}</button></div> ${errors.confirmPassword ? `<p class="mt-1 text-sm text-red-600">${escape(errors.confirmPassword)}</p>` : ``}</div></div> ${errors.general ? `<div class="rounded-md bg-red-50 p-4"><div class="flex"><div class="flex-shrink-0"><svg class="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd"></path></svg></div> <div class="ml-3"><p class="text-sm font-medium text-red-800">${escape(errors.general)}</p></div></div></div>` : ``} <div><button type="submit" ${""} class="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-spore-orange hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-spore-orange disabled:opacity-50 disabled:cursor-not-allowed transition-colors">${`Reset Password`}</button></div></form> <div class="mt-6"><div class="relative"><div class="absolute inset-0 flex items-center"><div class="w-full border-t border-gray-300"></div></div> <div class="relative flex justify-center text-sm"><span class="px-2 bg-gray-50 text-gray-500" data-svelte-h="svelte-1ld5my3">or</span></div></div> <div class="mt-6 text-center"><a href="/auth/login" class="font-medium text-spore-orange hover:text-spore-orange/90 transition-colors" data-svelte-h="svelte-1mwj2a2">Back to login</a></div></div>`}</div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/9.js
var __exports10 = {};
__export(__exports10, {
  component: () => component10,
  fonts: () => fonts10,
  imports: () => imports10,
  index: () => index10,
  server: () => page_server_ts_exports8,
  server_id: () => server_id9,
  stylesheets: () => stylesheets10
});
var index10, component_cache10, component10, server_id9, imports10, stylesheets10, fonts10;
var init__10 = __esm({
  ".svelte-kit/output/server/nodes/9.js"() {
    init_page_server_ts8();
    index10 = 9;
    component10 = async () => component_cache10 ??= (await Promise.resolve().then(() => (init_page_svelte8(), page_svelte_exports8))).default;
    server_id9 = "src/routes/auth/reset-password/[token]/+page.server.ts";
    imports10 = ["_app/immutable/chunks/9.d00b31b3.js", "_app/immutable/chunks/_page.99313784.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets10 = [];
    fonts10 = [];
  }
});

// .svelte-kit/output/server/entries/pages/dashboard/_page.server.ts.js
var page_server_ts_exports9 = {};
__export(page_server_ts_exports9, {
  load: () => load9
});
var RECENT_WORK_ORDERS_LIMIT, load9;
var init_page_server_ts9 = __esm({
  ".svelte-kit/output/server/entries/pages/dashboard/_page.server.ts.js"() {
    init_prisma();
    init_guards();
    RECENT_WORK_ORDERS_LIMIT = 5;
    load9 = async (event) => {
      try {
        requireAuth(event);
        const prisma = await createRequestPrisma(event);
        const organizationId = event.locals.user.organizationId ?? void 0;
        const [total, pending, inProgress, completed] = await Promise.all([
          prisma.workOrder.count({ where: { organizationId } }),
          prisma.workOrder.count({ where: { status: "PENDING", organizationId } }),
          prisma.workOrder.count({ where: { status: "IN_PROGRESS", organizationId } }),
          prisma.workOrder.count({ where: { status: "COMPLETED", organizationId } })
        ]);
        const recentWorkOrders = await prisma.workOrder.findMany({
          where: { organizationId },
          take: RECENT_WORK_ORDERS_LIMIT,
          orderBy: { updatedAt: "desc" },
          include: {
            Asset: {
              include: {
                Unit: {
                  select: {
                    name: true,
                    roomNumber: true,
                    Building: true,
                    floor: true,
                    Site: {
                      select: { name: true }
                    }
                  }
                }
              }
            }
          }
        });
        const sites = await prisma.site.findMany({
          where: { organizationId },
          include: {
            _count: {
              select: { Unit: true }
            }
          }
        });
        const mappedRecentWorkOrders = recentWorkOrders.map((wo) => ({
          ...wo,
          asset: wo.Asset ? {
            ...wo.Asset,
            room: wo.Asset.Unit ? {
              ...wo.Asset.Unit,
              name: wo.Asset.Unit.name || wo.Asset.Unit.roomNumber
            } : null
          } : null
        }));
        const mappedSites = sites.map((site) => ({
          ...site,
          _count: {
            rooms: site._count.Unit
          }
        }));
        return {
          stats: { total, pending, inProgress, completed },
          recentWorkOrders: mappedRecentWorkOrders,
          sites: mappedSites
        };
      } catch (error47) {
        console.error("[DASHBOARD] Error loading dashboard:", error47);
        throw error47;
      }
    };
  }
});

// .svelte-kit/output/server/chunks/websocket.js
var initialState, wsStore;
var init_websocket = __esm({
  ".svelte-kit/output/server/chunks/websocket.js"() {
    init_index2();
    initialState = {
      isConnected: false,
      messages: [],
      error: null,
      orgId: null,
      isPolling: false
    };
    wsStore = writable(initialState);
  }
});

// .svelte-kit/output/server/entries/pages/dashboard/_page.svelte.js
var page_svelte_exports9 = {};
__export(page_svelte_exports9, {
  default: () => Page9
});
function getStatusBadgeClasses(status) {
  const base2 = "px-3 py-1.5 text-xs font-bold uppercase tracking-wide rounded-full";
  const styles = {
    COMPLETED: "bg-spore-forest text-white",
    IN_PROGRESS: "bg-spore-orange text-white",
    PENDING: "bg-spore-steel text-white",
    ON_HOLD: "bg-spore-cream text-spore-steel"
  };
  return `${base2} ${styles[status] || "bg-spore-cream text-spore-steel"}`;
}
var LIVE_FEED_MAX_ITEMS, Page9;
var init_page_svelte9 = __esm({
  ".svelte-kit/output/server/entries/pages/dashboard/_page.svelte.js"() {
    init_ssr();
    init_websocket();
    LIVE_FEED_MAX_ITEMS = 10;
    Page9 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let stats;
      let recentWorkOrders;
      let statsConfig;
      let { data } = $$props;
      let wsConnected = false;
      let wsPolling = false;
      let liveFeed = [];
      const unsubscribe = wsStore.subscribe((state) => {
        wsConnected = state.isConnected;
        wsPolling = state.isPolling;
        if (state.messages.length > 0) {
          const latest = state.messages[0];
          if (latest.type === "WO_UPDATE") {
            const wo = latest.payload;
            liveFeed = [
              {
                type: "update",
                message: `${wo.title} \u2192 ${wo.status}`,
                time: /* @__PURE__ */ new Date(),
                id: latest.timestamp
              },
              ...liveFeed
            ].slice(0, LIVE_FEED_MAX_ITEMS);
          }
          if (latest.type === "WO_NEW") {
            const wo = latest.payload;
            liveFeed = [
              {
                type: "new",
                message: `New: ${wo.title}`,
                time: /* @__PURE__ */ new Date(),
                id: latest.timestamp
              },
              ...liveFeed
            ].slice(0, LIVE_FEED_MAX_ITEMS);
          }
        }
      });
      onDestroy(() => unsubscribe());
      const quickActions = [
        {
          icon: "\u{1F4CB}",
          label: "All Work Orders",
          href: "/work-orders"
        },
        {
          icon: "\u{1F3E2}",
          label: "Sites",
          href: "/sites"
        },
        {
          icon: "\u2699\uFE0F",
          label: "Assets",
          href: "/assets"
        },
        {
          icon: "\u2795",
          label: "New WO",
          href: "/work-orders?create=true",
          primary: true
        }
      ];
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      stats = data.stats;
      recentWorkOrders = data.recentWorkOrders || [];
      statsConfig = [
        {
          label: "Total WOs",
          value: stats?.total || 0,
          color: "text-spore-dark"
        },
        {
          label: "Pending",
          value: stats?.pending || 0,
          color: "text-spore-orange"
        },
        {
          label: "In Progress",
          value: stats?.inProgress || 0,
          color: "text-spore-steel"
        },
        {
          label: "Completed",
          value: stats?.completed || 0,
          color: "text-spore-forest"
        }
      ];
      return `${$$result.head += `<!-- HEAD_svelte-6500cf_START -->${$$result.title = `<title>Dashboard \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-6500cf_END -->`, ""} <div class="max-w-7xl mx-auto px-4 py-10"> <div class="mb-10"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-1nvtx26">Dashboard</h1> <div class="flex items-center gap-3 mt-2"><span class="${"flex items-center gap-2 text-sm font-medium " + escape(
        wsConnected ? "text-spore-orange" : wsPolling ? "text-spore-forest" : "text-spore-cream/50",
        true
      )}" role="status" aria-live="polite"><span class="${"w-2 h-2 rounded-full " + escape(
        wsConnected ? "bg-spore-orange animate-pulse" : wsPolling ? "bg-spore-forest animate-pulse" : "bg-spore-cream/30",
        true
      )}" aria-hidden="true"></span> ${wsConnected ? `Live updates enabled` : `${wsPolling ? `Polling updates` : `Connecting...`}`}</span></div></div> <div class="grid grid-cols-1 lg:grid-cols-3 gap-8"> <div class="lg:col-span-2 space-y-8"> <div class="grid grid-cols-2 md:grid-cols-4 gap-4">${each(statsConfig, (stat) => {
        return `<div class="bg-spore-white rounded-xl p-5 shadow-sm border border-spore-cream/50"><p class="text-xs font-semibold text-spore-steel uppercase tracking-wide">${escape(stat.label)}</p> <p class="${"text-3xl font-extrabold " + escape(stat.color, true) + " mt-1"}">${escape(stat.value)}</p> </div>`;
      })}</div>  <div class="bg-spore-white rounded-xl p-6 shadow-sm border border-spore-cream/50"><h2 class="text-lg font-bold text-spore-dark mb-5" data-svelte-h="svelte-10azdkw">Quick Actions</h2> <div class="grid grid-cols-2 md:grid-cols-4 gap-4">${each(quickActions, (action) => {
        return `<a${add_attribute("href", action.href, 0)} class="${"flex flex-col items-center p-5 " + escape(
          action.primary ? "bg-spore-orange rounded-xl hover:bg-spore-orange/90 transition-colors shadow-sm hover:shadow-md" : "bg-spore-cream/30 rounded-xl hover:bg-spore-cream/50 transition-colors border border-spore-cream/30",
          true
        )}"><span class="text-2xl mb-2">${escape(action.icon)}</span> <span class="${"text-sm font-semibold " + escape(
          action.primary ? "text-white font-bold" : "text-spore-steel",
          true
        )}">${escape(action.label)}</span> </a>`;
      })}</div></div>  <div class="bg-spore-white rounded-xl p-6 shadow-sm border border-spore-cream/50"><div class="flex justify-between items-center mb-5"><h2 class="text-lg font-bold text-spore-dark" data-svelte-h="svelte-1umgn2y">Recent Work Orders</h2> <a href="/work-orders" class="text-sm font-semibold text-spore-orange hover:text-spore-orange/80" data-svelte-h="svelte-1ohthn9">View all \u2192</a></div> ${recentWorkOrders.length > 0 ? `<div class="space-y-3">${each(recentWorkOrders, (wo) => {
        return `<div class="flex items-center justify-between p-4 bg-spore-cream/20 rounded-lg border border-spore-cream/50"><div class="flex-1 min-w-0"><p class="text-sm font-bold text-spore-dark truncate">${escape(wo.title)}</p> <p class="text-xs text-spore-steel mt-1">${escape(wo.asset?.room?.name ? `Room ${wo.asset.room.name}` : "")} ${escape(wo.asset?.room?.building ? ` \u2022 Bldg ${wo.asset.room.building}` : "")} ${escape(wo.asset?.room?.floor ? ` \u2022 Floor ${wo.asset.room.floor}` : "")} </p></div> <span${add_attribute("class", getStatusBadgeClasses(wo.status), 0)}>${escape(wo.status.replace("_", " "))}</span> </div>`;
      })}</div>` : `<p class="text-spore-steel text-sm" data-svelte-h="svelte-bae9j6">No recent work orders</p>`}</div></div>  <div class="space-y-8"><div class="bg-spore-dark rounded-xl p-6 border border-spore-steel/30"><div class="flex items-center justify-between mb-5"><h2 class="text-lg font-bold text-spore-cream" data-svelte-h="svelte-846tpj">Live Feed</h2> <span class="${"flex items-center gap-2 text-xs font-semibold " + escape(
        wsConnected ? "text-spore-orange" : wsPolling ? "text-spore-forest" : "text-spore-cream/50",
        true
      )}"><span class="${"w-2 h-2 rounded-full " + escape(
        wsConnected ? "bg-spore-orange animate-pulse" : wsPolling ? "bg-spore-forest animate-pulse" : "bg-spore-cream/30",
        true
      )}"></span> ${wsConnected ? `Live` : `${wsPolling ? `Polling` : `Offline`}`}</span></div> ${liveFeed.length > 0 ? `<div class="space-y-3">${each(liveFeed, (item) => {
        return `<div class="${"flex items-start gap-3 p-3 rounded-lg " + escape(
          item.type === "new" ? "bg-spore-forest/20" : "bg-spore-steel/50",
          true
        )}"><span class="text-base">${escape(item.type === "new" ? "\u{1F195}" : "\u{1F504}")}</span> <div class="flex-1 min-w-0"><p class="text-sm font-medium text-spore-cream truncate">${escape(item.message)}</p> <p class="text-xs text-spore-cream/50 mt-1">${escape(item.time.toLocaleTimeString())} </p></div> </div>`;
      })}</div>` : `<div class="text-center py-10"><p class="text-spore-cream/50 text-sm font-medium" data-svelte-h="svelte-jard1z">Waiting for activity...</p> <p class="text-xs text-spore-cream/30 mt-2" data-svelte-h="svelte-h90cnw">Updates appear here in real-time</p></div>`}</div>  ${data.sites && data.sites.length > 0 ? `<div class="bg-spore-white rounded-xl p-6"><h2 class="text-lg font-bold text-spore-dark mb-5" data-svelte-h="svelte-ifb08s">Sites</h2> <div class="space-y-3">${each(data.sites, (site) => {
        return `<a href="${"/sites/" + escape(site.id, true)}" class="flex items-center justify-between p-4 bg-spore-cream/20 rounded-lg hover:bg-spore-cream/40 transition-colors border border-spore-cream/50"><span class="text-sm font-bold text-spore-dark">${escape(site.name)}</span> <span class="text-xs font-semibold text-spore-steel">${escape(site._count?.rooms || 0)} rooms</span> </a>`;
      })}</div></div>` : ``}</div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/10.js
var __exports11 = {};
__export(__exports11, {
  component: () => component11,
  fonts: () => fonts11,
  imports: () => imports11,
  index: () => index11,
  server: () => page_server_ts_exports9,
  server_id: () => server_id10,
  stylesheets: () => stylesheets11
});
var index11, component_cache11, component11, server_id10, imports11, stylesheets11, fonts11;
var init__11 = __esm({
  ".svelte-kit/output/server/nodes/10.js"() {
    init_page_server_ts9();
    index11 = 10;
    component11 = async () => component_cache11 ??= (await Promise.resolve().then(() => (init_page_svelte9(), page_svelte_exports9))).default;
    server_id10 = "src/routes/dashboard/+page.server.ts";
    imports11 = ["_app/immutable/nodes/10.3852fac7.js", "_app/immutable/chunks/_page.b2002d4b.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/websocket.ff281e65.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets11 = [];
    fonts11 = [];
  }
});

// .svelte-kit/output/server/entries/pages/join-organization/_page.server.ts.js
var page_server_ts_exports10 = {};
__export(page_server_ts_exports10, {
  actions: () => actions8,
  load: () => load10
});
var load10, actions8;
var init_page_server_ts10 = __esm({
  ".svelte-kit/output/server/entries/pages/join-organization/_page.server.ts.js"() {
    init_chunks();
    init_validation();
    init_prisma();
    load10 = async ({ locals }) => {
      if (!locals.user) {
        throw redirect(303, "/auth/login");
      }
      if (locals.authState === "org_member") {
        throw redirect(303, "/dashboard");
      }
      return {};
    };
    actions8 = {
      default: async ({ request, locals }) => {
        if (!locals.user) {
          throw redirect(303, "/auth/login");
        }
        if (locals.authState === "org_member") {
          throw redirect(303, "/dashboard");
        }
        const formData = await request.formData();
        const validation = validateInput(joinOrganizationSchema, {
          inviteToken: formData.get("inviteToken")
        });
        if (!validation.success) {
          const firstError = Object.values(validation.errors)[0];
          return fail(400, {
            error: firstError,
            inviteToken: formData.get("inviteToken")
          });
        }
        const client = await getPrisma();
        try {
          const invite = await client.organizationInvite.findUnique({
            where: { token: validation.data.inviteToken },
            include: {
              Organization: {
                select: {
                  id: true,
                  name: true
                }
              }
            }
          });
          if (!invite) {
            return fail(400, {
              error: "Invalid invite code",
              inviteToken: formData.get("inviteToken")
            });
          }
          if (invite.expiresAt < /* @__PURE__ */ new Date()) {
            return fail(400, {
              error: "This invite has expired",
              inviteToken: formData.get("inviteToken")
            });
          }
          if (invite.status !== "PENDING") {
            return fail(400, {
              error: "This invite has already been used",
              inviteToken: formData.get("inviteToken")
            });
          }
          if (invite.email !== locals.user.email) {
            return fail(400, {
              error: "This invite was sent to a different email address",
              inviteToken: formData.get("inviteToken")
            });
          }
          await client.$transaction(async (tx) => {
            await tx.organizationInvite.update({
              where: { id: invite.id },
              data: { status: "ACCEPTED" }
            });
            await tx.user.update({
              where: { id: locals.user.id },
              data: {
                organizationId: invite.organizationId,
                role: "TECHNICIAN"
              }
            });
          });
          return {
            success: `Successfully joined ${invite.Organization.name}! Redirecting to dashboard...`,
            organization: invite.Organization.name,
            redirect: true
          };
        } catch (error47) {
          console.error("[JOIN ORG] Error:", error47);
          return fail(500, {
            error: "Failed to join organization. Please try again.",
            inviteToken: formData.get("inviteToken")
          });
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/join-organization/_page.svelte.js
var page_svelte_exports10 = {};
__export(page_svelte_exports10, {
  default: () => Page10
});
var Page10;
var init_page_svelte10 = __esm({
  ".svelte-kit/output/server/entries/pages/join-organization/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page10 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { form } = $$props;
      let redirectTimeout;
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      {
        if (form?.redirect) {
          clearTimeout(redirectTimeout);
          redirectTimeout = setTimeout(
            () => {
              window.location.href = "/dashboard";
            },
            2e3
          );
        }
      }
      return `<div class="min-h-screen bg-spore-dark flex items-center justify-center px-4 py-8"><div class="w-full max-w-md"> <div class="text-center mb-8"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-8kgatc">\u{1F33F} SPORE</h1> <p class="text-spore-cream/60 mt-2 text-lg" data-svelte-h="svelte-1uuzxd8">Join Organization</p> <p class="text-spore-cream/40 mt-1" data-svelte-h="svelte-14zw0na">Enter your invite code to get started</p></div>  <div class="bg-spore-white rounded-2xl p-6 sm:p-8 shadow-2xl">${form?.error ? `<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-4 rounded-xl mb-6 text-base font-medium">${escape(form.error)}</div>` : ``} ${form?.success ? `<div class="bg-green-50 border border-green-200 text-green-700 px-4 py-4 rounded-xl mb-6 text-base font-medium">${escape(form.success)}</div>` : ``} <form method="POST" class="space-y-5"><div><label for="inviteToken" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-1am6fzo">Invite Code</label> <input type="text" id="inviteToken" name="inviteToken"${add_attribute("value", form?.inviteToken ?? "", 0)} class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="Enter your invite code" autocapitalize="characters" autocorrect="off" spellcheck="false" required> <p class="text-sm text-spore-steel mt-2" data-svelte-h="svelte-187u9xa">Ask your organization admin for the invite code</p></div> ${form?.organization ? `<div class="bg-spore-cream/10 rounded-xl p-4"><p class="text-sm font-semibold text-spore-steel mb-1" data-svelte-h="svelte-1gjl1iv">You&#39;re joining:</p> <p class="text-lg font-bold text-spore-dark">${escape(form.organization)}</p></div>` : ``} <button type="submit" ${""} class="w-full bg-spore-forest text-white py-4 rounded-xl font-bold text-lg tracking-wide hover:bg-spore-forest/90 disabled:opacity-50 transition-all transform active:scale-95 touch-manipulation">${`JOIN ORGANIZATION`}</button></form> <div class="mt-8 pt-6 border-t border-spore-cream/20 text-center"><a href="/onboarding" class="text-spore-orange font-bold hover:text-spore-orange/80 transition-colors" data-svelte-h="svelte-scsy45">\u2190 Back to onboarding</a></div></div>  <div class="mt-6 text-center"><form method="POST" action="/auth/logout"><button type="submit" class="text-spore-cream/60 hover:text-spore-cream/80 text-sm transition-colors" data-svelte-h="svelte-1t49qke">Sign out</button></form></div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/11.js
var __exports12 = {};
__export(__exports12, {
  component: () => component12,
  fonts: () => fonts12,
  imports: () => imports12,
  index: () => index12,
  server: () => page_server_ts_exports10,
  server_id: () => server_id11,
  stylesheets: () => stylesheets12
});
var index12, component_cache12, component12, server_id11, imports12, stylesheets12, fonts12;
var init__12 = __esm({
  ".svelte-kit/output/server/nodes/11.js"() {
    init_page_server_ts10();
    index12 = 11;
    component12 = async () => component_cache12 ??= (await Promise.resolve().then(() => (init_page_svelte10(), page_svelte_exports10))).default;
    server_id11 = "src/routes/join-organization/+page.server.ts";
    imports12 = ["_app/immutable/chunks/11.38a9ad2b.js", "_app/immutable/chunks/_page.712b7f4e.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets12 = [];
    fonts12 = [];
  }
});

// .svelte-kit/output/server/entries/pages/onboarding/_page.server.ts.js
var page_server_ts_exports11 = {};
__export(page_server_ts_exports11, {
  actions: () => actions9,
  load: () => load11
});
var load11, actions9;
var init_page_server_ts11 = __esm({
  ".svelte-kit/output/server/entries/pages/onboarding/_page.server.ts.js"() {
    init_chunks();
    init_validation();
    init_prisma();
    load11 = async ({ locals }) => {
      if (!locals.user) {
        throw redirect(303, "/auth/login");
      }
      if (locals.authState === "org_member") {
        throw redirect(303, "/dashboard");
      }
      return {};
    };
    actions9 = {
      default: async ({ request, locals }) => {
        if (!locals.user) {
          throw redirect(303, "/auth/login");
        }
        if (locals.authState === "org_member") {
          throw redirect(303, "/dashboard");
        }
        const formData = await request.formData();
        const isCreate = formData.get("create") === "true";
        if (isCreate) {
          const validation = validateInput(createOrganizationSchema, {
            orgName: formData.get("orgName")
          });
          if (!validation.success) {
            const firstError = Object.values(validation.errors)[0];
            return fail(400, {
              error: firstError,
              orgName: formData.get("orgName")
            });
          }
          const client = await getPrisma();
          const existingOrg = await client.organization.findUnique({
            where: { name: validation.data.orgName }
          });
          if (existingOrg) {
            return fail(400, {
              error: "An organization with this name already exists",
              orgName: formData.get("orgName")
            });
          }
          try {
            await client.$transaction(async (tx) => {
              const org = await tx.organization.create({
                data: { name: validation.data.orgName, updatedAt: /* @__PURE__ */ new Date() }
              });
              await tx.user.update({
                where: { id: locals.user.id },
                data: {
                  organizationId: org.id,
                  role: "ADMIN"
                }
              });
            });
            throw redirect(303, "/dashboard");
          } catch (error47) {
            console.error("[ONBOARDING] Error creating organization:", error47);
            return fail(500, {
              error: "Failed to create organization. Please try again.",
              orgName: formData.get("orgName")
            });
          }
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/onboarding/_page.svelte.js
var page_svelte_exports11 = {};
__export(page_svelte_exports11, {
  default: () => Page11
});
var Page11;
var init_page_svelte11 = __esm({
  ".svelte-kit/output/server/entries/pages/onboarding/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page11 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { form } = $$props;
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      return `<div class="min-h-screen bg-spore-dark flex items-center justify-center px-4 py-8"><div class="w-full max-w-md"> <div class="text-center mb-8"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-8kgatc">\u{1F33F} SPORE</h1> <p class="text-spore-cream/60 mt-2 text-lg" data-svelte-h="svelte-ftmifd">Welcome aboard!</p> <p class="text-spore-cream/40 mt-2" data-svelte-h="svelte-vewr6j">Let&#39;s get you set up with an organization</p></div>  <div class="bg-spore-white rounded-2xl p-6 sm:p-8 shadow-2xl">${form?.error ? `<div class="bg-red-50 border border-red-200 text-red-700 px-4 py-4 rounded-xl mb-6 text-base font-medium">${escape(form.error)}</div>` : ``}  <div class="mb-8"><div class="grid grid-cols-2 gap-4"><button type="button" class="${"p-4 rounded-xl border-2 transition-all " + escape(
        "border-spore-orange bg-spore-orange/10 text-spore-orange",
        true
      )}"><svg class="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path></svg> <span class="font-semibold text-sm" data-svelte-h="svelte-1geyc1o">Create New</span></button> <button type="button" class="${"p-4 rounded-xl border-2 transition-all " + escape(
        "border-spore-cream/30 text-spore-steel hover:border-spore-cream/50",
        true
      )}"><svg class="w-8 h-8 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"></path></svg> <span class="font-semibold text-sm" data-svelte-h="svelte-q1nc29">Join Existing</span></button></div></div>  ${`<form method="POST" action="/onboarding?create=true" class="space-y-5"><div><label for="orgName" class="block text-base font-bold text-spore-steel mb-3" data-svelte-h="svelte-71ncp5">Organization Name</label> <input type="text" id="orgName" name="orgName"${add_attribute("value", form?.orgName ?? "", 0)} class="w-full px-5 py-4 text-lg rounded-xl border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:bg-spore-white transition-all" placeholder="e.g., Sunrise Senior Living" autocapitalize="words" required></div> <button type="submit" ${""} class="w-full bg-spore-forest text-white py-4 rounded-xl font-bold text-lg tracking-wide hover:bg-spore-forest/90 disabled:opacity-50 transition-all transform active:scale-95 touch-manipulation">${`CREATE ORGANIZATION`}</button></form>`}</div>  <div class="mt-6 text-center"><form method="POST" action="/auth/logout"><button type="submit" class="text-spore-cream/60 hover:text-spore-cream/80 text-sm transition-colors" data-svelte-h="svelte-1t49qke">Sign out</button></form></div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/12.js
var __exports13 = {};
__export(__exports13, {
  component: () => component13,
  fonts: () => fonts13,
  imports: () => imports13,
  index: () => index13,
  server: () => page_server_ts_exports11,
  server_id: () => server_id12,
  stylesheets: () => stylesheets13
});
var index13, component_cache13, component13, server_id12, imports13, stylesheets13, fonts13;
var init__13 = __esm({
  ".svelte-kit/output/server/nodes/12.js"() {
    init_page_server_ts11();
    index13 = 12;
    component13 = async () => component_cache13 ??= (await Promise.resolve().then(() => (init_page_svelte11(), page_svelte_exports11))).default;
    server_id12 = "src/routes/onboarding/+page.server.ts";
    imports13 = ["_app/immutable/chunks/12.23c3a1c8.js", "_app/immutable/chunks/_page.35493fbc.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets13 = [];
    fonts13 = [];
  }
});

// .svelte-kit/output/server/entries/pages/profile/_page.server.ts.js
var page_server_ts_exports12 = {};
__export(page_server_ts_exports12, {
  actions: () => actions10,
  load: () => load12
});
var load12, actions10;
var init_page_server_ts12 = __esm({
  ".svelte-kit/output/server/entries/pages/profile/_page.server.ts.js"() {
    init_prisma();
    init_auth();
    init_guards();
    init_chunks();
    load12 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const userId = event.locals.user.id;
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          phoneNumber: true,
          role: true,
          createdAt: true
        }
      });
      return { profile: user };
    };
    actions10 = {
      updateProfile: async (event) => {
        requireAuth(event);
        const prisma = await createRequestPrisma(event);
        const userId = event.locals.user.id;
        const formData = await event.request.formData();
        const firstName = formData.get("firstName");
        const lastName = formData.get("lastName");
        const phoneNumber = formData.get("phoneNumber");
        await prisma.user.update({
          where: { id: userId },
          data: {
            firstName: firstName?.trim() || null,
            lastName: lastName?.trim() || null,
            phoneNumber: phoneNumber?.trim() || null
          }
        });
        return { success: true, message: "Profile updated successfully" };
      },
      changePassword: async (event) => {
        requireAuth(event);
        const prisma = await createRequestPrisma(event);
        const userId = event.locals.user.id;
        const formData = await event.request.formData();
        const currentPassword = formData.get("currentPassword");
        const newPassword = formData.get("newPassword");
        const confirmPassword = formData.get("confirmPassword");
        if (!currentPassword || !newPassword || !confirmPassword) {
          return fail(400, { passwordError: "All password fields are required" });
        }
        if (newPassword.length < 8) {
          return fail(400, { passwordError: "New password must be at least 8 characters" });
        }
        if (newPassword !== confirmPassword) {
          return fail(400, { passwordError: "New passwords do not match" });
        }
        const user = await prisma.user.findUnique({
          where: { id: userId },
          select: { password: true }
        });
        if (!user) {
          return fail(400, { passwordError: "User not found" });
        }
        const isValid = await verifyPassword(currentPassword, user.password);
        if (!isValid) {
          return fail(400, { passwordError: "Current password is incorrect" });
        }
        const hashedPassword = await hashPassword(newPassword);
        await prisma.user.update({
          where: { id: userId },
          data: { password: hashedPassword }
        });
        return { passwordSuccess: true, message: "Password changed successfully" };
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/profile/_page.svelte.js
var page_svelte_exports12 = {};
__export(page_svelte_exports12, {
  default: () => Page12
});
var Page12;
var init_page_svelte12 = __esm({
  ".svelte-kit/output/server/entries/pages/profile/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page12 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      let { form } = $$props;
      let currentPassword = "";
      let newPassword = "";
      let confirmPassword = "";
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      if ($$props.form === void 0 && $$bindings.form && form !== void 0)
        $$bindings.form(form);
      return `${$$result.head += `<!-- HEAD_svelte-3w78n0_START -->${$$result.title = `<title>Profile \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-3w78n0_END -->`, ""} <div class="max-w-3xl mx-auto px-4 py-10"><div class="mb-8"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-1wjr7t2">Profile Settings</h1> <p class="text-spore-cream/60 mt-2" data-svelte-h="svelte-1xj12s3">Manage your account information</p></div>  <div class="bg-spore-dark rounded-xl p-6 mb-6 border border-spore-steel/30"><div class="flex items-start gap-6"> <div class="w-20 h-20 rounded-full bg-spore-orange flex items-center justify-center text-3xl font-bold text-white shrink-0">${escape((data.profile?.firstName?.[0] || data.profile?.email?.[0] || "?").toUpperCase())}</div> <div class="flex-1 min-w-0"><h2 class="text-2xl font-bold text-spore-cream">${data.profile?.firstName || data.profile?.lastName ? `${escape([data.profile?.firstName, data.profile?.lastName].filter(Boolean).join(" "))}` : `${escape(data.profile?.email?.split("@")[0])}`}</h2> <div class="mt-3 grid grid-cols-1 sm:grid-cols-2 gap-x-8 gap-y-2 text-sm"><div><span class="text-spore-steel" data-svelte-h="svelte-n48nce">Email</span> <p class="text-spore-cream font-medium truncate">${escape(data.profile?.email)}</p></div> <div><span class="text-spore-steel" data-svelte-h="svelte-x9w8cq">Phone</span> <p class="text-spore-cream font-medium">${escape(data.profile?.phoneNumber || "\u2014")}</p></div> <div><span class="text-spore-steel" data-svelte-h="svelte-1wne51i">Role</span> <p class="text-spore-cream font-medium capitalize">${escape(data.profile?.role?.toLowerCase())}</p></div> <div><span class="text-spore-steel" data-svelte-h="svelte-1atodpa">Access Level</span> <p class="${"font-medium " + escape(
        data.profile?.role === "ADMIN" ? "text-spore-orange" : data.profile?.role === "MANAGER" ? "text-spore-forest" : "text-spore-cream",
        true
      )}">${data.profile?.role === "ADMIN" ? `Full Access` : `${data.profile?.role === "MANAGER" ? `Elevated Access` : `Standard Access`}`}</p></div></div></div></div></div>  <div class="bg-spore-white rounded-xl p-6 mb-6"><h2 class="text-lg font-bold text-spore-dark mb-4" data-svelte-h="svelte-t4k2di">Edit Profile</h2> ${form?.success ? `<div class="mb-4 p-3 bg-spore-forest/10 border border-spore-forest/30 rounded-lg text-spore-forest text-sm">${escape(form.message)}</div>` : ``} <form method="POST" action="?/updateProfile" class="space-y-4"><div class="grid grid-cols-1 sm:grid-cols-2 gap-4"><div><label for="firstName" class="block text-sm font-medium text-spore-steel mb-1" data-svelte-h="svelte-13ykw0p">First Name</label> <input type="text" id="firstName" name="firstName"${add_attribute("value", data.profile?.firstName || "", 0)} class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"></div> <div><label for="lastName" class="block text-sm font-medium text-spore-steel mb-1" data-svelte-h="svelte-eyowth">Last Name</label> <input type="text" id="lastName" name="lastName"${add_attribute("value", data.profile?.lastName || "", 0)} class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"></div></div> <div><label for="phoneNumber" class="block text-sm font-medium text-spore-steel mb-1" data-svelte-h="svelte-jpoql5">Phone Number</label> <input type="tel" id="phoneNumber" name="phoneNumber"${add_attribute("value", data.profile?.phoneNumber || "", 0)} placeholder="(555) 123-4567" class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange"></div> <div><label class="block text-sm font-medium text-spore-steel mb-1" data-svelte-h="svelte-1551fsf">Email</label> <input type="email"${add_attribute("value", data.profile?.email || "", 0)} disabled class="w-full px-4 py-3 rounded-lg border border-spore-cream/50 bg-spore-cream/10 text-spore-steel cursor-not-allowed"> <p class="text-xs text-spore-steel mt-1" data-svelte-h="svelte-9ep45u">Contact an admin to change your email</p></div> <div class="flex justify-between items-center pt-2"><div class="text-sm text-spore-steel"><span class="font-medium" data-svelte-h="svelte-1knzhrc">Role:</span> <span class="capitalize">${escape(data.profile?.role.toLowerCase())}</span></div> <button type="submit" ${""} class="bg-spore-forest text-white px-6 py-2 rounded-lg font-bold text-sm hover:bg-spore-forest/90 focus:outline-none focus:ring-2 focus:ring-spore-forest disabled:opacity-50 transition-colors">${escape("Save Changes")}</button></div></form></div>  <div class="bg-spore-white rounded-xl p-6"><h2 class="text-lg font-bold text-spore-dark mb-4" data-svelte-h="svelte-1vsjyy0">Change Password</h2> ${form?.passwordError ? `<div class="mb-4 p-3 bg-red-50 border border-red-200 rounded-lg text-red-600 text-sm">${escape(form.passwordError)}</div>` : ``} ${form?.passwordSuccess ? `<div class="mb-4 p-3 bg-spore-forest/10 border border-spore-forest/30 rounded-lg text-spore-forest text-sm">${escape(form.message)}</div>` : ``} <form method="POST" action="?/changePassword" class="space-y-4"><div><label for="currentPassword" class="block text-sm font-medium text-spore-steel mb-1" data-svelte-h="svelte-1rc1a4n">Current Password</label> <input type="password" id="currentPassword" name="currentPassword" required class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", currentPassword, 0)}></div> <div class="grid grid-cols-1 sm:grid-cols-2 gap-4"><div><label for="newPassword" class="block text-sm font-medium text-spore-steel mb-1" data-svelte-h="svelte-t80aod">New Password</label> <input type="password" id="newPassword" name="newPassword" minlength="8" required class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", newPassword, 0)}></div> <div><label for="confirmPassword" class="block text-sm font-medium text-spore-steel mb-1" data-svelte-h="svelte-w47hzp">Confirm Password</label> <input type="password" id="confirmPassword" name="confirmPassword" minlength="8" required class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", confirmPassword, 0)}></div></div> <p class="text-xs text-spore-steel" data-svelte-h="svelte-aovh52">Password must be at least 8 characters</p> <div class="flex justify-end pt-2"><button type="submit" ${"disabled"} class="bg-spore-orange text-white px-6 py-2 rounded-lg font-bold text-sm hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-spore-orange disabled:opacity-50 transition-colors">${escape("Change Password")}</button></div></form></div>  <div class="mt-6 text-center text-sm text-spore-cream/50">Account created ${escape(new Date(data.profile?.createdAt || "").toLocaleDateString())}</div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/13.js
var __exports14 = {};
__export(__exports14, {
  component: () => component14,
  fonts: () => fonts14,
  imports: () => imports14,
  index: () => index14,
  server: () => page_server_ts_exports12,
  server_id: () => server_id13,
  stylesheets: () => stylesheets14
});
var index14, component_cache14, component14, server_id13, imports14, stylesheets14, fonts14;
var init__14 = __esm({
  ".svelte-kit/output/server/nodes/13.js"() {
    init_page_server_ts12();
    index14 = 13;
    component14 = async () => component_cache14 ??= (await Promise.resolve().then(() => (init_page_svelte12(), page_svelte_exports12))).default;
    server_id13 = "src/routes/profile/+page.server.ts";
    imports14 = ["_app/immutable/chunks/13.e5975abc.js", "_app/immutable/chunks/_page.bc100e93.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets14 = [];
    fonts14 = [];
  }
});

// .svelte-kit/output/server/entries/pages/select-organization/_page.server.ts.js
var page_server_ts_exports13 = {};
__export(page_server_ts_exports13, {
  actions: () => actions11,
  load: () => load13
});
var load13, actions11;
var init_page_server_ts13 = __esm({
  ".svelte-kit/output/server/entries/pages/select-organization/_page.server.ts.js"() {
    init_chunks();
    init_prisma();
    load13 = async ({ locals }) => {
      if (!locals.user) {
        throw redirect(303, "/auth/login");
      }
      if (locals.authState === "lobby") {
        throw redirect(303, "/onboarding");
      }
      const client = await getPrisma();
      const userOrgs = await client.organization.findMany({
        where: {
          User: {
            some: {
              id: locals.user.id
            }
          }
        },
        select: {
          id: true,
          name: true
        }
      });
      return {
        organizations: userOrgs,
        currentOrganization: locals.currentOrganization
      };
    };
    actions11 = {
      default: async ({ request, locals }) => {
        if (!locals.user) {
          throw redirect(303, "/auth/login");
        }
        if (locals.authState !== "org_member") {
          throw redirect(303, "/onboarding");
        }
        const formData = await request.formData();
        const organizationId = formData.get("organizationId");
        if (!organizationId) {
          return fail(400, { error: "Please select an organization" });
        }
        const client = await getPrisma();
        try {
          const membership = await client.organization.findFirst({
            where: {
              id: organizationId,
              User: {
                some: {
                  id: locals.user.id
                }
              }
            }
          });
          if (!membership) {
            return fail(400, { error: "You do not have access to this organization" });
          }
          await client.user.update({
            where: { id: locals.user.id },
            data: { organizationId }
          });
          throw redirect(303, "/dashboard");
        } catch (error47) {
          if (error47 instanceof Response) {
            throw error47;
          }
          console.error("[SELECT ORG] Error:", error47);
          return fail(500, { error: "Failed to switch organizations. Please try again." });
        }
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/select-organization/_page.svelte.js
var page_svelte_exports13 = {};
__export(page_svelte_exports13, {
  default: () => Page13
});
var Page13;
var init_page_svelte13 = __esm({
  ".svelte-kit/output/server/entries/pages/select-organization/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page13 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      let selectedOrg = "";
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      return `<div class="min-h-screen bg-spore-dark flex items-center justify-center px-4 py-8"><div class="w-full max-w-md"> <div class="text-center mb-8"><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-8kgatc">\u{1F33F} SPORE</h1> <p class="text-spore-cream/60 mt-2 text-lg" data-svelte-h="svelte-194mi4o">Select Organization</p> <p class="text-spore-cream/40 mt-1" data-svelte-h="svelte-10918ha">Choose which organization to work with</p></div>  <div class="bg-spore-white rounded-2xl p-6 sm:p-8 shadow-2xl">${data.organizations && data.organizations.length > 0 ? `<form method="POST"><div class="space-y-3 mb-8">${each(data.organizations, (org) => {
        return `<label class="block"><input type="radio" name="organizationId"${add_attribute("value", org.id, 0)} class="sr-only peer" required${org.id === selectedOrg ? add_attribute("checked", true, 1) : ""}> <div class="p-4 rounded-xl border-2 cursor-pointer transition-all peer-checked:border-spore-orange peer-checked:bg-spore-orange/10 border-spore-cream/30 hover:border-spore-cream/50"><div class="flex items-center justify-between"><div><p class="font-bold text-spore-dark text-lg">${escape(org.name)}</p> ${data.currentOrganization?.id === org.id ? `<p class="text-sm text-spore-orange font-medium mt-1" data-svelte-h="svelte-1yuemr6">Currently selected</p>` : ``}</div> <div class="w-5 h-5 rounded-full border-2 border-spore-cream/40 peer-checked:border-spore-orange peer-checked:bg-spore-orange flex items-center justify-center">${selectedOrg === org.id || data.currentOrganization?.id === org.id ? `<svg class="w-3 h-3 text-white" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>` : ``}</div> </div></div> </label>`;
      })}</div> <button type="submit" ${"disabled"} class="w-full bg-spore-forest text-white py-4 rounded-xl font-bold text-lg tracking-wide hover:bg-spore-forest/90 disabled:opacity-50 disabled:cursor-not-allowed transition-all transform active:scale-95 touch-manipulation">${`SWITCH TO ORGANIZATION`}</button></form>  ${data.organizations.length > 1 ? `<div class="mt-6 pt-6 border-t border-spore-cream/20"><p class="text-sm font-semibold text-spore-steel mb-3" data-svelte-h="svelte-dbfdx9">Quick switch:</p> <div class="grid grid-cols-2 gap-3">${each(data.organizations, (org) => {
        return `${org.id !== data.currentOrganization?.id ? `<form method="POST" class="contents"><input type="hidden" name="organizationId"${add_attribute("value", org.id, 0)}> <button type="submit" class="px-3 py-2 text-sm font-medium text-spore-dark bg-spore-cream/20 rounded-lg hover:bg-spore-cream/30 transition-colors touch-manipulation">${escape(org.name)}</button> </form>` : ``}`;
      })}</div></div>` : ``}` : ` <div class="text-center py-8"><svg class="w-16 h-16 mx-auto text-spore-steel/30 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 21V5a2 2 0 00-2-2H7a2 2 0 00-2 2v16m14 0h2m-2 0h-5m-9 0H3m2 0h5M9 7h1m-1 4h1m4-4h1m-1 4h1m-5 10v-5a1 1 0 011-1h2a1 1 0 011 1v5m-4 0h4"></path></svg> <p class="text-spore-steel font-semibold mb-2" data-svelte-h="svelte-1jef9o4">No organizations found</p> <p class="text-spore-steel/60 text-sm" data-svelte-h="svelte-yrkurc">You haven&#39;t joined any organizations yet</p> <a href="/onboarding" class="inline-flex items-center justify-center px-6 py-3 mt-4 bg-spore-forest text-white font-semibold rounded-xl hover:bg-spore-forest/90 transition-colors" data-svelte-h="svelte-6wzkcw">Create or Join Organization</a></div>`}</div>  <div class="mt-6 text-center"><form method="POST" action="/auth/logout"><button type="submit" class="text-spore-cream/60 hover:text-spore-cream/80 text-sm transition-colors" data-svelte-h="svelte-1t49qke">Sign out</button></form></div></div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/14.js
var __exports15 = {};
__export(__exports15, {
  component: () => component15,
  fonts: () => fonts15,
  imports: () => imports15,
  index: () => index15,
  server: () => page_server_ts_exports13,
  server_id: () => server_id14,
  stylesheets: () => stylesheets15
});
var index15, component_cache15, component15, server_id14, imports15, stylesheets15, fonts15;
var init__15 = __esm({
  ".svelte-kit/output/server/nodes/14.js"() {
    init_page_server_ts13();
    index15 = 14;
    component15 = async () => component_cache15 ??= (await Promise.resolve().then(() => (init_page_svelte13(), page_svelte_exports13))).default;
    server_id14 = "src/routes/select-organization/+page.server.ts";
    imports15 = ["_app/immutable/nodes/14.5f299f27.js", "_app/immutable/chunks/_page.e37169f7.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets15 = [];
    fonts15 = [];
  }
});

// .svelte-kit/output/server/entries/pages/sites/_page.server.ts.js
var page_server_ts_exports14 = {};
__export(page_server_ts_exports14, {
  actions: () => actions12,
  load: () => load14
});
var load14, actions12;
var init_page_server_ts14 = __esm({
  ".svelte-kit/output/server/entries/pages/sites/_page.server.ts.js"() {
    init_prisma();
    init_chunks();
    init_guards();
    init_audit();
    load14 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const organizationId = event.locals.user.organizationId ?? void 0;
      const search = event.url.searchParams.get("search") || "";
      const where = { organizationId };
      if (search) {
        where.name = {
          contains: search,
          mode: "insensitive"
        };
      }
      const sites = await prisma.site.findMany({
        where,
        orderBy: { createdAt: "desc" },
        include: {
          _count: {
            select: {
              Unit: true,
              Building: true,
              Asset: true
            }
          },
          Unit: {
            include: {
              _count: {
                select: { Asset: true }
              }
            }
          },
          Building: {
            include: {
              _count: {
                select: { Unit: true }
              }
            }
          }
        }
      });
      return { sites, search };
    };
    actions12 = {
      create: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const name = formData.get("name");
        if (!name || name.trim() === "") {
          return fail(400, { error: "Site name is required" });
        }
        const site = await prisma.site.create({
          data: {
            name: name.trim(),
            organizationId: event.locals.user.organizationId,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        await logAudit(event.locals.user.id, "SITE_CREATED", {
          siteId: site.id,
          name: site.name
        });
        return { success: true, site };
      },
      delete: async (event) => {
        if (!isManagerOrAbove(event)) {
          return fail(403, { error: "Permission denied. Only managers can delete sites." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const siteId = formData.get("siteId");
        if (!siteId) {
          return fail(400, { error: "Site ID is required" });
        }
        const site = await prisma.site.findUnique({
          where: { id: siteId },
          select: { name: true }
        });
        await prisma.site.delete({
          where: { id: siteId }
        });
        await logAudit(event.locals.user.id, "SITE_DELETED", {
          siteId,
          name: site?.name
        });
        return { success: true };
      },
      update: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const siteId = formData.get("siteId");
        const name = formData.get("name");
        if (!siteId) {
          return fail(400, { error: "Site ID is required" });
        }
        if (!name || name.trim() === "") {
          return fail(400, { error: "Site name is required" });
        }
        const site = await prisma.site.update({
          where: { id: siteId },
          data: { name: name.trim() }
        });
        return { success: true, site };
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/sites/_page.svelte.js
var page_svelte_exports14 = {};
__export(page_svelte_exports14, {
  default: () => Page14
});
var Page14;
var init_page_svelte14 = __esm({
  ".svelte-kit/output/server/entries/pages/sites/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page14 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let sites;
      let { data } = $$props;
      let editingSiteId = null;
      let editingSiteName = "";
      let searchTerm = data.search || "";
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      sites = data.sites || [];
      return `${$$result.head += `<!-- HEAD_svelte-w7e4y3_START -->${$$result.title = `<title>Sites \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-w7e4y3_END -->`, ""} <div class="max-w-7xl mx-auto px-4 py-10"> <div class="mb-10"><div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 mb-4"><div><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-19ed5sy">Sites</h1></div> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold tracking-wide">${escape("+ NEW SITE")}</button></div> <div class="flex flex-col sm:flex-row gap-4"><input type="text" placeholder="Search sites..." class="flex-1 max-w-md px-4 py-2 rounded-lg border border-spore-cream/30 bg-white text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", searchTerm, 0)}> ${searchTerm ? `<button class="text-sm font-semibold text-spore-cream/70 hover:text-spore-cream px-2" data-svelte-h="svelte-1k5n1zx">Clear</button>` : ``}</div></div>  ${``}  ${sites.length > 0 ? `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">${each(sites, (site) => {
        return `${editingSiteId === site.id ? ` <div class="bg-spore-white rounded-xl p-6 ring-2 ring-spore-orange"><form method="POST" action="?/update"><input type="hidden" name="siteId"${add_attribute("value", site.id, 0)}> <div class="mb-4"><input type="text" name="name" class="w-full px-4 py-3 rounded-lg border border-spore-orange bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange text-lg font-bold" required${add_attribute("value", editingSiteName, 0)}></div> <div class="flex gap-2"><button type="submit" ${!editingSiteName.trim() ? "disabled" : ""} class="flex-1 bg-spore-forest text-white px-4 py-2 rounded-lg font-bold text-sm hover:bg-spore-forest/90 disabled:opacity-50 transition-colors">${escape("SAVE")}</button> <button type="button" class="px-4 py-2 rounded-lg font-bold text-sm text-spore-steel hover:bg-spore-cream transition-colors" data-svelte-h="svelte-vhk55s">CANCEL</button> </div></form> </div>` : ` <div class="bg-spore-white rounded-xl p-6 hover:shadow-lg transition-all group relative"><a href="${"/sites/" + escape(site.id, true)}" class="absolute inset-0 z-0"></a> <div class="relative z-10 pointer-events-none"><div class="flex justify-between items-start mb-4"><div class="w-12 h-12 bg-spore-forest/10 rounded-xl flex items-center justify-center"><span class="text-2xl" data-svelte-h="svelte-1xnl04j">\u{1F3E2}</span></div> <div class="flex gap-2 pointer-events-auto"><button class="text-spore-steel/40 hover:text-spore-orange transition-colors opacity-0 group-hover:opacity-100" data-svelte-h="svelte-s97alz">\u270F\uFE0F</button> <form method="POST" action="?/delete"><input type="hidden" name="siteId"${add_attribute("value", site.id, 0)}> <button type="submit" class="text-spore-steel/40 hover:text-red-500 transition-colors opacity-0 group-hover:opacity-100" data-svelte-h="svelte-9vz145">\u2715
										</button></form> </div></div> <h3 class="text-lg font-bold text-spore-dark group-hover:text-spore-forest transition-colors">${escape(site.name)}</h3> <p class="text-sm text-spore-steel mt-1">${escape(site._count?.Building || 0)} building${escape(site._count?.Building !== 1 ? "s" : "")} \u2022 ${escape(site._count?.Unit || 0)} unit${escape(site._count?.Unit !== 1 ? "s" : "")}</p> <div class="mt-4 pt-4 border-t border-spore-cream/50"><span class="text-xs text-spore-steel">Created ${escape(new Date(site.createdAt).toLocaleDateString())}</span> </div></div> </div>`}`;
      })}</div>` : `<div class="text-center py-16 bg-spore-white rounded-xl"><div class="text-5xl mb-4" data-svelte-h="svelte-n08cxc">\u{1F3E2}</div> <h3 class="text-xl font-bold text-spore-dark mb-2" data-svelte-h="svelte-1r1pntd">No sites yet</h3> <p class="text-spore-steel mb-6" data-svelte-h="svelte-1itm7tw">Create your first site to get started</p> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold" data-svelte-h="svelte-1vkd0hb">+ CREATE SITE</button></div>`}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/15.js
var __exports16 = {};
__export(__exports16, {
  component: () => component16,
  fonts: () => fonts16,
  imports: () => imports16,
  index: () => index16,
  server: () => page_server_ts_exports14,
  server_id: () => server_id15,
  stylesheets: () => stylesheets16
});
var index16, component_cache16, component16, server_id15, imports16, stylesheets16, fonts16;
var init__16 = __esm({
  ".svelte-kit/output/server/nodes/15.js"() {
    init_page_server_ts14();
    index16 = 15;
    component16 = async () => component_cache16 ??= (await Promise.resolve().then(() => (init_page_svelte14(), page_svelte_exports14))).default;
    server_id15 = "src/routes/sites/+page.server.ts";
    imports16 = ["_app/immutable/chunks/15.650fc23d.js", "_app/immutable/chunks/_page.e1015e72.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets16 = [];
    fonts16 = [];
  }
});

// .svelte-kit/output/server/entries/pages/sites/_id_/_page.server.ts.js
var page_server_ts_exports15 = {};
__export(page_server_ts_exports15, {
  actions: () => actions13,
  load: () => load15
});
var load15, actions13;
var init_page_server_ts15 = __esm({
  ".svelte-kit/output/server/entries/pages/sites/_id_/_page.server.ts.js"() {
    init_prisma();
    init_chunks();
    init_guards();
    load15 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const { id } = event.params;
      const site = await prisma.site.findUnique({
        where: { id },
        include: {
          Building: {
            orderBy: { name: "asc" }
          },
          Unit: {
            orderBy: [
              { floor: "asc" },
              { roomNumber: "asc" }
            ],
            include: {
              _count: {
                select: { Asset: true }
              }
            }
          },
          _count: {
            select: {
              Building: true,
              Unit: true,
              Asset: true
            }
          }
        }
      });
      if (!site) {
        throw error(404, "Site not found");
      }
      const buildingsWithUnits = site.Building.map((building2) => ({
        id: building2.id,
        name: building2.name,
        description: building2.description,
        units: site.Unit.filter((u) => u.buildingId === building2.id)
      }));
      const unassignedUnits = site.Unit.filter((u) => !u.buildingId);
      return { site, buildingsWithUnits, unassignedUnits };
    };
    actions13 = {
      createUnit: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id: siteId } = event.params;
        const roomNumber = formData.get("roomNumber");
        const name = formData.get("name");
        const floor = formData.get("floor");
        const buildingId = formData.get("buildingId");
        if (!roomNumber || roomNumber.trim() === "") {
          return fail(400, { error: "Room number is required" });
        }
        if (buildingId) {
          const building2 = await prisma.building.findFirst({
            where: { id: buildingId, siteId }
          });
          if (!building2) {
            return fail(400, { error: "Invalid building" });
          }
        }
        const unit = await prisma.unit.create({
          data: {
            roomNumber: roomNumber.trim(),
            name: name?.trim() || null,
            floor: floor ? parseInt(floor) : null,
            siteId,
            buildingId: buildingId || null,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        return { success: true, unit };
      },
      updateSite: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id } = event.params;
        const name = formData.get("name");
        if (!name || name.trim() === "") {
          return fail(400, { error: "Site name is required" });
        }
        const site = await prisma.site.update({
          where: { id },
          data: { name: name.trim() }
        });
        return { success: true, site };
      },
      deleteUnit: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const unitId = formData.get("unitId");
        if (!unitId) {
          return fail(400, { error: "Unit ID is required" });
        }
        await prisma.unit.delete({
          where: { id: unitId }
        });
        return { success: true };
      },
      createBuilding: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id: siteId } = event.params;
        const name = formData.get("name");
        const description = formData.get("description");
        if (!name || name.trim() === "") {
          return fail(400, { error: "Building name is required" });
        }
        const building2 = await prisma.building.create({
          data: {
            name: name.trim(),
            description: description?.trim() || null,
            siteId,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        return { success: true, building: building2 };
      },
      updateBuilding: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id: siteId } = event.params;
        const buildingId = formData.get("buildingId");
        const name = formData.get("name");
        const description = formData.get("description");
        if (!buildingId) {
          return fail(400, { error: "Building ID is required" });
        }
        if (!name || name.trim() === "") {
          return fail(400, { error: "Building name is required" });
        }
        const existingBuilding = await prisma.building.findFirst({
          where: { id: buildingId, siteId }
        });
        if (!existingBuilding) {
          return fail(404, { error: "Building not found" });
        }
        const building2 = await prisma.building.update({
          where: { id: buildingId },
          data: {
            name: name.trim(),
            description: description?.trim() || null
          }
        });
        return { success: true, building: building2 };
      },
      deleteBuilding: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id: siteId } = event.params;
        const buildingId = formData.get("buildingId");
        if (!buildingId) {
          return fail(400, { error: "Building ID is required" });
        }
        const existingBuilding = await prisma.building.findFirst({
          where: { id: buildingId, siteId }
        });
        if (!existingBuilding) {
          return fail(404, { error: "Building not found" });
        }
        await prisma.unit.updateMany({
          where: { buildingId },
          data: { buildingId: null }
        });
        await prisma.building.delete({
          where: { id: buildingId }
        });
        return { success: true };
      },
      updateUnit: async (event) => {
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const unitId = formData.get("unitId");
        const roomNumber = formData.get("roomNumber");
        const name = formData.get("name");
        const floor = formData.get("floor");
        const buildingId = formData.get("buildingId");
        if (!unitId) {
          return fail(400, { error: "Unit ID is required" });
        }
        if (!roomNumber || roomNumber.trim() === "") {
          return fail(400, { error: "Room number is required" });
        }
        const existingUnit = await prisma.unit.findUnique({
          where: { id: unitId },
          select: { siteId: true }
        });
        if (!existingUnit || existingUnit.siteId !== event.params.id) {
          return fail(404, { error: "Unit not found" });
        }
        if (buildingId) {
          const building2 = await prisma.building.findFirst({
            where: { id: buildingId, siteId: event.params.id }
          });
          if (!building2) {
            return fail(400, { error: "Invalid building" });
          }
        }
        const unit = await prisma.unit.update({
          where: { id: unitId },
          data: {
            roomNumber: roomNumber.trim(),
            name: name?.trim() || null,
            floor: floor ? parseInt(floor) : null,
            buildingId: buildingId || null
          }
        });
        return { success: true, unit };
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/sites/_id_/_page.svelte.js
var page_svelte_exports15 = {};
__export(page_svelte_exports15, {
  default: () => Page15
});
var Page15;
var init_page_svelte15 = __esm({
  ".svelte-kit/output/server/entries/pages/sites/_id_/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    Page15 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let site;
      let buildingsWithUnits;
      let unassignedUnits;
      let allBuildings;
      let { data } = $$props;
      let editingUnitId = null;
      let editingUnit = { name: "", buildingId: "", floor: "" };
      let editingBuildingId = null;
      let editingBuilding = { name: "", description: "" };
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      site = data.site;
      buildingsWithUnits = data.buildingsWithUnits || [];
      unassignedUnits = data.unassignedUnits || [];
      allBuildings = site.Building || [];
      return `<div class="max-w-7xl mx-auto px-4 py-10"> <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 mb-10"><div><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight">${escape(site.name)}</h1> <p class="text-spore-cream/60 mt-2 text-sm font-medium">${escape(site._count?.units || 0)} unit${escape(site._count?.units !== 1 ? "s" : "")} \u2022 ${escape(site._count?.buildings || 0)} building${escape(site._count?.buildings !== 1 ? "s" : "")}</p></div> <div class="flex gap-3"><button class="bg-spore-steel text-white px-6 py-3 rounded-xl hover:bg-spore-steel/90 transition-colors text-sm font-bold tracking-wide">${escape("+ ADD BUILDING")}</button> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold tracking-wide">${escape("+ ADD UNIT")}</button></div></div>  ${``}  ${``}  ${buildingsWithUnits.length > 0 || unassignedUnits.length > 0 ? `<div class="space-y-8">${each(buildingsWithUnits, (building2) => {
        return `${editingBuildingId === building2.id ? ` <div class="bg-spore-white rounded-xl p-6 ring-2 ring-spore-steel"><form method="POST" action="?/updateBuilding" class="mb-6"><input type="hidden" name="buildingId"${add_attribute("value", building2.id, 0)}> <div class="flex gap-4 items-end"><div class="flex-1"><label class="block text-sm font-medium text-spore-dark mb-1" data-svelte-h="svelte-dal9dr">Building Name</label> <input type="text" name="name" placeholder="Building name" class="w-full px-4 py-3 rounded-lg border border-spore-steel bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-steel font-bold" required${add_attribute("value", editingBuilding.name, 0)}></div> <div class="flex-1"><label class="block text-sm font-medium text-spore-dark mb-1" data-svelte-h="svelte-1mfkp1c">Description</label> <input type="text" name="description" placeholder="Description (optional)" class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-steel"${add_attribute("value", editingBuilding.description, 0)}></div> <div class="flex gap-2"><button type="submit" ${!editingBuilding.name.trim() ? "disabled" : ""} class="bg-spore-forest text-white px-4 py-3 rounded-lg font-bold text-sm hover:bg-spore-forest/90 disabled:opacity-50 transition-colors">${escape("SAVE")}</button> <button type="button" class="px-4 py-3 rounded-lg font-bold text-sm text-spore-steel hover:bg-spore-cream transition-colors" data-svelte-h="svelte-ze24xl">CANCEL
									</button></div> </div></form> </div>` : ` <div class="bg-spore-white rounded-xl overflow-hidden"> <div class="bg-spore-dark px-6 py-4 flex justify-between items-center"><div><h2 class="text-lg font-bold text-spore-cream">${escape(building2.name)}</h2> <p class="text-spore-cream/60 text-sm">${escape(building2.units.length)} unit${escape(building2.units.length !== 1 ? "s" : "")} </p></div> <div class="flex gap-2"><button class="text-spore-cream/60 hover:text-spore-orange transition-colors" aria-label="${"Edit " + escape(building2.name, true)}">\u270F\uFE0F</button> <form method="POST" action="?/deleteBuilding"><input type="hidden" name="buildingId"${add_attribute("value", building2.id, 0)}> <button type="submit" class="text-spore-cream/60 hover:text-red-400 transition-colors" aria-label="${"Delete " + escape(building2.name, true)}">\u2715
									</button></form> </div></div>  ${building2.units.length > 0 ? `<div class="p-6"><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">${each(building2.units, (unit) => {
          let isEditing = editingUnitId === unit.id;
          return ` ${isEditing ? ` <div class="bg-spore-cream/20 rounded-lg p-4 border-2 border-spore-orange"><form method="POST" action="?/updateUnit"><input type="hidden" name="unitId"${add_attribute("value", unit.id, 0)}> <div class="space-y-3"><input type="text" name="roomNumber" placeholder="Unit name" class="w-full px-3 py-2 rounded border border-spore-cream bg-white text-spore-dark text-sm focus:outline-none focus:ring-2 focus:ring-spore-orange" required${add_attribute("value", editingUnit.name, 0)}> <div class="grid grid-cols-2 gap-2"><select name="buildingId" class="px-3 py-2 rounded border border-spore-cream bg-white text-spore-dark text-sm focus:outline-none focus:ring-2 focus:ring-spore-orange"><option value="" data-svelte-h="svelte-nkh85j">Unassigned</option>${each(allBuildings, (b) => {
            return `<option${add_attribute("value", b.id, 0)}>${escape(b.name)}</option>`;
          })}</select> <input type="number" name="floor" placeholder="Floor" class="px-3 py-2 rounded border border-spore-cream bg-white text-spore-dark text-sm focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", editingUnit.floor, 0)}></div> <div class="flex gap-2"><button type="submit" ${!editingUnit.name.trim() ? "disabled" : ""} class="flex-1 bg-spore-forest text-white px-3 py-2 rounded font-bold text-xs hover:bg-spore-forest/90 disabled:opacity-50 transition-colors">${escape("SAVE")}</button> <button type="button" class="px-3 py-2 rounded font-bold text-xs text-spore-steel hover:bg-spore-cream transition-colors" data-svelte-h="svelte-9fkin8">CANCEL
															</button></div> </div></form> </div>` : ` <div class="bg-spore-cream/20 rounded-lg p-4 border border-spore-cream/50 group hover:border-spore-orange/50 transition-colors"><div class="flex justify-between items-start"><div><h3 class="font-bold text-spore-dark">${escape(unit.name || unit.roomNumber)}</h3> <p class="text-sm text-spore-steel mt-1">${unit.floor ? `Floor ${escape(unit.floor)}` : ``} ${unit._count?.assets ? `<span class="ml-2">\u2022 ${escape(unit._count.assets)} asset${escape(unit._count.assets !== 1 ? "s" : "")}</span>` : ``} </p></div> <div class="flex gap-2"><button class="text-spore-steel/40 hover:text-spore-orange transition-colors opacity-0 group-hover:opacity-100" data-svelte-h="svelte-xbha6c">\u270F\uFE0F</button> <form method="POST" action="?/deleteUnit"><input type="hidden" name="unitId"${add_attribute("value", unit.id, 0)}> <button type="submit" class="text-spore-steel/40 hover:text-red-500 transition-colors opacity-0 group-hover:opacity-100" data-svelte-h="svelte-3v0zhq">\u2715
															</button></form> </div></div> <div class="mt-4 pt-3 border-t border-spore-cream/50"><a href="${"/assets?unit=" + escape(unit.id, true)}" class="text-xs font-semibold text-spore-orange hover:text-spore-orange/80">View Assets \u2192
													</a></div> </div>`}`;
        })}</div> </div>` : `<div class="p-8 text-center"><p class="text-spore-steel text-sm" data-svelte-h="svelte-78k5a5">No units in this building yet</p> </div>`} </div>`}`;
      })}  ${unassignedUnits.length > 0 ? `<div class="bg-spore-white rounded-xl overflow-hidden"><div class="bg-spore-cream/50 px-6 py-4"><h2 class="text-lg font-bold text-spore-cream" data-svelte-h="svelte-17hh07w">Unassigned Units</h2> <p class="text-spore-cream/60 text-sm">${escape(unassignedUnits.length)} unit${escape(unassignedUnits.length !== 1 ? "s" : "")}</p></div> <div class="p-6"><div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">${each(unassignedUnits, (unit) => {
        return `${editingUnitId === unit.id ? ` <div class="bg-spore-cream/20 rounded-lg p-4 border-2 border-spore-orange"><form method="POST" action="?/updateUnit"><input type="hidden" name="unitId"${add_attribute("value", unit.id, 0)}> <div class="space-y-3"><input type="text" name="roomNumber" placeholder="Unit name" class="w-full px-3 py-2 rounded border border-spore-cream bg-white text-spore-dark text-sm focus:outline-none focus:ring-2 focus:ring-spore-orange" required${add_attribute("value", editingUnit.name, 0)}> <div class="grid grid-cols-2 gap-2"><select name="buildingId" class="px-3 py-2 rounded border border-spore-cream bg-white text-spore-dark text-sm focus:outline-none focus:ring-2 focus:ring-spore-orange"><option value="" data-svelte-h="svelte-nkh85j">Unassigned</option>${each(allBuildings, (b) => {
          return `<option${add_attribute("value", b.id, 0)}>${escape(b.name)}</option>`;
        })}</select> <input type="number" name="floor" placeholder="Floor" class="px-3 py-2 rounded border border-spore-cream bg-white text-spore-dark text-sm focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", editingUnit.floor, 0)}></div> <div class="flex gap-2"><button type="submit" ${!editingUnit.name.trim() ? "disabled" : ""} class="flex-1 bg-spore-forest text-white px-3 py-2 rounded font-bold text-xs hover:bg-spore-forest/90 disabled:opacity-50 transition-colors">${escape("SAVE")}</button> <button type="button" class="px-3 py-2 rounded font-bold text-xs text-spore-steel hover:bg-spore-cream transition-colors" data-svelte-h="svelte-9mmxtg">CANCEL
													</button></div> </div></form> </div>` : ` <div class="bg-spore-cream/20 rounded-lg p-4 border border-spore-cream/50 group hover:border-spore-orange/50 transition-colors"><div class="flex justify-between items-start"><div><h3 class="font-bold text-spore-dark">${escape(unit.name || unit.roomNumber)}</h3> <p class="text-sm text-spore-steel mt-1">${unit.floor ? `Floor ${escape(unit.floor)}` : ``} ${unit._count?.assets ? `<span class="ml-2">\u2022 ${escape(unit._count.assets)} asset${escape(unit._count.assets !== 1 ? "s" : "")}</span>` : ``} </p></div> <div class="flex gap-2"><button class="text-spore-steel/40 hover:text-spore-orange transition-colors opacity-0 group-hover:opacity-100" data-svelte-h="svelte-rvh0p6">\u270F\uFE0F</button> <form method="POST" action="?/deleteUnit"><input type="hidden" name="unitId"${add_attribute("value", unit.id, 0)}> <button type="submit" class="text-spore-steel/40 hover:text-red-500 transition-colors opacity-0 group-hover:opacity-100" data-svelte-h="svelte-40zcaq">\u2715
													</button></form> </div></div> <div class="mt-4 pt-3 border-t border-spore-cream/50"><a href="${"/assets?unit=" + escape(unit.id, true)}" class="text-xs font-semibold text-spore-orange hover:text-spore-orange/80">View Assets \u2192
											</a></div> </div>`}`;
      })}</div></div></div>` : ``}</div>` : `<div class="text-center py-16 bg-spore-white rounded-xl"><div class="text-5xl mb-4" data-svelte-h="svelte-n08cxc">\u{1F3E2}</div> <h3 class="text-xl font-bold text-spore-dark mb-2" data-svelte-h="svelte-1c0awzq">No buildings or units yet</h3> <p class="text-spore-steel mb-6" data-svelte-h="svelte-33yep1">Add a building to start organizing your site</p> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold" data-svelte-h="svelte-1cfi1x1">+ ADD BUILDING</button></div>`}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/16.js
var __exports17 = {};
__export(__exports17, {
  component: () => component17,
  fonts: () => fonts17,
  imports: () => imports17,
  index: () => index17,
  server: () => page_server_ts_exports15,
  server_id: () => server_id16,
  stylesheets: () => stylesheets17
});
var index17, component_cache17, component17, server_id16, imports17, stylesheets17, fonts17;
var init__17 = __esm({
  ".svelte-kit/output/server/nodes/16.js"() {
    init_page_server_ts15();
    index17 = 16;
    component17 = async () => component_cache17 ??= (await Promise.resolve().then(() => (init_page_svelte15(), page_svelte_exports15))).default;
    server_id16 = "src/routes/sites/[id]/+page.server.ts";
    imports17 = ["_app/immutable/chunks/16.3b60b98b.js", "_app/immutable/chunks/_page.130a976f.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js"];
    stylesheets17 = [];
    fonts17 = [];
  }
});

// .svelte-kit/output/server/entries/pages/templates/_page.server.ts.js
var page_server_ts_exports16 = {};
__export(page_server_ts_exports16, {
  actions: () => actions14,
  load: () => load16
});
var load16, actions14;
var init_page_server_ts16 = __esm({
  ".svelte-kit/output/server/entries/pages/templates/_page.server.ts.js"() {
    init_prisma();
    init_guards();
    init_chunks();
    init_constants2();
    init_security();
    init_templates();
    init_validation();
    load16 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      event.locals.user.id;
      const organizationId = event.locals.user.organizationId;
      if (!organizationId) {
        throw error(400, "Organization required");
      }
      const search = event.url.searchParams.get("search");
      const showInactive = event.url.searchParams.get("inactive") === "true";
      const templates = await queryTemplates(prisma, {
        organizationId,
        isActive: showInactive ? void 0 : true,
        search: search || void 0
      });
      return {
        templates,
        search,
        showInactive
      };
    };
    actions14 = {
      /**
       * Create a new template
       */
      create: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "template_create", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const userId = event.locals.user?.id;
        const organizationId = event.locals.user?.organizationId;
        if (!userId || !organizationId) {
          return fail(401, { error: "Authentication required." });
        }
        const data = await event.request.formData();
        const itemsData = data.get("items");
        let items = [];
        try {
          items = JSON.parse(itemsData);
          if (!Array.isArray(items) || items.length === 0) {
            return fail(400, { error: "At least one checklist item is required." });
          }
        } catch {
          return fail(400, { error: "Invalid checklist items format." });
        }
        const validationResult = workOrderTemplateSchema.safeParse({
          name: data.get("name"),
          description: data.get("description") || void 0,
          title: data.get("title") || void 0,
          workDescription: data.get("workDescription") || void 0,
          priority: data.get("priority") || DEFAULT_PRIORITY,
          isGlobal: data.get("isGlobal") === "true",
          items
        });
        if (!validationResult.success) {
          const firstError = validationResult.error.issues[0];
          return fail(400, { error: firstError?.message || "Validation failed." });
        }
        return createTemplate(event, prisma, validationResult.data, userId, organizationId);
      },
      /**
       * Delete (soft delete) a template
       */
      delete: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "template_delete", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const userId = event.locals.user?.id;
        const organizationId = event.locals.user?.organizationId;
        if (!userId || !organizationId) {
          return fail(401, { error: "Authentication required." });
        }
        const data = await event.request.formData();
        const templateId = data.get("templateId");
        if (!templateId) {
          return fail(400, { error: "Template ID is required." });
        }
        return deleteTemplate(event, prisma, templateId, userId, organizationId);
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/templates/_page.svelte.js
var page_svelte_exports16 = {};
__export(page_svelte_exports16, {
  default: () => Page16
});
var css, Page16;
var init_page_svelte16 = __esm({
  ".svelte-kit/output/server/entries/pages/templates/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    init_constants2();
    css = {
      code: ".line-clamp-1.s-Osc4856uyo_8{display:-webkit-box;-webkit-line-clamp:1;-webkit-box-orient:vertical;overflow:hidden}.line-clamp-2.s-Osc4856uyo_8{display:-webkit-box;-webkit-line-clamp:2;-webkit-box-orient:vertical;overflow:hidden}.truncate.s-Osc4856uyo_8{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}",
      map: null
    };
    Page16 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      let templates = data.templates || [];
      let searchValue = data.search || "";
      let showInactive = data.showInactive || false;
      let showCreateForm = false;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      $$result.css.add(css);
      {
        if (data.templates)
          templates = data.templates;
      }
      return `${$$result.head += `<!-- HEAD_svelte-1emetuj_START -->${$$result.title = `<title>Work Order Templates \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-1emetuj_END -->`, ""} <div class="max-w-7xl mx-auto px-4 py-10"> <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 mb-6"><div><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-1txcgrr">Work Order Templates</h1> <p class="text-spore-cream/70 mt-2" data-svelte-h="svelte-72e3fu">Create reusable templates for common work orders</p></div> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:ring-offset-2 focus:ring-offset-spore-steel transition-colors text-sm font-bold tracking-wide shadow-lg"${add_attribute("aria-expanded", showCreateForm, 0)}>+ NEW TEMPLATE</button></div>  <div class="bg-spore-white rounded-xl p-4 mb-6 border border-spore-cream/50"><div class="flex flex-col sm:flex-row gap-4"><div class="flex-1"><label for="template-search" class="sr-only" data-svelte-h="svelte-10fsp6r">Search templates</label> <input type="text" id="template-search" placeholder="Search templates..." class="w-full px-4 py-2 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark placeholder-spore-steel/50 focus:outline-none focus:ring-2 focus:ring-spore-orange"${add_attribute("value", searchValue, 0)}></div> <div class="flex gap-3"><button class="px-4 py-2 bg-spore-dark text-white rounded-lg hover:bg-spore-dark/90 focus:outline-none focus:ring-2 focus:ring-spore-dark transition-colors font-medium text-sm" data-svelte-h="svelte-1e5hvda">Search</button> <button class="px-4 py-2 bg-spore-cream/20 text-spore-steel rounded-lg hover:bg-spore-cream/30 focus:outline-none focus:ring-2 focus:ring-spore-cream transition-colors font-medium text-sm" data-svelte-h="svelte-1jxxha5">Reset</button> <button class="${"px-4 py-2 rounded-lg font-medium text-sm transition-colors " + escape(
        showInactive ? "bg-spore-orange text-white" : "bg-spore-cream/20 text-spore-steel hover:bg-spore-cream/30",
        true
      )}">${escape(showInactive ? "All" : "Active")}</button></div></div></div>  ${``}  ${templates && templates.length > 0 ? `<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">${each(templates, (template) => {
        return `<article class="bg-white rounded-xl shadow-sm border border-spore-cream/50 hover:shadow-md transition-shadow overflow-hidden"> <div class="px-5 py-4 border-b border-spore-cream/50"><div class="flex items-start justify-between gap-2"><h3 class="font-bold text-lg text-spore-dark line-clamp-1 s-Osc4856uyo_8">${escape(template.name)}</h3> <div class="flex gap-1 shrink-0">${template.isGlobal ? `<span class="px-2 py-0.5 text-xs font-semibold rounded-full bg-purple-100 text-purple-700" title="Global template" data-svelte-h="svelte-1taoxi1">Global
									</span>` : ``} <span class="${"px-2 py-0.5 text-xs font-semibold rounded-full " + escape(WORK_ORDER_PRIORITY_COLORS[template.priority], true) + " s-Osc4856uyo_8"}">${escape(template.priority)}</span> </div></div> ${template.description ? `<p class="text-sm text-spore-steel mt-1 line-clamp-2 s-Osc4856uyo_8">${escape(template.description)}</p>` : ``}</div>  <div class="px-5 py-4"><div class="flex items-center justify-between text-sm"><span class="text-spore-steel">${escape(template._itemCount || 0)} ${escape(template._itemCount === 1 ? "item" : "items")}</span> <span class="text-spore-steel">Used ${escape(template.usageCount)} ${escape(template.usageCount === 1 ? "time" : "times")} </span></div>  ${template.TemplateItems && template.TemplateItems.length > 0 ? `<ul class="mt-3 space-y-1">${each(template.TemplateItems.slice(0, 3), (item) => {
          return `<li class="text-sm text-spore-steel flex items-center gap-2"><span class="w-1.5 h-1.5 rounded-full bg-spore-cream" aria-hidden="true"></span> <span class="truncate s-Osc4856uyo_8">${escape(item.title)}</span> </li>`;
        })} ${template.TemplateItems.length > 3 ? `<li class="text-sm text-spore-steel italic">+${escape(template.TemplateItems.length - 3)} more items
									</li>` : ``} </ul>` : ``}</div>  <div class="px-5 py-3 bg-spore-cream/10 border-t border-spore-cream/50 flex justify-between items-center"><a href="${"/templates/" + escape(template.id, true)}" class="text-sm font-medium text-spore-orange hover:text-spore-orange/80 focus:outline-none focus:underline">View Details</a> <form method="POST" action="?/delete" class="inline"><input type="hidden" name="templateId"${add_attribute("value", template.id, 0)}> <button type="submit" class="text-sm text-red-500 hover:text-red-700 focus:outline-none focus:underline" onclick="return confirm('Are you sure you want to delete this template?')" data-svelte-h="svelte-og4i1n">Delete</button> </form></div> </article>`;
      })}</div>` : ` <div class="text-center py-16 bg-white rounded-xl" role="status"><div class="text-5xl mb-4" aria-hidden="true" data-svelte-h="svelte-idje0l">\u{1F4CB}</div> <h3 class="text-xl font-bold text-spore-dark mb-2" data-svelte-h="svelte-10lu0ts">No templates yet</h3> <p class="text-spore-steel mb-6" data-svelte-h="svelte-1qrwo84">Create your first template to speed up work order creation</p> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:ring-offset-2 transition-colors text-sm font-bold" data-svelte-h="svelte-m2x7vk">+ CREATE TEMPLATE</button></div>`} </div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/17.js
var __exports18 = {};
__export(__exports18, {
  component: () => component18,
  fonts: () => fonts18,
  imports: () => imports18,
  index: () => index18,
  server: () => page_server_ts_exports16,
  server_id: () => server_id17,
  stylesheets: () => stylesheets18
});
var index18, component_cache18, component18, server_id17, imports18, stylesheets18, fonts18;
var init__18 = __esm({
  ".svelte-kit/output/server/nodes/17.js"() {
    init_page_server_ts16();
    index18 = 17;
    component18 = async () => component_cache18 ??= (await Promise.resolve().then(() => (init_page_svelte16(), page_svelte_exports16))).default;
    server_id17 = "src/routes/templates/+page.server.ts";
    imports18 = ["_app/immutable/nodes/17.1a1f92a3.js", "_app/immutable/chunks/_page.2252b26e.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/stores.e6b76d1c.js", "_app/immutable/chunks/constants.cc7bddc0.js"];
    stylesheets18 = ["_app/immutable/assets/_page.b74b4820.css"];
    fonts18 = [];
  }
});

// .svelte-kit/output/server/entries/pages/templates/_id_/_page.server.ts.js
var page_server_ts_exports17 = {};
__export(page_server_ts_exports17, {
  actions: () => actions15,
  load: () => load17
});
var load17, actions15;
var init_page_server_ts17 = __esm({
  ".svelte-kit/output/server/entries/pages/templates/_id_/_page.server.ts.js"() {
    init_prisma();
    init_guards();
    init_chunks();
    init_security();
    init_templates();
    init_validation();
    load17 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const userId = event.locals.user.id;
      const organizationId = event.locals.user.organizationId;
      if (!organizationId) {
        throw error(400, "Organization required");
      }
      const templateId = event.params.id;
      const template = await getTemplateById(prisma, templateId, organizationId, userId);
      if ("status" in template) {
        if (template.status === 404) {
          throw error(404, "Template not found");
        }
        if (template.status === 403) {
          throw error(403, "You do not have access to this template");
        }
        throw error(500, "Failed to load template");
      }
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: { role: true }
      });
      return {
        template,
        userRole: user?.role || "TECHNICIAN"
      };
    };
    actions15 = {
      /**
       * Update template
       */
      update: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "template_update", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const userId = event.locals.user?.id;
        const organizationId = event.locals.user?.organizationId;
        if (!userId || !organizationId) {
          return fail(401, { error: "Authentication required." });
        }
        const templateId = event.params.id;
        const data = await event.request.formData();
        const itemsData = data.get("items");
        let items = [];
        try {
          items = JSON.parse(itemsData);
        } catch {
          return fail(400, { error: "Invalid checklist items format." });
        }
        const updateData = {};
        const name = data.get("name");
        const description = data.get("description");
        const title = data.get("title");
        const workDescription = data.get("workDescription");
        const priority = data.get("priority");
        if (name !== null)
          updateData.name = name;
        if (description !== null)
          updateData.description = description;
        if (title !== null)
          updateData.title = title;
        if (workDescription !== null)
          updateData.workDescription = workDescription;
        if (priority !== null)
          updateData.priority = priority;
        if (items.length > 0)
          updateData.items = items;
        const validationResult = workOrderTemplateUpdateSchema.safeParse(updateData);
        if (!validationResult.success) {
          const firstError = validationResult.error.issues[0];
          return fail(400, { error: firstError?.message || "Validation failed." });
        }
        return updateTemplate(
          event,
          prisma,
          templateId,
          validationResult.data,
          userId,
          organizationId
        );
      },
      /**
       * Delete template
       */
      delete: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "template_delete", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const userId = event.locals.user?.id;
        const organizationId = event.locals.user?.organizationId;
        if (!userId || !organizationId) {
          return fail(401, { error: "Authentication required." });
        }
        const templateId = event.params.id;
        const result = await deleteTemplate(event, prisma, templateId, userId, organizationId);
        if ("success" in result) {
          throw redirect(303, "/templates");
        }
        return result;
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/templates/_id_/_page.svelte.js
var page_svelte_exports17 = {};
__export(page_svelte_exports17, {
  default: () => Page17
});
var Page17;
var init_page_svelte17 = __esm({
  ".svelte-kit/output/server/entries/pages/templates/_id_/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    init_constants2();
    Page17 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      let template = data.template;
      let userRole = data.userRole;
      let isEditing = false;
      ({
        name: template.name || "",
        description: template.description || "",
        title: template.title || "",
        workDescription: template.workDescription || "",
        priority: template.priority || "MEDIUM",
        items: template.TemplateItems ? [...template.TemplateItems.map((i) => ({ title: i.title }))] : [{ title: "" }]
      });
      const canEdit = userRole === "MANAGER" || userRole === "ADMIN";
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      return `${$$result.head += `<!-- HEAD_svelte-1kh6yx6_START -->${$$result.title = `<title>${escape(template.name)} \u2014 Template \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-1kh6yx6_END -->`, ""} <div class="max-w-5xl mx-auto px-4 py-10"> <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 mb-6"><div class="flex items-center gap-3"><a href="/templates" class="text-spore-steel hover:text-spore-dark focus:outline-none focus:underline"><svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg></a> <div><h1 class="text-3xl font-extrabold text-spore-cream tracking-tight">${escape(template.name)}</h1> <div class="flex items-center gap-2 mt-1">${template.isGlobal ? `<span class="px-2 py-0.5 text-xs font-semibold rounded-full bg-purple-100 text-purple-700" data-svelte-h="svelte-j3a2pq">Global Template</span>` : ``} <span class="text-sm text-spore-cream/70">Used ${escape(template.usageCount)} ${escape(template.usageCount === 1 ? "time" : "times")}</span></div></div></div> <div class="flex gap-3">${canEdit && !isEditing ? `<button class="px-4 py-2 bg-spore-cream/20 text-spore-dark rounded-lg hover:bg-spore-cream/30 focus:outline-none focus:ring-2 focus:ring-spore-cream transition-colors font-medium text-sm" data-svelte-h="svelte-1mcorov">Edit Template</button>` : ``} <form method="POST" action="?/delete"><input type="hidden" name="templateId"${add_attribute("value", template.id, 0)}> <button type="submit" class="px-4 py-2 bg-red-100 text-red-700 rounded-lg hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500 transition-colors font-medium text-sm" onclick="return confirm('Are you sure you want to delete this template?')" data-svelte-h="svelte-1vrmtqj">Delete</button></form></div></div> ${` <div class="grid grid-cols-1 lg:grid-cols-3 gap-6"> <div class="lg:col-span-2 space-y-6"> ${template.description ? `<div class="bg-white rounded-xl shadow-sm border border-spore-cream/50 p-6"><h2 class="text-sm font-bold text-spore-steel uppercase tracking-wide mb-3" data-svelte-h="svelte-szjavg">Description</h2> <p class="text-spore-dark">${escape(template.description)}</p></div>` : ``}  <div class="bg-white rounded-xl shadow-sm border border-spore-cream/50 p-6"><h2 class="text-sm font-bold text-spore-steel uppercase tracking-wide mb-4">Checklist Items (${escape(template.TemplateItems?.length || 0)})</h2> ${template.TemplateItems && template.TemplateItems.length > 0 ? `<ul class="space-y-3">${each(template.TemplateItems, (item, index24) => {
        return `<li class="flex items-start gap-3 p-3 bg-spore-cream/10 rounded-lg"><span class="flex items-center justify-center w-6 h-6 rounded-full bg-spore-orange text-white text-xs font-bold shrink-0">${escape(index24 + 1)}</span> <span class="text-spore-dark font-medium">${escape(item.title)}</span> </li>`;
      })}</ul>` : `<p class="text-spore-steel italic" data-svelte-h="svelte-fsqtck">No checklist items defined.</p>`}</div>  ${template.title || template.workDescription ? `<div class="bg-white rounded-xl shadow-sm border border-spore-cream/50 p-6"><h2 class="text-sm font-bold text-spore-steel uppercase tracking-wide mb-4" data-svelte-h="svelte-1ugu1f0">Default Work Order Content</h2> ${template.title ? `<div class="mb-3"><span class="text-xs font-medium text-spore-steel uppercase" data-svelte-h="svelte-gdtgec">Title</span> <p class="text-spore-dark font-medium">${escape(template.title)}</p></div>` : ``} ${template.workDescription ? `<div><span class="text-xs font-medium text-spore-steel uppercase" data-svelte-h="svelte-1m9h140">Description</span> <p class="text-spore-dark whitespace-pre-wrap">${escape(template.workDescription)}</p></div>` : ``}</div>` : ``}</div>  <div class="space-y-6"> <div class="bg-white rounded-xl shadow-sm border border-spore-cream/50 p-6"><h2 class="text-sm font-bold text-spore-steel uppercase tracking-wide mb-3" data-svelte-h="svelte-b0rqqq">Priority</h2> <span class="${"inline-flex px-3 py-1 text-sm font-semibold rounded-full " + escape(WORK_ORDER_PRIORITY_COLORS[template.priority], true)}">${escape(template.priority)}</span></div>  <div class="bg-white rounded-xl shadow-sm border border-spore-cream/50 p-6"><h2 class="text-sm font-bold text-spore-steel uppercase tracking-wide mb-3" data-svelte-h="svelte-17fvql6">Details</h2> <dl class="space-y-3 text-sm"><div class="flex justify-between"><dt class="text-spore-steel" data-svelte-h="svelte-1q77piq">Items</dt> <dd class="text-spore-dark font-medium">${escape(template._itemCount || 0)}</dd> </div><div class="flex justify-between"><dt class="text-spore-steel" data-svelte-h="svelte-2gemp">Used</dt> <dd class="text-spore-dark font-medium">${escape(template.usageCount)}x</dd> </div><div class="flex justify-between"><dt class="text-spore-steel" data-svelte-h="svelte-zpks9u">Scope</dt> <dd class="text-spore-dark font-medium">${template.isGlobal ? `<span class="text-purple-600" data-svelte-h="svelte-1f77bkx">Global</span>` : `Organization`}</dd> </div><div class="flex justify-between"><dt class="text-spore-steel" data-svelte-h="svelte-5j5g0g">Status</dt> <dd class="text-spore-dark font-medium">${template.isActive ? `<span class="text-green-600" data-svelte-h="svelte-nbs9x">Active</span>` : `<span class="text-red-600" data-svelte-h="svelte-1p8ecko">Inactive</span>`}</dd> </div><div class="flex justify-between"><dt class="text-spore-steel" data-svelte-h="svelte-1uzijy2">Created</dt> <dd class="text-spore-dark font-medium">${escape(new Date(template.createdAt).toLocaleDateString())}</dd></div></dl></div>  <a href="${"/work-orders?template=" + escape(template.id, true)}" class="block w-full text-center bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:ring-offset-2 transition-colors text-sm font-bold tracking-wide shadow-lg">Use This Template</a></div></div>`}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/18.js
var __exports19 = {};
__export(__exports19, {
  component: () => component19,
  fonts: () => fonts19,
  imports: () => imports19,
  index: () => index19,
  server: () => page_server_ts_exports17,
  server_id: () => server_id18,
  stylesheets: () => stylesheets19
});
var index19, component_cache19, component19, server_id18, imports19, stylesheets19, fonts19;
var init__19 = __esm({
  ".svelte-kit/output/server/nodes/18.js"() {
    init_page_server_ts17();
    index19 = 18;
    component19 = async () => component_cache19 ??= (await Promise.resolve().then(() => (init_page_svelte17(), page_svelte_exports17))).default;
    server_id18 = "src/routes/templates/[id]/+page.server.ts";
    imports19 = ["_app/immutable/chunks/18.3cc46594.js", "_app/immutable/chunks/_page.45132f49.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/constants.cc7bddc0.js"];
    stylesheets19 = [];
    fonts19 = [];
  }
});

// .svelte-kit/output/server/entries/pages/users/_page.server.ts.js
var page_server_ts_exports18 = {};
__export(page_server_ts_exports18, {
  actions: () => actions16,
  load: () => load18
});
var load18, actions16;
var init_page_server_ts18 = __esm({
  ".svelte-kit/output/server/entries/pages/users/_page.server.ts.js"() {
    init_prisma();
    init_auth();
    init_chunks();
    init_audit();
    load18 = async (event) => {
      const { locals, url: url2 } = event;
      if (!locals.user || !canManageUsers(locals.user.role)) {
        throw error(403, "Access denied. Admin privileges required.");
      }
      const prisma = await createRequestPrisma(event);
      const organizationId = locals.user.organizationId;
      const search = url2.searchParams.get("search")?.trim();
      const roleFilter = url2.searchParams.get("role");
      const statusFilter = url2.searchParams.get("status");
      const sort = url2.searchParams.get("sort") || "name";
      const where = { organizationId };
      if (roleFilter) {
        where.role = roleFilter;
      }
      if (statusFilter === "active") {
        where.isActive = true;
      } else if (statusFilter === "inactive") {
        where.isActive = false;
      }
      if (search) {
        where.OR = [
          { email: { contains: search, mode: "insensitive" } },
          { firstName: { contains: search, mode: "insensitive" } },
          { lastName: { contains: search, mode: "insensitive" } }
        ];
      }
      let orderBy = {};
      switch (sort) {
        case "name":
          orderBy = [{ firstName: "asc" }, { lastName: "asc" }];
          break;
        case "email":
          orderBy = { email: "asc" };
          break;
        case "role":
          orderBy = { role: "asc" };
          break;
        case "joined":
          orderBy = { createdAt: "desc" };
          break;
        case "updated":
          orderBy = { updatedAt: "desc" };
          break;
        default:
          orderBy = [{ firstName: "asc" }, { lastName: "asc" }];
      }
      const users = await prisma.user.findMany({
        where,
        orderBy,
        select: {
          id: true,
          email: true,
          firstName: true,
          lastName: true,
          role: true,
          isActive: true,
          createdAt: true,
          updatedAt: true
        }
      });
      return { users };
    };
    actions16 = {
      create: async (event) => {
        const { locals, request } = event;
        if (!locals.user || !canManageUsers(locals.user.role)) {
          return fail(403, { error: "Access denied" });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await request.formData();
        const email3 = formData.get("email");
        const firstName = formData.get("firstName");
        const lastName = formData.get("lastName");
        const role = formData.get("role");
        const password = formData.get("password");
        if (!email3?.trim()) {
          return fail(400, { error: "Email is required" });
        }
        if (!password || password.length < 8) {
          return fail(400, { error: "Password must be at least 8 characters" });
        }
        if (!["ADMIN", "MANAGER", "TECHNICIAN"].includes(role)) {
          return fail(400, { error: "Invalid role" });
        }
        const existing = await prisma.user.findUnique({
          where: { email: email3.toLowerCase().trim() }
        });
        if (existing) {
          return fail(400, { error: "Email already in use" });
        }
        const hashedPassword = await hashPassword(password);
        const newUser = await prisma.user.create({
          data: {
            email: email3.toLowerCase().trim(),
            password: hashedPassword,
            firstName: firstName?.trim() || null,
            lastName: lastName?.trim() || null,
            role,
            organizationId: locals.user.organizationId,
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        await logAudit(locals.user.id, "USER_CREATED", {
          newUserId: newUser.id,
          email: newUser.email,
          role
        });
        return { success: true };
      },
      updateRole: async (event) => {
        const { locals, request } = event;
        if (!locals.user || !canManageUsers(locals.user.role)) {
          return fail(403, { error: "Access denied" });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await request.formData();
        const userId = formData.get("userId");
        const role = formData.get("role");
        if (!userId)
          return fail(400, { error: "User ID required" });
        if (!["ADMIN", "MANAGER", "TECHNICIAN"].includes(role)) {
          return fail(400, { error: "Invalid role" });
        }
        if (userId === locals.user.id) {
          return fail(400, { error: "Can't change your own role" });
        }
        const targetUser = await prisma.user.findUnique({
          where: { id: userId },
          select: { email: true, role: true }
        });
        await prisma.user.updateMany({
          where: { id: userId, organizationId: locals.user.organizationId },
          data: { role }
        });
        await logAudit(locals.user.id, "USER_ROLE_CHANGED", {
          targetUserId: userId,
          email: targetUser?.email,
          oldRole: targetUser?.role,
          newRole: role
        });
        return { success: true };
      },
      delete: async (event) => {
        const { locals, request } = event;
        if (!locals.user || !canManageUsers(locals.user.role)) {
          return fail(403, { error: "Access denied" });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await request.formData();
        const userId = formData.get("userId");
        if (!userId)
          return fail(400, { error: "User ID required" });
        if (userId === locals.user.id) {
          return fail(400, { error: "Can't delete your own account" });
        }
        const targetUser = await prisma.user.findUnique({
          where: { id: userId },
          select: { email: true }
        });
        await prisma.user.deleteMany({
          where: { id: userId, organizationId: locals.user.organizationId }
        });
        await logAudit(locals.user.id, "USER_DELETED", {
          deletedUserId: userId,
          email: targetUser?.email
        });
        return { success: true };
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/users/_page.svelte.js
var page_svelte_exports18 = {};
__export(page_svelte_exports18, {
  default: () => Page18
});
function getRoleBadgeClasses(role) {
  const baseClasses = "px-2 py-1 text-xs font-bold uppercase rounded-full border-0 cursor-pointer";
  const colorClasses = {
    ADMIN: "bg-spore-orange text-white",
    MANAGER: "bg-spore-forest text-white",
    TECHNICIAN: "bg-spore-steel text-white"
  };
  return `${baseClasses} ${colorClasses[role]}`;
}
var ROLE_NAMES, Page18;
var init_page_svelte18 = __esm({
  ".svelte-kit/output/server/entries/pages/users/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    init_FilterBar();
    init_stores();
    ROLE_NAMES = {
      ADMIN: "Admin",
      MANAGER: "Manager",
      TECHNICIAN: "Technician"
    };
    Page18 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let users;
      let { data } = $$props;
      let showFilters = false;
      let searchValue = "";
      let filterRole = "";
      let filterStatus = "";
      let sortOption = "name";
      function applyFilters() {
        const params = new URLSearchParams();
        if (searchValue)
          params.set("search", searchValue);
        if (filterRole)
          params.set("role", filterRole);
        if (filterStatus)
          params.set("status", filterStatus);
        if (sortOption !== "name")
          params.set("sort", sortOption);
        const queryString = params.toString();
        goto(`?${queryString}`, { replaceState: true, keepFocus: true });
      }
      function clearFilters() {
        searchValue = "";
        filterRole = "";
        filterStatus = "";
        sortOption = "name";
        goto("?", { replaceState: true, keepFocus: true });
      }
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        users = data.users || [];
        {
          if (page.url) {
            const urlParams = page.url.searchParams;
            searchValue = urlParams.get("search") || "";
            filterRole = urlParams.get("role") || "";
            filterStatus = urlParams.get("status") || "";
            sortOption = urlParams.get("sort") || "name";
          }
        }
        $$rendered = `<div class="max-w-7xl mx-auto px-4 py-10"> <div class="mb-8"><div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 mb-6"><div><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-t6iemi">Users</h1> <p class="text-spore-cream/60 mt-2 text-sm font-medium">${escape(users.length)} team member${escape(users.length !== 1 ? "s" : "")}</p></div> <div class="flex gap-3"><a href="/users/security" class="bg-spore-steel text-spore-cream px-6 py-3 rounded-xl hover:bg-spore-steel/90 transition-colors text-sm font-bold tracking-wide" data-svelte-h="svelte-6mogsj">\u{1F512} Security</a> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold tracking-wide">${escape("+ ADD USER")}</button></div></div>  ${validate_component(FilterBar, "FilterBar").$$render(
          $$result,
          {
            searchPlaceholder: "Search users...",
            searchTitle: "Search by name or email",
            onSearch: (v) => {
              searchValue = v;
              applyFilters();
            },
            toggleButtons: [],
            filters: [
              {
                value: filterRole,
                placeholder: "All Roles",
                title: "Filter by role",
                onChange: (v) => {
                  filterRole = v;
                  applyFilters();
                },
                options: Object.entries(ROLE_NAMES).map(([value, label]) => ({ value, label }))
              },
              {
                value: filterStatus,
                placeholder: "All Status",
                title: "Filter by status",
                onChange: (v) => {
                  filterStatus = v;
                  applyFilters();
                },
                options: [
                  { value: "active", label: "Active" },
                  { value: "inactive", label: "Inactive" }
                ]
              }
            ],
            sortOptions: [
              { value: "name", label: "Name" },
              { value: "email", label: "Email" },
              { value: "role", label: "Role" },
              { value: "joined", label: "Joined" },
              { value: "updated", label: "Updated" }
            ],
            onSortChange: (v) => {
              sortOption = v;
              applyFilters();
            },
            onClear: clearFilters,
            clearLabel: "Reset",
            showFilters,
            searchValue,
            sortValue: sortOption
          },
          {
            showFilters: ($$value) => {
              showFilters = $$value;
              $$settled = false;
            },
            searchValue: ($$value) => {
              searchValue = $$value;
              $$settled = false;
            },
            sortValue: ($$value) => {
              sortOption = $$value;
              $$settled = false;
            }
          },
          {}
        )}</div>  ${``}  ${users.length > 0 ? `<div class="bg-spore-white rounded-xl overflow-hidden"><div class="overflow-x-auto"><table class="min-w-full"><thead class="bg-spore-dark"><tr><th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1tc615d">User</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-j44ek2">Email</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-devm0q">Role</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-9iareg">Status</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1us0d3z">Joined</th> <th class="px-6 py-4 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1r8dv0n">Actions</th></tr></thead> <tbody class="divide-y divide-spore-cream/50">${each(users, (user) => {
          return `<tr class="hover:bg-spore-cream/20 transition-colors"><td class="px-6 py-4 whitespace-nowrap"><span class="text-sm font-bold text-spore-dark">${escape(user.firstName || "")} ${escape(user.lastName || "")} ${!user.firstName && !user.lastName ? `<span class="text-spore-steel" data-svelte-h="svelte-6cnpz3">(No name)</span>` : ``} </span></td> <td class="px-6 py-4 whitespace-nowrap text-sm text-spore-steel">${escape(user.email)}</td> <td class="px-6 py-4 whitespace-nowrap"><form method="POST" action="?/updateRole" class="inline"><input type="hidden" name="userId"${add_attribute("value", user.id, 0)}> <select name="role"${add_attribute("value", user.role, 0)}${add_attribute("class", getRoleBadgeClasses(user.role), 0)}>${each(["TECHNICIAN", "MANAGER", "ADMIN"], (role) => {
            return `<option${add_attribute("value", role, 0)}>${escape(ROLE_NAMES[role])}</option>`;
          })}</select> </form></td> <td class="px-6 py-4 whitespace-nowrap"><span class="${"px-2 py-1 text-xs font-medium rounded-full " + escape(
            user.isActive ? "bg-green-100 text-green-800" : "bg-red-100 text-red-800",
            true
          )}">${escape(user.isActive ? "Active" : "Inactive")} </span></td> <td class="px-6 py-4 whitespace-nowrap text-sm text-spore-steel">${escape(new Date(user.createdAt).toLocaleDateString())}</td> <td class="px-6 py-4 whitespace-nowrap text-sm"><form method="POST" action="?/delete" class="inline"><input type="hidden" name="userId"${add_attribute("value", user.id, 0)}> <button type="submit" class="text-red-500 hover:text-red-400 font-bold transition-colors" data-svelte-h="svelte-gvkpdz">Delete</button> </form></td> </tr>`;
        })}</tbody></table></div></div>` : `<div class="text-center py-16 bg-spore-white rounded-xl"><div class="text-5xl mb-4" data-svelte-h="svelte-1i6rpvs">\u{1F465}</div> <h3 class="text-xl font-bold text-spore-dark mb-2" data-svelte-h="svelte-xk78eh">No users yet</h3> <p class="text-spore-steel mb-6" data-svelte-h="svelte-1iuc5bd">Add team members to get started</p> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 transition-colors text-sm font-bold" data-svelte-h="svelte-174euj2">+ ADD USER</button></div>`}</div>`;
      } while (!$$settled);
      return $$rendered;
    });
  }
});

// .svelte-kit/output/server/nodes/19.js
var __exports20 = {};
__export(__exports20, {
  component: () => component20,
  fonts: () => fonts20,
  imports: () => imports20,
  index: () => index20,
  server: () => page_server_ts_exports18,
  server_id: () => server_id19,
  stylesheets: () => stylesheets20
});
var index20, component_cache20, component20, server_id19, imports20, stylesheets20, fonts20;
var init__20 = __esm({
  ".svelte-kit/output/server/nodes/19.js"() {
    init_page_server_ts18();
    index20 = 19;
    component20 = async () => component_cache20 ??= (await Promise.resolve().then(() => (init_page_svelte18(), page_svelte_exports18))).default;
    server_id19 = "src/routes/users/+page.server.ts";
    imports20 = ["_app/immutable/nodes/19.8299d912.js", "_app/immutable/chunks/_page.bce61d57.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/globals.7f7f1b26.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/stores.e6b76d1c.js", "_app/immutable/chunks/badges.487c14ed.js", "_app/immutable/chunks/FilterBar.0110061d.js"];
    stylesheets20 = [];
    fonts20 = [];
  }
});

// .svelte-kit/output/server/entries/pages/users/security/_page.svelte.js
var page_svelte_exports19 = {};
__export(page_svelte_exports19, {
  default: () => Page19
});
var Page19;
var init_page_svelte19 = __esm({
  ".svelte-kit/output/server/entries/pages/users/security/_page.svelte.js"() {
    init_ssr();
    Page19 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { data } = $$props;
      let securityLogs = [];
      let filters = {
        severity: "",
        action: "",
        ipAddress: "",
        startDate: "",
        endDate: ""
      };
      let pagination = {
        logs: { page: 1, total: 0, limit: 50 },
        blocks: { page: 1, total: 0, limit: 50 }
      };
      async function loadSecurityLogs() {
        try {
          const params = new URLSearchParams({
            limit: pagination.logs.limit.toString(),
            offset: ((pagination.logs.page - 1) * pagination.logs.limit).toString()
          });
          if (filters.severity)
            ;
          if (filters.action)
            ;
          if (filters.ipAddress)
            ;
          if (filters.startDate)
            ;
          if (filters.endDate)
            ;
          const response = await fetch(`/api/security/event-logs?${params}`);
          if (response.ok) {
            const result = await response.json();
            securityLogs = result.logs;
            pagination.logs.total = result.total;
          }
        } catch (error47) {
          console.error("Failed to load security logs:", error47);
        }
      }
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      {
        {
          loadSecurityLogs();
        }
      }
      return `${$$result.head += `<!-- HEAD_svelte-a4mkf8_START -->${$$result.title = `<title>Security Dashboard - SPORE CMMS</title>`, ""}<!-- HEAD_svelte-a4mkf8_END -->`, ""} <div class="max-w-7xl mx-auto px-4 py-6"><div class="mb-6"><h1 class="text-2xl font-bold text-spore-cream mb-2" data-svelte-h="svelte-1i631de">Security Dashboard</h1> <p class="text-spore-steel" data-svelte-h="svelte-n94d62">Monitor security events and manage IP blocks</p></div>  <div class="flex gap-4 mb-6 border-b border-spore-steel/30"><button class="${"pb-3 px-1 font-semibold transition-colors border-b-2 " + escape(
        "text-spore-orange border-spore-orange",
        true
      )}">Security Logs</button> <button class="${"pb-3 px-1 font-semibold transition-colors border-b-2 " + escape(
        "text-spore-cream/50 border-transparent hover:text-spore-cream",
        true
      )}">Blocked IPs</button></div> ${`<div class="flex justify-center items-center h-64"><div class="animate-spin rounded-full h-8 w-8 border-b-2 border-spore-orange"></div></div>`}  ${``}</div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/20.js
var __exports21 = {};
__export(__exports21, {
  component: () => component21,
  fonts: () => fonts21,
  imports: () => imports21,
  index: () => index21,
  stylesheets: () => stylesheets21
});
var index21, component_cache21, component21, imports21, stylesheets21, fonts21;
var init__21 = __esm({
  ".svelte-kit/output/server/nodes/20.js"() {
    index21 = 20;
    component21 = async () => component_cache21 ??= (await Promise.resolve().then(() => (init_page_svelte19(), page_svelte_exports19))).default;
    imports21 = ["_app/immutable/chunks/20.92748185.js", "_app/immutable/chunks/_page.6cf9c208.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/globals.7f7f1b26.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/badges.487c14ed.js"];
    stylesheets21 = [];
    fonts21 = [];
  }
});

// .svelte-kit/output/server/chunks/user.js
function formatUserName(user) {
  if (user.firstName || user.lastName) {
    return [user.firstName, user.lastName].filter(Boolean).join(" ");
  }
  return user.email || "Unknown";
}
var init_user = __esm({
  ".svelte-kit/output/server/chunks/user.js"() {
  }
});

// .svelte-kit/output/server/chunks/status-history.js
var status_history_exports = {};
__export(status_history_exports, {
  formatStatusHistory: () => formatStatusHistory,
  queryStatusHistory: () => queryStatusHistory,
  recordStatusChange: () => recordStatusChange
});
async function recordStatusChange(prisma, workOrderId, fromStatus, toStatus, userId, reason) {
  try {
    await prisma.workOrderStatusHistory.create({
      data: {
        workOrderId,
        fromStatus: fromStatus || "PENDING",
        toStatus,
        reason: reason || null,
        userId
      }
    });
  } catch (e3) {
    logError("Failed to record status history", e3, { workOrderId, fromStatus, toStatus });
  }
}
async function queryStatusHistory(prisma, workOrderId) {
  return prisma.workOrderStatusHistory.findMany({
    where: { workOrderId },
    orderBy: { createdAt: "desc" },
    include: {
      user: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true
        }
      }
    }
  });
}
function formatStatusHistory(history) {
  return history.map((h) => ({
    ...h,
    user: h.user ? {
      ...h.user,
      displayName: formatUserName(h.user)
    } : null
  }));
}
var init_status_history = __esm({
  ".svelte-kit/output/server/chunks/status-history.js"() {
    init_user();
    init_logger();
  }
});

// .svelte-kit/output/server/chunks/service.js
async function broadcastToOrg(orgId, message) {
  try {
    const response = await fetch(DEV_BROADCAST_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ orgId, message })
    });
    if (response.ok) {
      console.log("[WS] Broadcast sent via HTTP API");
      return;
    }
  } catch (e3) {
  }
  if (typeof globalThis.__wsBroadcast === "function") {
    globalThis.__wsBroadcast(orgId, message);
    console.log("[WS] Broadcast sent via global function");
  } else {
    console.warn("[WS] Broadcast not available");
  }
}
function transformWorkOrder(wo) {
  const result = {
    ...wo,
    asset: null,
    building: null,
    unit: null,
    site: wo.Site || null
  };
  if (wo.Asset) {
    const assetData = {
      id: wo.Asset.id,
      name: wo.Asset.name,
      description: wo.Asset.description,
      type: wo.Asset.type,
      status: wo.Asset.status,
      purchaseDate: wo.Asset.purchaseDate,
      warrantyExpiry: wo.Asset.warrantyExpiry,
      lastMaintenance: wo.Asset.lastMaintenance,
      createdAt: wo.Asset.createdAt,
      updatedAt: wo.Asset.updatedAt,
      siteId: wo.Asset.siteId,
      unitId: wo.Asset.unitId,
      room: null
    };
    if (wo.Asset.Unit) {
      assetData.room = {
        id: wo.Asset.Unit.id,
        roomNumber: wo.Asset.Unit.roomNumber,
        name: wo.Asset.Unit.name || wo.Asset.Unit.roomNumber,
        floor: wo.Asset.Unit.floor,
        site: wo.Asset.Unit.Site ? { name: wo.Asset.Unit.Site.name } : null,
        building: wo.Asset.Unit.Building ? { name: wo.Asset.Unit.Building.name } : null
      };
    }
    result.asset = assetData;
  }
  if (wo.Building) {
    result.building = {
      id: wo.Building.id,
      name: wo.Building.name,
      description: wo.Building.description,
      address: wo.Building.address,
      city: wo.Building.city,
      state: wo.Building.state,
      zipCode: wo.Building.zipCode,
      country: wo.Building.country,
      yearBuilt: wo.Building.yearBuilt,
      floors: wo.Building.floors,
      squareFeet: wo.Building.squareFeet,
      createdAt: wo.Building.createdAt,
      updatedAt: wo.Building.updatedAt,
      siteId: wo.Building.siteId,
      site: wo.Building.Site ? { name: wo.Building.Site.name } : null
    };
  }
  if (wo.Unit) {
    result.unit = {
      id: wo.Unit.id,
      roomNumber: wo.Unit.roomNumber,
      name: wo.Unit.name,
      floor: wo.Unit.floor,
      squareFeet: wo.Unit.squareFeet,
      description: wo.Unit.description,
      createdAt: wo.Unit.createdAt,
      updatedAt: wo.Unit.updatedAt,
      siteId: wo.Unit.siteId,
      buildingId: wo.Unit.buildingId,
      site: wo.Unit.Site ? { name: wo.Unit.Site.name } : null,
      building: wo.Unit.Building ? { name: wo.Unit.Building.name } : null
    };
  }
  return result;
}
function transformWorkOrders(workOrders) {
  return workOrders.map(transformWorkOrder);
}
function transformAssetWithRoom(asset) {
  const result = {
    id: asset.id,
    name: asset.name,
    description: asset.description,
    type: asset.type,
    status: asset.status,
    purchaseDate: asset.purchaseDate,
    warrantyExpiry: asset.warrantyExpiry,
    lastMaintenance: asset.lastMaintenance,
    createdAt: asset.createdAt,
    updatedAt: asset.updatedAt,
    siteId: asset.siteId,
    unitId: asset.unitId,
    room: null
  };
  if (asset.Unit) {
    result.room = {
      id: asset.Unit.id,
      roomNumber: asset.Unit.roomNumber,
      name: asset.Unit.name || asset.Unit.roomNumber,
      floor: asset.Unit.floor,
      site: asset.Unit.Site ? { name: asset.Unit.Site.name } : null,
      building: asset.Unit.Building ? { name: asset.Unit.Building.name } : null
    };
  }
  return result;
}
function transformAssetsWithRoom(assets2) {
  return assets2.map(transformAssetWithRoom);
}
function transformUnit(unit) {
  return {
    id: unit.id,
    roomNumber: unit.roomNumber,
    name: unit.name,
    floor: unit.floor,
    squareFeet: unit.squareFeet,
    description: unit.description,
    createdAt: unit.createdAt,
    updatedAt: unit.updatedAt,
    siteId: unit.siteId,
    buildingId: unit.buildingId,
    site: unit.Site ? { name: unit.Site.name } : null,
    building: unit.Building ? { name: unit.Building.name } : null
  };
}
function transformUnits(units) {
  return units.map(transformUnit);
}
function transformBuilding(building2) {
  return {
    id: building2.id,
    name: building2.name,
    description: building2.description,
    address: building2.address,
    city: building2.city,
    state: building2.state,
    zipCode: building2.zipCode,
    country: building2.country,
    yearBuilt: building2.yearBuilt,
    floors: building2.floors,
    squareFeet: building2.squareFeet,
    createdAt: building2.createdAt,
    updatedAt: building2.updatedAt,
    siteId: building2.siteId,
    site: building2.Site ? { name: building2.Site.name } : null
  };
}
function transformBuildings(buildings) {
  return buildings.map(transformBuilding);
}
function buildWorkOrderWhere(filters) {
  const where = {
    organizationId: filters.organizationId
  };
  if (filters.assignedToId) {
    where.assignedToId = filters.assignedToId;
  }
  if (filters.status) {
    where.status = filters.status;
  }
  if (filters.priority) {
    where.priority = filters.priority;
  }
  if (filters.siteId) {
    where.siteId = filters.siteId;
  }
  if (filters.search?.trim()) {
    where.OR = [
      { title: { contains: filters.search.trim(), mode: "insensitive" } },
      { description: { contains: filters.search.trim(), mode: "insensitive" } }
    ];
  }
  return where;
}
function buildWorkOrderOrderBy(sort) {
  if (sort === "priority") {
    return { createdAt: "desc" };
  }
  if (sort === "created") {
    return { createdAt: "desc" };
  }
  if (sort === "updated") {
    return { updatedAt: "desc" };
  }
  return [
    { dueDate: "asc" },
    { createdAt: "desc" }
  ];
}
function sortByPriority(workOrders) {
  return workOrders.sort((a, b) => {
    const aOrder = PRIORITY_ORDER[a.priority] ?? 999;
    const bOrder = PRIORITY_ORDER[b.priority] ?? 999;
    if (aOrder !== bOrder)
      return aOrder - bOrder;
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
  });
}
async function queryWorkOrders(prisma, filters) {
  const where = buildWorkOrderWhere(filters);
  const orderBy = buildWorkOrderOrderBy(filters.sort || "dueDate");
  const workOrders = await prisma.workOrder.findMany({
    where,
    include: {
      Asset: {
        select: {
          id: true,
          name: true
        }
      },
      Building: {
        select: {
          id: true,
          name: true,
          Site: {
            select: {
              name: true
            }
          }
        }
      },
      Unit: {
        select: {
          id: true,
          roomNumber: true,
          name: true,
          Building: {
            select: {
              name: true
            }
          },
          Site: {
            select: {
              name: true
            }
          }
        }
      },
      Site: {
        select: {
          id: true,
          name: true
        }
      }
    },
    orderBy
  });
  let transformed = transformWorkOrders(workOrders);
  if (filters.sort === "priority") {
    transformed = sortByPriority(transformed);
  }
  return transformed;
}
async function queryLocationOptions(prisma, organizationId) {
  const orgFilter = organizationId ?? void 0;
  const [assets2, units, buildings, sites, users] = await Promise.all([
    prisma.asset.findMany({
      where: {
        Unit: {
          Site: {
            organizationId: orgFilter
          }
        }
      },
      include: {
        Unit: {
          include: {
            Site: { select: { name: true } },
            Building: { select: { name: true } }
          }
        }
      },
      orderBy: { name: "asc" }
    }),
    prisma.unit.findMany({
      where: {
        Site: {
          organizationId: orgFilter
        }
      },
      include: {
        Site: { select: { name: true } },
        Building: { select: { name: true } }
      },
      orderBy: [
        { Site: { name: "asc" } },
        { Building: { name: "asc" } },
        { roomNumber: "asc" }
      ]
    }),
    prisma.building.findMany({
      where: {
        Site: {
          organizationId: orgFilter
        }
      },
      include: {
        Site: { select: { name: true } }
      },
      orderBy: [
        { Site: { name: "asc" } },
        { name: "asc" }
      ]
    }),
    prisma.site.findMany({
      where: {
        organizationId: orgFilter
      },
      orderBy: { name: "asc" }
    }),
    prisma.user.findMany({
      where: { organizationId: orgFilter },
      select: {
        id: true,
        firstName: true,
        lastName: true,
        email: true
      },
      orderBy: { firstName: "asc" }
    })
  ]);
  return {
    assets: transformAssetsWithRoom(assets2),
    units: transformUnits(units),
    buildings: transformBuildings(buildings),
    sites,
    users
  };
}
async function queryWorkOrderById(prisma, id) {
  const workOrder = await prisma.workOrder.findUnique({
    where: { id },
    include: {
      Asset: {
        include: {
          Unit: {
            include: {
              Site: { select: { id: true, name: true } },
              Building: { select: { id: true, name: true } }
            }
          }
        }
      }
    }
  });
  if (!workOrder) {
    return null;
  }
  return transformWorkOrder(workOrder);
}
async function queryAssetsForDropdown(prisma, organizationId) {
  const assets2 = await prisma.asset.findMany({
    where: {
      Unit: {
        Site: {
          organizationId: organizationId ?? void 0
        }
      }
    },
    include: {
      Unit: {
        include: {
          Site: { select: { name: true } }
        }
      }
    },
    orderBy: { name: "asc" }
  });
  return transformAssetsWithRoom(assets2);
}
function assertCanUpdateWorkOrder(event, workOrder) {
  const userId = event.locals.user?.id;
  const userRole = event.locals.user?.role;
  if (!userId || !userRole) {
    throw fail(401, { error: "Authentication required" });
  }
  if (!canUpdateWorkOrder(userId, userRole, workOrder.createdById, workOrder.assignedToId)) {
    throw fail(403, { error: "You do not have permission to update this work order" });
  }
}
function assertCanAssignWorkOrder(event) {
  const userRole = event.locals.user?.role;
  if (!userRole) {
    throw fail(401, { error: "Authentication required" });
  }
  if (!canAssignWorkOrder(userRole)) {
    throw fail(403, { error: "Only managers and admins can assign work orders" });
  }
}
function assertCanDeleteWorkOrder(event) {
  const userRole = event.locals.user?.role;
  if (!userRole) {
    throw fail(401, { error: "Authentication required" });
  }
  if (!canDeleteWorkOrder(userRole)) {
    throw fail(403, { error: "Only managers and admins can delete work orders" });
  }
}
async function validateAssignedUser(prisma, assignedToId, organizationId) {
  if (!assignedToId) {
    return true;
  }
  const assignedUser = await prisma.user.findUnique({
    where: { id: assignedToId },
    select: { organizationId: true }
  });
  return assignedUser?.organizationId === organizationId;
}
async function createWorkOrder(event, prisma, data) {
  const organizationId = event.locals.user.organizationId;
  const createdById = event.locals.user.id;
  if (!organizationId) {
    return fail(400, { error: "Organization required." });
  }
  const isValidAssignment = await validateAssignedUser(
    prisma,
    data.assignedToId || null,
    organizationId
  );
  if (!isValidAssignment) {
    return fail(400, { error: "Invalid user assignment." });
  }
  try {
    const newWo = await prisma.workOrder.create({
      data: {
        title: data.title.trim(),
        description: data.description?.trim() || "",
        priority: data.priority,
        dueDate: data.dueDate || null,
        organizationId,
        createdById,
        assignedToId: data.assignedToId || null,
        status: "PENDING",
        updatedAt: /* @__PURE__ */ new Date(),
        ...data.selectionMode === "asset" && { assetId: data.assetId },
        ...data.selectionMode === "unit" && { unitId: data.unitId },
        ...data.selectionMode === "building" && { buildingId: data.buildingId },
        ...data.selectionMode === "site" && { siteId: data.siteId }
      },
      select: {
        id: true,
        title: true,
        status: true,
        assetId: true,
        buildingId: true,
        unitId: true,
        siteId: true,
        organizationId: true,
        createdAt: true,
        priority: true,
        dueDate: true
      }
    });
    if (data.checklistItems && data.checklistItems.length > 0) {
      const checklistItems = data.checklistItems.map((item, index24) => ({
        title: item.title.trim(),
        position: index24,
        workOrderId: newWo.id
      }));
      await prisma.workOrderChecklistItem.createMany({
        data: checklistItems
      });
    }
    broadcastToOrg(organizationId, {
      type: "WO_NEW",
      payload: newWo
    });
    await logAudit(createdById, "WORK_ORDER_CREATED", {
      workOrderId: newWo.id,
      title: newWo.title,
      priority: newWo.priority,
      dueDate: newWo.dueDate,
      selectionMode: data.selectionMode,
      checklistItemCount: data.checklistItems?.length || 0,
      selectionDetails: data.selectionMode === "asset" ? { assetId: data.assetId } : data.selectionMode === "unit" ? { unitId: data.unitId } : data.selectionMode === "building" ? { buildingId: data.buildingId } : data.selectionMode === "site" ? { siteId: data.siteId } : {}
    });
    return { success: true, workOrder: newWo };
  } catch (e3) {
    logError("Error creating work order", e3, { title: data.title });
    return { success: false, error: "Failed to create work order." };
  }
}
async function updateWorkOrderStatus(event, prisma, workOrderId, newStatus, reason) {
  const userId = event.locals.user.id;
  try {
    const existing = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
      select: { createdById: true, assignedToId: true, status: true }
    });
    if (!existing) {
      return { success: false, error: "Work order not found." };
    }
    assertCanUpdateWorkOrder(event, existing);
    const { recordStatusChange: recordStatusChange2 } = await Promise.resolve().then(() => (init_status_history(), status_history_exports));
    await recordStatusChange2(prisma, workOrderId, existing.status, newStatus, userId, reason);
    const updatedWo = await prisma.workOrder.update({
      where: { id: workOrderId },
      data: { status: newStatus },
      select: {
        id: true,
        title: true,
        status: true,
        assetId: true,
        organizationId: true
      }
    });
    broadcastToOrg(updatedWo.organizationId, {
      type: "WO_UPDATE",
      payload: updatedWo
    });
    await logAudit(userId, "WORK_ORDER_STATUS_CHANGED", {
      workOrderId: updatedWo.id,
      title: updatedWo.title,
      fromStatus: existing.status,
      toStatus: newStatus,
      reason
    });
    return { success: true, updatedWo };
  } catch (e3) {
    if (e3 && typeof e3 === "object" && "status" in e3) {
      throw e3;
    }
    logError("Error updating WO status", e3, { workOrderId, newStatus });
    return { success: false, error: "Database transaction failed." };
  }
}
async function assignWorkOrder(event, prisma, workOrderId, assignedToId) {
  const userId = event.locals.user.id;
  const organizationId = event.locals.user.organizationId;
  if (!organizationId) {
    return fail(400, { error: "Organization required." });
  }
  assertCanAssignWorkOrder(event);
  try {
    if (assignedToId) {
      const isValid = await validateAssignedUser(
        prisma,
        assignedToId,
        organizationId
      );
      if (!isValid) {
        return fail(400, { error: "Cannot assign to user outside your organization" });
      }
    }
    const updatedWo = await prisma.workOrder.update({
      where: { id: workOrderId },
      data: { assignedToId: assignedToId || null },
      select: {
        id: true,
        title: true,
        status: true,
        assignedToId: true,
        organizationId: true
      }
    });
    broadcastToOrg(updatedWo.organizationId, {
      type: "WO_UPDATE",
      payload: updatedWo
    });
    await logAudit(userId, "WORK_ORDER_ASSIGNED", {
      workOrderId: updatedWo.id,
      title: updatedWo.title,
      assignedToId: assignedToId || null
    });
    return { success: true };
  } catch (e3) {
    if (e3 && typeof e3 === "object" && "status" in e3) {
      throw e3;
    }
    logError("Error assigning WO", e3, { workOrderId, assignedToId });
    return fail(500, { error: "Failed to assign work order" });
  }
}
async function updateWorkOrderDetails(event, prisma, workOrderId, data) {
  const userId = event.locals.user.id;
  try {
    const existing = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
      select: { createdById: true, assignedToId: true }
    });
    if (!existing) {
      return fail(404, { error: "Work order not found" });
    }
    assertCanUpdateWorkOrder(event, existing);
    const workOrder = await prisma.workOrder.update({
      where: { id: workOrderId },
      data: {
        title: data.title.trim(),
        description: data.description?.trim() || "",
        assetId: data.assetId
      },
      select: {
        id: true,
        title: true,
        description: true,
        assetId: true,
        organizationId: true
      }
    });
    broadcastToOrg(workOrder.organizationId, {
      type: "WO_UPDATE",
      payload: workOrder
    });
    await logAudit(userId, "WORK_ORDER_UPDATED", {
      workOrderId: workOrder.id,
      title: workOrder.title
    });
    return { success: true, workOrder };
  } catch (e3) {
    if (e3 && typeof e3 === "object" && "status" in e3) {
      throw e3;
    }
    logError("Error updating work order", e3, { workOrderId });
    return fail(500, { error: "Failed to update work order" });
  }
}
async function deleteWorkOrder(event, prisma, workOrderId) {
  const userId = event.locals.user.id;
  assertCanDeleteWorkOrder(event);
  try {
    const wo = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
      select: { title: true, organizationId: true }
    });
    if (!wo) {
      return fail(404, { error: "Work order not found" });
    }
    await prisma.workOrder.delete({
      where: { id: workOrderId }
    });
    await logAudit(userId, "WORK_ORDER_DELETED", {
      workOrderId,
      title: wo.title
    });
    return { success: true, organizationId: wo.organizationId };
  } catch (e3) {
    if (e3 && typeof e3 === "object" && "status" in e3) {
      throw e3;
    }
    logError("Error deleting work order", e3, { workOrderId });
    return fail(500, { error: "Failed to delete work order" });
  }
}
var MAX_DESCRIPTION_LENGTH, MAX_COMMENT_LENGTH, MAX_COMMENT_DEPTH, DEV_BROADCAST_URL;
var init_service = __esm({
  ".svelte-kit/output/server/chunks/service.js"() {
    init_chunks();
    init_audit();
    init_guards();
    init_constants2();
    init_logger();
    MAX_DESCRIPTION_LENGTH = 5e3;
    MAX_COMMENT_LENGTH = 5e3;
    MAX_COMMENT_DEPTH = 5;
    DEV_BROADCAST_URL = "http://localhost:3001/api/broadcast";
  }
});

// .svelte-kit/output/server/entries/pages/work-orders/_page.server.ts.js
var page_server_ts_exports19 = {};
__export(page_server_ts_exports19, {
  actions: () => actions17,
  load: () => load19
});
var load19, actions17;
var init_page_server_ts19 = __esm({
  ".svelte-kit/output/server/entries/pages/work-orders/_page.server.ts.js"() {
    init_prisma();
    init_guards();
    init_chunks();
    init_constants2();
    init_service();
    init_security();
    init_templates();
    load19 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const userId = event.locals.user.id;
      const organizationId = event.locals.user.organizationId;
      if (!organizationId) {
        throw error(400, "Organization required");
      }
      const myOnly = event.url.searchParams.get("my") === "true";
      const status = event.url.searchParams.get("status");
      const priority = event.url.searchParams.get("priority");
      const siteId = event.url.searchParams.get("siteId");
      const sort = event.url.searchParams.get("sort") || "dueDate";
      const search = event.url.searchParams.get("search");
      const workOrders = await queryWorkOrders(prisma, {
        organizationId,
        assignedToId: myOnly ? userId : void 0,
        status: status || void 0,
        priority: priority || void 0,
        siteId: siteId || void 0,
        sort,
        search: search || void 0
      });
      const locationOptions = await queryLocationOptions(prisma, organizationId);
      const templates = await queryTemplates(prisma, {
        organizationId,
        isActive: true
      });
      return {
        workOrders,
        ...locationOptions,
        templates,
        myOnly,
        status,
        priority,
        siteId,
        sort,
        search
      };
    };
    actions17 = {
      /**
       * Create a new Work Order
       */
      create: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_create", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        event.locals.user?.id;
        const organizationId = event.locals.user?.organizationId;
        const data = await event.request.formData();
        let title = data.get("title");
        let description = data.get("description");
        let priority = data.get("priority") || DEFAULT_PRIORITY;
        const dueDate = data.get("dueDate");
        const assignedToId = data.get("assignedToId");
        const selectionMode = data.get("selectionMode") || DEFAULT_SELECTION_MODE;
        const assetId = data.get("assetId");
        const unitId = data.get("unitId") || data.get("roomId");
        const buildingId = data.get("buildingId");
        const siteId = data.get("siteId");
        const templateId = data.get("templateId");
        let checklistItems = [];
        if (templateId && organizationId) {
          const templateResult = await applyTemplate(prisma, templateId, organizationId);
          if ("status" in templateResult) {
            return templateResult;
          }
          if (!title?.trim() && templateResult.title) {
            title = templateResult.title;
          }
          if (!description?.trim() && templateResult.description) {
            description = templateResult.description;
          }
          if (priority === DEFAULT_PRIORITY && templateResult.priority) {
            priority = templateResult.priority;
          }
          checklistItems = templateResult.items || [];
        }
        if (!title?.trim()) {
          return fail(400, { error: "Title is required." });
        }
        if (!PRIORITIES.includes(priority)) {
          return fail(400, { error: "Invalid priority value." });
        }
        const trimmedDescription = description?.trim() || "";
        if (trimmedDescription.length > MAX_DESCRIPTION_LENGTH) {
          return fail(400, { error: `Description is too long (max ${MAX_DESCRIPTION_LENGTH} characters).` });
        }
        let parsedDueDate = null;
        if (dueDate) {
          parsedDueDate = new Date(dueDate);
          if (isNaN(parsedDueDate.getTime())) {
            return fail(400, { error: "Invalid due date format." });
          }
        }
        if (!assetId && !unitId && !buildingId && !siteId) {
          return fail(400, { error: "Please select an asset, unit, building, or site." });
        }
        return createWorkOrder(event, prisma, {
          title,
          description: trimmedDescription,
          priority,
          dueDate: parsedDueDate,
          assignedToId: assignedToId || void 0,
          selectionMode: selectionMode || "asset",
          assetId,
          unitId,
          buildingId,
          siteId,
          checklistItems
        });
      },
      /**
       * Handles updating the status of a Work Order.
       * This is the core workflow trigger for the real-time system.
       */
      updateStatus: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_status_update", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const data = await event.request.formData();
        const woId = data.get("workOrderId");
        const newStatus = data.get("status");
        if (!woId || !newStatus) {
          return { success: false, error: "Missing ID or status." };
        }
        return updateWorkOrderStatus(event, prisma, woId, newStatus);
      },
      assign: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_assign", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const data = await event.request.formData();
        const woId = data.get("workOrderId");
        const assignedToId = data.get("assignedToId");
        if (!woId) {
          return fail(400, { error: "Work order ID required" });
        }
        return assignWorkOrder(event, prisma, woId, assignedToId || null);
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/work-orders/_page.svelte.js
var page_svelte_exports20 = {};
__export(page_svelte_exports20, {
  default: () => Page20
});
function isOverdue(dueDate, status) {
  if (status === "COMPLETED" || !dueDate)
    return false;
  const today = /* @__PURE__ */ new Date();
  today.setHours(0, 0, 0, 0);
  const due = typeof dueDate === "string" ? new Date(dueDate) : dueDate;
  due.setHours(0, 0, 0, 0);
  return due < today;
}
function getOverdueClass(dueDate, status) {
  return isOverdue(dueDate, status) ? "text-red-500 font-semibold" : "text-spore-dark";
}
var Page20;
var init_page_svelte20 = __esm({
  ".svelte-kit/output/server/entries/pages/work-orders/_page.svelte.js"() {
    init_ssr();
    init_websocket();
    init_devalue();
    init_FilterBar();
    init_stores();
    init_constants2();
    init_user();
    Page20 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let isExpanded;
      let $$unsubscribe_page;
      validate_store(page, "page");
      $$unsubscribe_page = subscribe(page, (value) => value);
      let { data } = $$props;
      let workOrders = data.workOrders || [];
      data.assets || [];
      data.units || [];
      data.buildings || [];
      let sites = data.sites || [];
      let users = data.users || [];
      data.templates || [];
      let expandedCardIds = /* @__PURE__ */ new Set();
      function getSiteOptions() {
        return sites.map((s3) => ({ value: s3.id, label: s3.name }));
      }
      let filterStatus = data.status || "";
      let filterPriority = data.priority || "";
      let filterSite = data.siteId || "";
      let sortOption = data.sort || DEFAULT_SORT_OPTION;
      let showFilters = false;
      let myOnly = data.myOnly || false;
      let searchValue = data.search || "";
      function applyFilters() {
        const params = new URLSearchParams();
        if (myOnly)
          params.set("my", "true");
        if (filterStatus)
          params.set("status", filterStatus);
        if (filterPriority)
          params.set("priority", filterPriority);
        if (filterSite)
          params.set("siteId", filterSite);
        if (sortOption && sortOption !== DEFAULT_SORT_OPTION)
          params.set("sort", sortOption);
        if (searchValue)
          params.set("search", searchValue);
        goto(`?${params.toString()}`, { keepFocus: true });
      }
      function clearFilters() {
        filterStatus = "";
        filterPriority = "";
        filterSite = "";
        sortOption = DEFAULT_SORT_OPTION;
        myOnly = false;
        searchValue = "";
        applyFilters();
      }
      function toggleMyOrders() {
        myOnly = !myOnly;
        applyFilters();
      }
      let wsConnected = false;
      let lastUpdate = null;
      let showCreateForm = false;
      const unsubscribe = wsStore.subscribe((state) => {
        wsConnected = state.isConnected;
        if (state.messages.length > 0) {
          const latest = state.messages[0];
          if (latest.type === "WO_UPDATE" && latest.payload) {
            const updated2 = latest.payload;
            workOrders = workOrders.map((wo) => {
              if (wo.id === updated2.id) {
                lastUpdate = `${updated2.title} \u2192 ${updated2.status}`;
                return { ...wo, status: updated2.status };
              }
              return wo;
            });
          }
          if (latest.type === "WO_NEW" && latest.payload) {
            const newWoPayload = latest.payload;
            if (!workOrders.some((wo) => wo.id === newWoPayload.id)) {
              lastUpdate = `New: ${newWoPayload.title}`;
              invalidateAll();
            }
          }
        }
      });
      onDestroy(() => unsubscribe());
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      let $$settled;
      let $$rendered;
      let previous_head = $$result.head;
      do {
        $$settled = true;
        $$result.head = previous_head;
        isExpanded = (id) => expandedCardIds.has(id);
        {
          if (data.workOrders)
            workOrders = data.workOrders;
        }
        {
          if (data.assets)
            data.assets;
        }
        {
          if (data.units)
            data.units;
        }
        {
          if (data.buildings)
            data.buildings;
        }
        {
          if (data.sites)
            sites = data.sites;
        }
        {
          if (data.users)
            users = data.users;
        }
        {
          if (data.templates)
            data.templates;
        }
        $$rendered = `${$$result.head += `<!-- HEAD_svelte-178cqdl_START -->${$$result.title = `<title>Work Orders \u2014 Spore CMMS</title>`, ""}<!-- HEAD_svelte-178cqdl_END -->`, ""} <div class="max-w-7xl mx-auto px-4 py-10"> <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4 mb-6"><div><h1 class="text-4xl font-extrabold text-spore-cream tracking-tight" data-svelte-h="svelte-hmu04k">Work Orders</h1> <div class="flex items-center gap-3 mt-2"><span class="${"flex items-center gap-2 text-sm font-medium " + escape(
          wsConnected ? "text-spore-orange" : "text-spore-cream/50",
          true
        )}" role="status" aria-live="polite"><span class="${"w-2 h-2 rounded-full " + escape(
          wsConnected ? "bg-spore-orange animate-pulse" : "bg-spore-cream/30",
          true
        )}" aria-hidden="true"></span> ${escape(wsConnected ? "Live updates enabled" : "Connecting...")}</span> ${lastUpdate ? `<span class="text-sm font-medium text-spore-orange animate-pulse" role="status" aria-live="polite">${escape(lastUpdate)}</span>` : ``}</div></div> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:ring-offset-2 focus:ring-offset-spore-steel transition-colors text-sm font-bold tracking-wide shadow-lg"${add_attribute("aria-expanded", showCreateForm, 0)} aria-controls="create-form">${escape("+ NEW WORK ORDER")}</button></div>  ${validate_component(FilterBar, "FilterBar").$$render(
          $$result,
          {
            searchPlaceholder: "Search work orders...",
            searchTitle: "Search by title or description",
            onSearch: (v) => {
              searchValue = v;
              applyFilters();
            },
            toggleButtons: [
              {
                label: "My Work Orders",
                active: myOnly,
                onToggle: toggleMyOrders,
                title: "Show only my assigned work orders"
              }
            ],
            filters: [
              {
                value: filterStatus,
                placeholder: "All Statuses",
                title: "Filter by status",
                onChange: (v) => {
                  filterStatus = v;
                  applyFilters();
                },
                options: WORK_ORDER_STATUSES.map((s3) => ({ value: s3, label: s3.replace("_", " ") }))
              },
              {
                value: filterPriority,
                placeholder: "All Priorities",
                title: "Filter by priority",
                onChange: (v) => {
                  filterPriority = v;
                  applyFilters();
                },
                options: PRIORITIES.map((p) => ({ value: p, label: p }))
              },
              {
                value: filterSite,
                placeholder: "All Sites",
                title: "Filter by site",
                onChange: (v) => {
                  filterSite = v;
                  applyFilters();
                },
                show: sites.length > 0,
                options: getSiteOptions()
              }
            ],
            sortOptions: [
              { value: "dueDate", label: "Due Date" },
              { value: "priority", label: "Priority" },
              { value: "created", label: "Newest" },
              { value: "updated", label: "Updated" }
            ],
            onSortChange: (v) => {
              sortOption = v;
              applyFilters();
            },
            onClear: clearFilters,
            clearLabel: "Reset",
            showFilters,
            searchValue,
            sortValue: sortOption
          },
          {
            showFilters: ($$value) => {
              showFilters = $$value;
              $$settled = false;
            },
            searchValue: ($$value) => {
              searchValue = $$value;
              $$settled = false;
            },
            sortValue: ($$value) => {
              sortOption = $$value;
              $$settled = false;
            }
          },
          {}
        )}  ${``}  ${workOrders && workOrders.length > 0 ? `<div class="bg-spore-white rounded-xl shadow-sm border border-spore-cream/50 overflow-hidden"> <div class="hidden md:block overflow-x-auto"><table class="min-w-full" role="table" aria-label="Work orders list"><thead class="bg-spore-dark"><tr><th scope="col" class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-3znkiu">Title</th> <th scope="col" class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-19faq7s">Priority</th> <th scope="col" class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-11id8rq">Status</th> <th scope="col" class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-1eniqmk">Assigned</th> <th scope="col" class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider hidden lg:table-cell" data-svelte-h="svelte-1n0iefz">Location</th> <th scope="col" class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider hidden lg:table-cell" data-svelte-h="svelte-12ixr6g">Due Date</th> <th scope="col" class="px-4 py-3 text-left text-xs font-bold text-spore-cream uppercase tracking-wider" data-svelte-h="svelte-4s34th">Actions</th></tr></thead> <tbody class="divide-y divide-spore-cream/50">${each(workOrders, (workOrder) => {
          return `<tr class="hover:bg-spore-cream/20 transition-colors"><td class="px-4 py-3"><a href="${"/work-orders/" + escape(workOrder.id, true)}" class="text-sm font-bold text-spore-dark hover:text-spore-orange transition-colors focus:outline-none focus:underline block">${escape(workOrder.title)} </a></td> <td class="px-4 py-3 whitespace-nowrap"><span class="${"px-2 py-1 text-xs font-semibold rounded-full " + escape(WORK_ORDER_PRIORITY_COLORS[workOrder.priority] || WORK_ORDER_PRIORITY_COLORS.MEDIUM, true)}">${escape(workOrder.priority)} </span></td> <td class="px-4 py-3 whitespace-nowrap"><span class="${"px-2 py-1 text-xs font-semibold rounded-full " + escape(getStatusColor(workOrder.status), true)}">${escape(formatStatus(workOrder.status))} </span></td> <td class="px-4 py-3 whitespace-nowrap"><form method="POST" action="?/assign" class="inline"><input type="hidden" name="workOrderId"${add_attribute("value", workOrder.id, 0)}> <select name="assignedToId"${add_attribute("value", workOrder.assignedToId || "", 0)} class="text-xs bg-transparent border-0 text-spore-steel cursor-pointer hover:text-spore-dark focus:outline-none focus:ring-1 focus:ring-spore-orange rounded min-w-[120px]"><option value="" data-svelte-h="svelte-nkh85j">Unassigned</option>${each(users, (user) => {
            return `<option${add_attribute("value", user.id, 0)}>${escape(formatUserName(user))}</option>`;
          })}</select> </form></td> <td class="px-4 py-3 text-sm text-spore-steel font-medium hidden lg:table-cell">${workOrder.asset && workOrder.asset.Unit ? `${escape(workOrder.asset.Unit.Site?.name || "N/A")} \u2022 Unit ${escape(workOrder.asset.Unit.roomNumber || workOrder.asset.Unit.name || "N/A")} ${workOrder.asset.Unit.Building ? `\u2022 Bldg ${escape(workOrder.asset.Unit.Building.name)}` : ``} ${workOrder.asset.Unit.floor ? `\u2022 Floor ${escape(workOrder.asset.Unit.floor)}` : ``}` : `${workOrder.building ? `${escape(workOrder.building.Site?.name || "N/A")} \u2022 Bldg ${escape(workOrder.building.name)}` : `${workOrder.unit ? `${escape(workOrder.unit.Site?.name || "N/A")} \u2022 Unit ${escape(workOrder.unit.roomNumber || workOrder.unit.name || "N/A")} ${workOrder.unit.Building ? `\u2022 Bldg ${escape(workOrder.unit.Building.name)}` : ``} ${workOrder.unit.floor ? `\u2022 Floor ${escape(workOrder.unit.floor)}` : ``}` : `${workOrder.site ? `${escape(workOrder.site.name)}` : `N/A`}`}`}`}</td> <td class="px-4 py-3 text-sm text-spore-steel hidden lg:table-cell">${workOrder.dueDate ? `${escape(new Date(workOrder.dueDate).toLocaleDateString())} ${isOverdue(workOrder.dueDate, workOrder.status) ? `<span class="text-red-500 font-semibold" data-svelte-h="svelte-w65mx2">(Overdue)</span>` : ``}` : `-`}</td> <td class="px-4 py-3 whitespace-nowrap text-xs font-medium space-x-2">${workOrder.status === "PENDING" ? `<form method="POST" action="?/updateStatus" class="inline"><input type="hidden" name="workOrderId"${add_attribute("value", workOrder.id, 0)}> <input type="hidden" name="status" value="IN_PROGRESS"> <button type="submit" class="text-spore-orange hover:text-spore-orange/70 focus:outline-none focus:underline" title="${"Start working on " + escape(workOrder.title, true)}">Start</button> </form>` : ``} ${workOrder.status === "IN_PROGRESS" ? `<form method="POST" action="?/updateStatus" class="inline"><input type="hidden" name="workOrderId"${add_attribute("value", workOrder.id, 0)}> <input type="hidden" name="status" value="COMPLETED"> <button type="submit" class="text-spore-forest hover:text-spore-forest/70 focus:outline-none focus:underline" title="${"Mark " + escape(workOrder.title, true) + " as completed"}">Complete</button> </form>` : ``} <a href="${"/work-orders/" + escape(workOrder.id, true)}" class="text-spore-steel hover:text-spore-dark focus:outline-none focus:underline" title="${"View details for " + escape(workOrder.title, true)}">View
									</a></td> </tr>`;
        })}</tbody></table></div>  <div class="md:hidden divide-y divide-spore-cream/50">${each(workOrders, (workOrder) => {
          return `<div class="hover:bg-spore-cream/10 transition-colors"> <button class="w-full p-4 flex items-start justify-between text-left"${add_attribute("aria-expanded", isExpanded(workOrder.id), 0)}${add_attribute("aria-controls", "card-content-" + workOrder.id, 0)}><div class="flex items-center gap-3 flex-1 min-w-0"><div class="flex flex-col gap-1 flex-shrink-0"><span class="${"px-2 py-1 text-xs font-semibold rounded-full " + escape(WORK_ORDER_PRIORITY_COLORS[workOrder.priority] || WORK_ORDER_PRIORITY_COLORS.MEDIUM, true)}">${escape(workOrder.priority)}</span> <span class="${"px-2 py-1 text-xs font-semibold rounded-full " + escape(getStatusColor(workOrder.status), true)}">${escape(formatStatus(workOrder.status))} </span></div> <h3 class="text-base font-bold text-spore-dark truncate">${escape(workOrder.title)} </h3></div> <div class="flex-shrink-0 ml-2 text-spore-steel"><svg class="${"w-5 h-5 transition-transform " + escape(isExpanded(workOrder.id) ? "rotate-180" : "", true)}" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg> </div></button>  <div${add_attribute("id", "card-content-" + workOrder.id, 0)} class="${"overflow-hidden transition-all duration-200 " + escape(
            isExpanded(workOrder.id) ? "max-h-[1000px] opacity-100" : "max-h-0 opacity-0",
            true
          )}"><div class="px-4 pb-4 space-y-2"><div class="flex items-center justify-between"><span class="text-sm font-medium text-spore-steel" data-svelte-h="svelte-8jdlm4">Location:</span> <span class="text-sm text-spore-dark text-right">${workOrder.asset && workOrder.asset.Unit ? `${escape(workOrder.asset.Unit.Site?.name || "N/A")} \u2022 Unit ${escape(workOrder.asset.Unit.roomNumber || workOrder.asset.Unit.name || "N/A")} ${workOrder.asset.Unit.Building ? `\u2022 Bldg ${escape(workOrder.asset.Unit.Building.name)}` : ``} ${workOrder.asset.Unit.floor ? `\u2022 Floor ${escape(workOrder.asset.Unit.floor)}` : ``}` : `${workOrder.building ? `${escape(workOrder.building.Site?.name || "N/A")} \u2022 Bldg ${escape(workOrder.building.name)}` : `${workOrder.unit ? `${escape(workOrder.unit.Site?.name || "N/A")} \u2022 Unit ${escape(workOrder.unit.roomNumber || workOrder.unit.name || "N/A")} ${workOrder.unit.Building ? `\u2022 Bldg ${escape(workOrder.unit.Building.name)}` : ``} ${workOrder.unit.floor ? `\u2022 Floor ${escape(workOrder.unit.floor)}` : ``}` : `${workOrder.site ? `${escape(workOrder.site.name)}` : `N/A`}`}`}`} </span></div> ${workOrder.dueDate ? `<div class="flex items-center justify-between"><span class="text-sm font-medium text-spore-steel" data-svelte-h="svelte-1t4sczn">Due:</span> <span class="${"text-sm " + escape(getOverdueClass(workOrder.dueDate, workOrder.status), true)}">${escape(new Date(workOrder.dueDate).toLocaleDateString())} ${isOverdue(workOrder.dueDate, workOrder.status) ? `(Overdue)` : ``}</span> </div>` : ``} <div class="flex items-center justify-between"><span class="text-sm font-medium text-spore-steel" data-svelte-h="svelte-1es34l">Assigned:</span> <form method="POST" action="?/assign" class="flex-1 max-w-[180px]"><input type="hidden" name="workOrderId"${add_attribute("value", workOrder.id, 0)}> <select name="assignedToId"${add_attribute("value", workOrder.assignedToId || "", 0)} class="w-full text-sm bg-spore-cream/30 border border-spore-cream/50 rounded-lg px-3 py-2.5 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange min-h-[44px]"><option value="" data-svelte-h="svelte-nkh85j">Unassigned</option>${each(users, (user) => {
            return `<option${add_attribute("value", user.id, 0)}>${escape(formatUserName(user))}</option>`;
          })}</select> </form></div> <div class="flex gap-2 text-sm font-bold pt-2">${workOrder.status === "PENDING" ? `<form method="POST" action="?/updateStatus" class="flex-1"><input type="hidden" name="workOrderId"${add_attribute("value", workOrder.id, 0)}> <input type="hidden" name="status" value="IN_PROGRESS"> <button type="submit" class="w-full bg-spore-orange text-white py-3 px-4 rounded-lg font-medium hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-spore-orange transition-colors min-h-[44px]" aria-label="${"Start work order: " + escape(workOrder.title, true)}">Start</button> </form>` : ``} ${workOrder.status === "IN_PROGRESS" ? `<form method="POST" action="?/updateStatus" class="flex-1"><input type="hidden" name="workOrderId"${add_attribute("value", workOrder.id, 0)}> <input type="hidden" name="status" value="COMPLETED"> <button type="submit" class="w-full bg-spore-forest text-white py-3 px-4 rounded-lg font-medium hover:bg-spore-forest/90 focus:outline-none focus:ring-2 focus:ring-spore-forest transition-colors min-h-[44px]" aria-label="${"Complete work order: " + escape(workOrder.title, true)}">Complete</button> </form>` : ``} <a href="${"/work-orders/" + escape(workOrder.id, true)}" class="flex-1 bg-spore-cream text-spore-dark py-3 px-4 rounded-lg font-medium text-center hover:bg-spore-cream/70 focus:outline-none focus:ring-2 focus:ring-spore-cream transition-colors min-h-[44px] flex items-center justify-center">View
								</a></div> </div></div> </div>`;
        })}</div></div>` : `<div class="text-center py-16 bg-spore-white rounded-xl" role="status"><div class="text-5xl mb-4" aria-hidden="true" data-svelte-h="svelte-idje0l">\u{1F4CB}</div> <h3 class="text-xl font-bold text-spore-dark mb-2" data-svelte-h="svelte-14qcuvf">No work orders yet</h3> <p class="text-spore-steel mb-6" data-svelte-h="svelte-jrvcoi">Create your first work order to get started</p> <button class="bg-spore-orange text-white px-6 py-3 rounded-xl hover:bg-spore-orange/90 focus:outline-none focus:ring-2 focus:ring-spore-orange focus:ring-offset-2 transition-colors text-sm font-bold" data-svelte-h="svelte-19pqfzv">+ CREATE WORK ORDER</button></div>`}</div>`;
      } while (!$$settled);
      $$unsubscribe_page();
      return $$rendered;
    });
  }
});

// .svelte-kit/output/server/nodes/21.js
var __exports22 = {};
__export(__exports22, {
  component: () => component22,
  fonts: () => fonts22,
  imports: () => imports22,
  index: () => index22,
  server: () => page_server_ts_exports19,
  server_id: () => server_id20,
  stylesheets: () => stylesheets22
});
var index22, component_cache22, component22, server_id20, imports22, stylesheets22, fonts22;
var init__22 = __esm({
  ".svelte-kit/output/server/nodes/21.js"() {
    init_page_server_ts19();
    index22 = 21;
    component22 = async () => component_cache22 ??= (await Promise.resolve().then(() => (init_page_svelte20(), page_svelte_exports20))).default;
    server_id20 = "src/routes/work-orders/+page.server.ts";
    imports22 = ["_app/immutable/nodes/21.1ae08e3f.js", "_app/immutable/chunks/_page.a9e36868.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/websocket.ff281e65.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/stores.e6b76d1c.js", "_app/immutable/chunks/constants.cc7bddc0.js", "_app/immutable/chunks/FilterBar.0110061d.js"];
    stylesheets22 = [];
    fonts22 = [];
  }
});

// .svelte-kit/output/server/chunks/mentions.js
function parseMentions(content) {
  const matches = content.match(MENTION_PATTERN);
  if (!matches)
    return [];
  return matches.map((match) => match.slice(1));
}
function formatMentionUsername(user) {
  const parts = [user.firstName, user.lastName].filter(Boolean);
  if (parts.length > 0) {
    return parts.join("").toLowerCase().replace(/\s+/g, "");
  }
  return user.email.split("@")[0].toLowerCase();
}
function linkifyMentions(content, mentions) {
  if (mentions.length === 0)
    return content;
  let result = content;
  const userMap = /* @__PURE__ */ new Map();
  mentions.forEach((m) => {
    const username = formatMentionUsername(m.mentionedUser);
    userMap.set(username, {
      id: m.mentionedUser.id,
      displayName: m.mentionedUser.firstName ? [m.mentionedUser.firstName, m.mentionedUser.lastName].filter(Boolean).join(" ") : m.mentionedUser.email
    });
  });
  result = result.replace(MENTION_PATTERN, (match, username) => {
    const user = userMap.get(username);
    if (user) {
      return `<span class="mention-highlight" data-user-id="${user.id}">@${username}</span>`;
    }
    return match;
  });
  return result;
}
var MENTION_PATTERN;
var init_mentions = __esm({
  ".svelte-kit/output/server/chunks/mentions.js"() {
    MENTION_PATTERN = /@([a-zA-Z0-9_.-]+)\b/g;
  }
});

// .svelte-kit/output/server/entries/pages/work-orders/_id_/_page.server.ts.js
var page_server_ts_exports20 = {};
__export(page_server_ts_exports20, {
  actions: () => actions18,
  load: () => load20
});
async function findUsersByUsernamePattern(prisma, pattern2, organizationId) {
  return prisma.user.findMany({
    where: {
      organizationId,
      OR: [
        { firstName: { contains: pattern2, mode: "insensitive" } },
        { lastName: { contains: pattern2, mode: "insensitive" } },
        { email: { contains: pattern2, mode: "insensitive" } }
      ]
    },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      email: true
    },
    take: 10
  });
}
async function queryMentionableUsers(prisma, organizationId) {
  return prisma.user.findMany({
    where: { organizationId, isActive: true },
    select: {
      id: true,
      firstName: true,
      lastName: true,
      email: true
    },
    orderBy: { firstName: "asc" }
  });
}
async function createMentionRecords(prisma, commentId, mentionedUserIds) {
  if (mentionedUserIds.length === 0)
    return [];
  const data = mentionedUserIds.map((mentionedUserId) => ({
    commentId,
    mentionedUserId
  }));
  return prisma.commentMention.createMany({
    data
  });
}
async function queryComments(prisma, workOrderId) {
  const comments = await prisma.workOrderComment.findMany({
    where: {
      workOrderId,
      isDeleted: false
    },
    select: {
      id: true,
      parentId: true,
      content: true,
      createdAt: true,
      updatedAt: true,
      isEdited: true,
      editedAt: true,
      isDeleted: true,
      user: {
        select: {
          id: true,
          firstName: true,
          lastName: true,
          email: true
        }
      },
      mentions: {
        include: {
          mentionedUser: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true
            }
          }
        }
      }
    },
    orderBy: { createdAt: "asc" }
  });
  return buildCommentTree(comments);
}
function buildCommentTree(comments) {
  const commentMap = /* @__PURE__ */ new Map();
  const rootComments = [];
  comments.forEach((comment) => {
    const enriched = {
      ...comment,
      user: {
        ...comment.user,
        displayName: formatUserName(comment.user)
      },
      replies: [],
      depth: 0
    };
    commentMap.set(comment.id, enriched);
    if (!comment.parentId) {
      rootComments.push(enriched);
    }
  });
  comments.forEach((comment) => {
    if (comment.parentId) {
      const parent = commentMap.get(comment.parentId);
      const child = commentMap.get(comment.id);
      if (parent && child) {
        parent.replies.push(child);
      }
    }
  });
  function calculateDepth(comment, currentDepth = 0) {
    comment.depth = currentDepth;
    comment.replies.forEach((reply) => calculateDepth(reply, currentDepth + 1));
  }
  rootComments.forEach((comment) => calculateDepth(comment));
  return rootComments;
}
async function createComment(event, prisma, data) {
  const { workOrderId, content, userId, parentId } = data;
  if (!content?.trim()) {
    return fail(400, { error: "Comment cannot be empty." });
  }
  if (content.length > MAX_COMMENT_LENGTH) {
    return fail(400, { error: `Comment is too long (max ${MAX_COMMENT_LENGTH} characters).` });
  }
  if (parentId) {
    const parentComment = await prisma.workOrderComment.findUnique({
      where: { id: parentId },
      include: { workOrder: true }
    });
    if (!parentComment) {
      return fail(404, { error: "Parent comment not found." });
    }
    if (parentComment.workOrderId !== workOrderId) {
      return fail(400, { error: "Parent comment belongs to a different work order." });
    }
    const depth = await getCommentDepth(prisma, parentId);
    if (depth >= MAX_COMMENT_DEPTH) {
      return fail(400, { error: `Maximum reply depth (${MAX_COMMENT_DEPTH}) reached.` });
    }
  }
  const workOrder = await prisma.workOrder.findUnique({
    where: { id: workOrderId },
    select: { organizationId: true }
  });
  if (!workOrder) {
    return fail(404, { error: "Work order not found." });
  }
  const user = await prisma.user.findUnique({
    where: { id: userId },
    select: { organizationId: true }
  });
  if (!user || user.organizationId !== workOrder.organizationId) {
    return fail(403, { error: "You do not have permission to comment on this work order." });
  }
  try {
    const comment = await prisma.workOrderComment.create({
      data: {
        content: content.trim(),
        workOrderId,
        userId,
        parentId: parentId || null
      },
      include: {
        user: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    const mentionedUsernames = parseMentions(content);
    if (mentionedUsernames.length > 0) {
      const mentionedUsers = await findUsersByUsernamePattern(
        prisma,
        // Use first username as hint (could improve to match all)
        mentionedUsernames[0],
        workOrder.organizationId
      );
      const matchedUsers = mentionedUsers.filter((u) => {
        const username = [u.firstName, u.lastName].filter(Boolean).join("").toLowerCase().replace(/\s+/g, "");
        return mentionedUsernames.includes(username);
      });
      if (matchedUsers.length > 0) {
        await createMentionRecords(
          prisma,
          comment.id,
          matchedUsers.map((u) => u.id)
        );
      }
    }
    broadcastToOrg(workOrder.organizationId, {
      type: "WO_COMMENT_ADDED",
      payload: {
        workOrderId,
        commentId: comment.id,
        comment: {
          id: comment.id,
          content: comment.content,
          createdAt: comment.createdAt,
          userId: comment.userId,
          userName: formatUserName(comment.user),
          parentId: comment.parentId
        }
      }
    });
    await logAudit(userId, "WORK_ORDER_COMMENT_ADDED", {
      workOrderId,
      commentId: comment.id,
      hasParent: !!comment.parentId
    });
    return { success: true, comment };
  } catch (e3) {
    logError("Error creating comment", e3, { workOrderId });
    return fail(500, { error: "Failed to create comment." });
  }
}
async function getCommentDepth(prisma, commentId) {
  let depth = 0;
  let currentId = commentId;
  while (currentId) {
    const comment = await prisma.workOrderComment.findUnique({
      where: { id: currentId },
      select: { parentId: true }
    });
    if (!comment)
      break;
    if (!comment.parentId)
      break;
    depth++;
    currentId = comment.parentId;
  }
  return depth;
}
async function updateComment(event, prisma, commentId, userId, newContent) {
  if (!newContent?.trim()) {
    return fail(400, { error: "Comment cannot be empty." });
  }
  if (newContent.length > MAX_COMMENT_LENGTH) {
    return fail(400, { error: `Comment is too long (max ${MAX_COMMENT_LENGTH} characters).` });
  }
  const existingComment = await prisma.workOrderComment.findUnique({
    where: { id: commentId },
    include: { workOrder: true }
  });
  if (!existingComment) {
    return fail(404, { error: "Comment not found." });
  }
  if (existingComment.userId !== userId) {
    return fail(403, { error: "You can only edit your own comments." });
  }
  if (existingComment.isDeleted) {
    return fail(400, { error: "Cannot edit a deleted comment." });
  }
  try {
    await prisma.commentEdit.create({
      data: {
        content: existingComment.content,
        commentId,
        userId
      }
    });
    const updated2 = await prisma.workOrderComment.update({
      where: { id: commentId },
      data: {
        content: newContent.trim(),
        isEdited: true,
        editedAt: /* @__PURE__ */ new Date()
      },
      include: {
        user: {
          select: {
            id: true,
            firstName: true,
            lastName: true,
            email: true
          }
        }
      }
    });
    await prisma.commentMention.deleteMany({
      where: { commentId }
    });
    const mentionedUsernames = parseMentions(newContent);
    if (mentionedUsernames.length > 0) {
      const matchedUsers = await findUsersByUsernamePattern(
        prisma,
        mentionedUsernames[0],
        existingComment.workOrder.organizationId
      );
      const exactMatches = matchedUsers.filter((u) => {
        const username = [u.firstName, u.lastName].filter(Boolean).join("").toLowerCase().replace(/\s+/g, "");
        return mentionedUsernames.includes(username);
      });
      if (exactMatches.length > 0) {
        await createMentionRecords(
          prisma,
          commentId,
          exactMatches.map((u) => u.id)
        );
      }
    }
    broadcastToOrg(existingComment.workOrder.organizationId, {
      type: "WO_COMMENT_UPDATED",
      payload: {
        workOrderId: existingComment.workOrderId,
        commentId,
        content: newContent.trim()
      }
    });
    await logAudit(userId, "WORK_ORDER_COMMENT_EDITED", {
      workOrderId: existingComment.workOrderId,
      commentId
    });
    return { success: true, comment: updated2 };
  } catch (e3) {
    logError("Error updating comment", e3, { commentId });
    return fail(500, { error: "Failed to update comment." });
  }
}
async function deleteComment(event, prisma, commentId, userId) {
  const existingComment = await prisma.workOrderComment.findUnique({
    where: { id: commentId },
    include: { workOrder: true }
  });
  if (!existingComment) {
    return fail(404, { error: "Comment not found." });
  }
  if (existingComment.userId !== userId) {
    return fail(403, { error: "You can only delete your own comments." });
  }
  if (existingComment.isDeleted) {
    return fail(400, { error: "Comment is already deleted." });
  }
  try {
    await prisma.workOrderComment.update({
      where: { id: commentId },
      data: {
        isDeleted: true,
        content: "[deleted]"
      }
    });
    broadcastToOrg(existingComment.workOrder.organizationId, {
      type: "WO_COMMENT_DELETED",
      payload: {
        workOrderId: existingComment.workOrderId,
        commentId
      }
    });
    await logAudit(userId, "WORK_ORDER_COMMENT_DELETED", {
      workOrderId: existingComment.workOrderId,
      commentId,
      hadReplies: true
      // Could check, but not necessary for audit
    });
    return { success: true };
  } catch (e3) {
    logError("Error deleting comment", e3, { commentId });
    return fail(500, { error: "Failed to delete comment." });
  }
}
async function verifyWorkOrderAccess(prisma, workOrderId, userId, organizationId) {
  let workOrder;
  try {
    workOrder = await prisma.workOrder.findUnique({
      where: { id: workOrderId },
      select: { organizationId: true }
    });
  } catch (e3) {
    logError("Failed to fetch work order for auth check", e3, { workOrderId, userId });
    return fail(500, { error: "Failed to verify access. Please try again." });
  }
  if (!workOrder) {
    return fail(404, { error: "Work order not found." });
  }
  if (workOrder.organizationId !== organizationId) {
    const security = SecurityManager.getInstance();
    await security.logSecurityEvent({
      event: void 0,
      action: "CHECKLIST_ACCESS_DENIED",
      details: { workOrderId, reason: "Organization mismatch" },
      severity: "WARNING",
      userId
    });
    return fail(403, { error: "You do not have permission to modify this checklist." });
  }
  return workOrder;
}
async function queryChecklistItems(prisma, workOrderId) {
  return prisma.workOrderChecklistItem.findMany({
    where: { workOrderId },
    orderBy: { position: "asc" }
  });
}
async function createChecklistItem(prisma, workOrderId, title, userId, organizationId) {
  const authResult = await verifyWorkOrderAccess(prisma, workOrderId, userId, organizationId);
  if (authResult && "status" in authResult) {
    return authResult;
  }
  try {
    const maxPositionItem = await prisma.workOrderChecklistItem.findFirst({
      where: { workOrderId },
      orderBy: { position: "desc" },
      select: { position: true }
    });
    const newPosition = (maxPositionItem?.position ?? -1) + 1;
    const item = await prisma.workOrderChecklistItem.create({
      data: {
        workOrderId,
        title: title.trim(),
        position: newPosition
      }
    });
    return { success: true, item };
  } catch (e3) {
    logError("Failed to create checklist item", e3, { workOrderId, userId });
    return fail(500, { error: "Failed to create checklist item. Please try again." });
  }
}
async function toggleChecklistItem(prisma, itemId, isCompleted, userId, organizationId) {
  let item;
  try {
    item = await prisma.workOrderChecklistItem.findUnique({
      where: { id: itemId },
      select: { workOrderId: true }
    });
  } catch (e3) {
    logError("Failed to fetch checklist item for auth check", e3, { itemId, userId });
    return fail(500, { error: "Failed to verify access. Please try again." });
  }
  if (!item) {
    return fail(404, { error: "Checklist item not found." });
  }
  const authResult = await verifyWorkOrderAccess(prisma, item.workOrderId, userId, organizationId);
  if (authResult && "status" in authResult) {
    return authResult;
  }
  try {
    const updated2 = await prisma.workOrderChecklistItem.update({
      where: { id: itemId },
      data: { isCompleted }
    });
    return { success: true, item: updated2 };
  } catch (e3) {
    logError("Failed to toggle checklist item", e3, { itemId, userId });
    return fail(500, { error: "Failed to update checklist item. Please try again." });
  }
}
async function deleteChecklistItem(prisma, itemId, userId, organizationId) {
  let item;
  try {
    item = await prisma.workOrderChecklistItem.findUnique({
      where: { id: itemId },
      select: { workOrderId: true }
    });
  } catch (e3) {
    logError("Failed to fetch checklist item for auth check", e3, { itemId, userId });
    return fail(500, { error: "Failed to verify access. Please try again." });
  }
  if (!item) {
    return fail(404, { error: "Checklist item not found." });
  }
  const authResult = await verifyWorkOrderAccess(prisma, item.workOrderId, userId, organizationId);
  if (authResult && "status" in authResult) {
    return authResult;
  }
  try {
    await prisma.workOrderChecklistItem.delete({
      where: { id: itemId }
    });
    return { success: true };
  } catch (e3) {
    logError("Failed to delete checklist item", e3, { itemId, userId });
    return fail(500, { error: "Failed to delete checklist item. Please try again." });
  }
}
var load20, actions18;
var init_page_server_ts20 = __esm({
  ".svelte-kit/output/server/entries/pages/work-orders/_id_/_page.server.ts.js"() {
    init_prisma();
    init_chunks();
    init_guards();
    init_user();
    init_security();
    init_validation();
    init_constants2();
    init_service();
    init_audit();
    init_logger();
    init_mentions();
    init_status_history();
    load20 = async (event) => {
      requireAuth(event);
      const prisma = await createRequestPrisma(event);
      const { id } = event.params;
      const workOrder = await queryWorkOrderById(prisma, id);
      if (!workOrder) {
        throw error(404, "Work order not found");
      }
      const assets2 = await queryAssetsForDropdown(prisma, event.locals.user.organizationId);
      const comments = await queryComments(prisma, id);
      const statusHistory = await queryStatusHistory(prisma, id);
      const checklistItems = await queryChecklistItems(prisma, id);
      const organizationId = event.locals.user.organizationId;
      if (!organizationId) {
        throw error(400, "User must belong to an organization");
      }
      const mentionableUsers = await queryMentionableUsers(prisma, organizationId);
      const mentionableUsersWithUsername = mentionableUsers.map((u) => ({
        ...u,
        displayName: formatUserName(u),
        mentionUsername: formatMentionUsername(u)
      }));
      return {
        workOrder,
        assets: assets2,
        comments,
        statusHistory: formatStatusHistory(statusHistory),
        mentionableUsers: mentionableUsersWithUsername,
        checklistItems
      };
    };
    actions18 = {
      updateStatus: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_status_update", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id } = event.params;
        const newStatus = formData.get("status");
        const reason = formData.get("reason");
        if (!newStatus) {
          return fail(400, { error: "Status is required" });
        }
        if (STATUSES_REQUIRING_REASON.includes(newStatus) && !reason?.trim()) {
          return fail(400, { error: "A reason is required for this status change." });
        }
        return updateWorkOrderStatus(event, prisma, id, newStatus, reason?.trim());
      },
      update: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_update", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id } = event.params;
        const title = formData.get("title");
        const description = formData.get("description");
        const assetId = formData.get("assetId");
        if (!title || title.trim() === "") {
          return fail(400, { error: "Title is required" });
        }
        if (!assetId) {
          return fail(400, { error: "Asset is required" });
        }
        return updateWorkOrderDetails(event, prisma, id, {
          title,
          description,
          assetId
        });
      },
      delete: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_delete", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const { id } = event.params;
        const result = await deleteWorkOrder(event, prisma, id);
        if (typeof result === "object" && result !== null && "success" in result && result.success === true) {
          throw redirect(303, "/work-orders");
        }
        return result;
      },
      /**
       * Add a new comment
       */
      addComment: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_comment_add", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id } = event.params;
        const validation = validateInput(workOrderCommentSchema, {
          content: formData.get("content"),
          parentId: formData.get("parentId")
        });
        if (!validation.success) {
          const firstError = Object.values(validation.errors)[0];
          return fail(400, { error: firstError });
        }
        return createComment(event, prisma, {
          workOrderId: id,
          content: validation.data.content,
          userId: event.locals.user.id,
          parentId: validation.data.parentId
        });
      },
      /**
       * Update an existing comment
       */
      updateComment: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_comment_update", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const commentId = formData.get("commentId");
        if (!commentId) {
          return fail(400, { error: "Comment ID is required." });
        }
        const validation = validateInput(workOrderCommentSchema, {
          content: formData.get("content"),
          parentId: void 0
          // Not used for updates
        });
        if (!validation.success) {
          const firstError = Object.values(validation.errors)[0];
          return fail(400, { error: firstError });
        }
        return updateComment(event, prisma, commentId, event.locals.user.id, validation.data.content);
      },
      /**
       * Delete a comment
       */
      deleteComment: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_comment_delete", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const commentId = formData.get("commentId");
        if (!commentId) {
          return fail(400, { error: "Comment ID is required." });
        }
        return deleteComment(event, prisma, commentId, event.locals.user.id);
      },
      /**
       * Add a checklist item
       */
      addChecklistItem: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_checklist_add", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const { id } = event.params;
        const validation = validateInput(workOrderChecklistSchema, {
          title: formData.get("title")
        });
        if (!validation.success) {
          const firstError = Object.values(validation.errors)[0];
          return fail(400, { error: firstError });
        }
        const userId = event.locals.user.id;
        const organizationId = event.locals.user.organizationId;
        return createChecklistItem(prisma, id, validation.data.title, userId, organizationId);
      },
      /**
       * Toggle checklist item completion
       */
      toggleChecklistItem: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_checklist_toggle", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const itemId = formData.get("itemId");
        const isCompleted = formData.get("isCompleted") === "true";
        const userId = event.locals.user.id;
        const organizationId = event.locals.user.organizationId;
        if (!itemId) {
          return fail(400, { error: "Item ID is required." });
        }
        return toggleChecklistItem(prisma, itemId, isCompleted, userId, organizationId);
      },
      /**
       * Delete a checklist item
       */
      deleteChecklistItem: async (event) => {
        const security = SecurityManager.getInstance();
        const rateLimitResult = await security.checkRateLimit(
          { event, action: "work_order_checklist_delete", userId: event.locals.user?.id },
          SECURITY_RATE_LIMITS.FORM
        );
        if (!rateLimitResult.success) {
          if (rateLimitResult.blocked) {
            return fail(429, { error: "Too many requests. Your IP has been temporarily blocked." });
          }
          return fail(429, { error: "Too many requests. Please try again later." });
        }
        const prisma = await createRequestPrisma(event);
        const formData = await event.request.formData();
        const itemId = formData.get("itemId");
        const userId = event.locals.user.id;
        const organizationId = event.locals.user.organizationId;
        if (!itemId) {
          return fail(400, { error: "Item ID is required." });
        }
        return deleteChecklistItem(prisma, itemId, userId, organizationId);
      }
    };
  }
});

// .svelte-kit/output/server/entries/pages/work-orders/_id_/_page.svelte.js
var page_svelte_exports21 = {};
__export(page_svelte_exports21, {
  default: () => Page21
});
function formatStatus$1(status) {
  return status.replace(/_/g, " ");
}
function formatTimeAgo(date5) {
  const now = /* @__PURE__ */ new Date();
  const seconds = Math.floor((now.getTime() - date5.getTime()) / 1e3);
  if (seconds < 60)
    return "just now";
  if (seconds < 3600)
    return `${Math.floor(seconds / 60)}m ago`;
  if (seconds < 86400)
    return `${Math.floor(seconds / 3600)}h ago`;
  if (seconds < 604800)
    return `${Math.floor(seconds / 86400)}d ago`;
  return date5.toLocaleDateString();
}
function getReplyCount(comment) {
  if (!comment.replies || comment.replies.length === 0)
    return 0;
  return comment.replies.reduce((acc, reply) => acc + 1 + getReplyCount(reply), 0);
}
function formatStatus2(status) {
  return status.replace(/_/g, " ");
}
var StatusHistory, Checklist, MAX_COMMENT_LENGTH2, CommentForm, MAX_DEPTH2, Comment, CommentThread, Page21;
var init_page_svelte21 = __esm({
  ".svelte-kit/output/server/entries/pages/work-orders/_id_/_page.svelte.js"() {
    init_ssr();
    init_devalue();
    init_constants2();
    init_mentions();
    StatusHistory = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let { history } = $$props;
      if ($$props.history === void 0 && $$bindings.history && history !== void 0)
        $$bindings.history(history);
      return `<div class="bg-spore-white rounded-xl p-6"><h2 class="text-lg font-extrabold text-spore-dark mb-4 flex items-center gap-2"><span data-svelte-h="svelte-stchci">\u{1F4CB}</span> <span data-svelte-h="svelte-8dhk2s">Status History</span></h2> ${history.length === 0 ? `<p class="text-spore-steel text-sm italic" data-svelte-h="svelte-kqr86c">No status changes recorded yet.</p>` : `<div class="relative"> <div class="absolute left-[7px] top-2 bottom-2 w-0.5 bg-spore-cream"></div> <div class="space-y-4">${each(history, (entry, index24) => {
        return `<div class="relative flex gap-4"> <div class="flex-shrink-0 w-4 h-4 rounded-full bg-spore-forest border-2 border-spore-cream z-10 mt-1"></div>  <div class="flex-1 min-w-0 pb-2"><div class="flex flex-wrap items-center gap-2 mb-1"><span class="${"px-2 py-0.5 text-xs font-bold rounded " + escape(getStatusColor(entry.fromStatus), true)}">${escape(formatStatus$1(entry.fromStatus))}</span> <span class="text-spore-steel" data-svelte-h="svelte-1s1x4f8">\u2192</span> <span class="${"px-2 py-0.5 text-xs font-bold rounded " + escape(getStatusColor(entry.toStatus), true)}">${escape(formatStatus$1(entry.toStatus))} </span></div> <div class="text-sm text-spore-dark">${entry.user ? `<span class="font-semibold">${escape(entry.user.displayName)}</span>
									changed the status` : `Status changed`} <span class="text-spore-steel">${escape(new Date(entry.createdAt).toLocaleDateString())} at ${escape(new Date(entry.createdAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" }))} </span></div> ${entry.reason ? `<div class="mt-1 text-sm text-spore-steel italic">Reason: &quot;${escape(entry.reason)}&quot;
								</div>` : ``}</div> </div>`;
      })}</div></div>`}</div>`;
    });
    Checklist = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let incompleteCount;
      let completedCount;
      let { items } = $$props;
      let { workOrderId } = $$props;
      if ($$props.items === void 0 && $$bindings.items && items !== void 0)
        $$bindings.items(items);
      if ($$props.workOrderId === void 0 && $$bindings.workOrderId && workOrderId !== void 0)
        $$bindings.workOrderId(workOrderId);
      incompleteCount = items.filter((i) => !i.isCompleted).length;
      completedCount = items.filter((i) => i.isCompleted).length;
      items.length > 0 && incompleteCount === 0;
      return `<div class="bg-spore-white rounded-xl p-6"><h2 class="text-lg font-extrabold text-spore-dark mb-4 flex items-center justify-between"><div class="flex items-center gap-2"><span data-svelte-h="svelte-d2qxsh">\u2713</span> <span data-svelte-h="svelte-wwmsq">Checklist</span></div> ${items.length > 0 ? `<span class="text-sm font-normal text-spore-steel">${escape(completedCount)}/${escape(items.length)} done</span>` : ``}</h2>  ${items.length === 0 ? `<p class="text-spore-steel text-sm italic mb-4" data-svelte-h="svelte-583qw3">No checklist items yet.</p>` : `<div class="space-y-2 mb-4">${each(items, (item) => {
        return `<div class="${"group flex items-center gap-3 p-3 rounded-lg border " + escape(
          item.isCompleted ? "bg-spore-forest/5 border-spore-forest/20" : "bg-white border-spore-cream hover:border-spore-orange/30",
          true
        ) + " transition-colors"}"> <form method="POST" action="?/toggleChecklistItem" class="flex-shrink-0"><input type="hidden" name="itemId"${add_attribute("value", item.id, 0)}> <input type="hidden" name="isCompleted"${add_attribute("value", item.isCompleted ? "false" : "true", 0)}> <button type="submit" class="${"w-6 h-6 rounded border-2 flex items-center justify-center transition-colors " + escape(
          item.isCompleted ? "bg-spore-forest border-spore-forest text-white" : "border-spore-steel hover:border-spore-orange",
          true
        )}"${add_attribute("aria-label", item.isCompleted ? "Mark incomplete" : "Mark complete", 0)}>${item.isCompleted ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path></svg>` : ``} </button></form>  <span class="${"flex-1 text-sm " + escape(
          item.isCompleted ? "text-spore-steel line-through" : "text-spore-dark",
          true
        )}">${escape(item.title)}</span>  <form method="POST" action="?/deleteChecklistItem" class="flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity"><input type="hidden" name="itemId"${add_attribute("value", item.id, 0)}> <button type="submit" class="text-spore-steel hover:text-red-500 p-1 rounded" aria-label="Delete item"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path></svg> </button></form> </div>`;
      })}</div>`}  ${`<button class="w-full px-4 py-2 rounded-lg border border-dashed border-spore-cream text-spore-steel text-sm font-semibold hover:border-spore-orange hover:text-spore-orange transition-colors" data-svelte-h="svelte-7pzuw7">+ Add item</button>`}</div>`;
    });
    MAX_COMMENT_LENGTH2 = 5e3;
    CommentForm = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let remainingChars;
      let { mentionableUsers } = $$props;
      let { parentId = null } = $$props;
      let { placeholder = "Write a comment..." } = $$props;
      let { submitLabel = "Comment" } = $$props;
      let { onCancel = null } = $$props;
      let { autofocus = false } = $$props;
      let textareaElement;
      let content = "";
      if ($$props.mentionableUsers === void 0 && $$bindings.mentionableUsers && mentionableUsers !== void 0)
        $$bindings.mentionableUsers(mentionableUsers);
      if ($$props.parentId === void 0 && $$bindings.parentId && parentId !== void 0)
        $$bindings.parentId(parentId);
      if ($$props.placeholder === void 0 && $$bindings.placeholder && placeholder !== void 0)
        $$bindings.placeholder(placeholder);
      if ($$props.submitLabel === void 0 && $$bindings.submitLabel && submitLabel !== void 0)
        $$bindings.submitLabel(submitLabel);
      if ($$props.onCancel === void 0 && $$bindings.onCancel && onCancel !== void 0)
        $$bindings.onCancel(onCancel);
      if ($$props.autofocus === void 0 && $$bindings.autofocus && autofocus !== void 0)
        $$bindings.autofocus(autofocus);
      remainingChars = MAX_COMMENT_LENGTH2 - content.length;
      return `<div class="space-y-3"><form method="POST" action="?/addComment"><div class="relative"><textarea name="content"${add_attribute("placeholder", placeholder, 0)} rows="3" class="w-full px-4 py-3 rounded-lg border border-spore-cream bg-spore-cream/20 text-spore-dark focus:outline-none focus:ring-2 focus:ring-spore-orange resize-none" required${add_attribute("this", textareaElement, 0)}>${escape("")}</textarea>  <div class="absolute bottom-2 right-2 text-xs text-spore-steel">${escape(remainingChars)} remaining</div>  ${``}</div> <div class="flex gap-3"><button type="submit" ${!content.trim() || content.length > MAX_COMMENT_LENGTH2 ? "disabled" : ""} class="bg-spore-forest text-white px-6 py-2 rounded-lg font-bold text-sm hover:bg-spore-forest/90 disabled:opacity-50 disabled:cursor-not-allowed transition-colors">${escape(submitLabel)}</button> ${onCancel ? `<button type="button" class="px-6 py-2 rounded-lg font-bold text-sm text-spore-steel hover:bg-spore-cream transition-colors" data-svelte-h="svelte-nw0b6j">Cancel</button>` : ``}</div></form></div>`;
    });
    MAX_DEPTH2 = 5;
    Comment = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let canReply;
      let canEdit;
      let isOwnComment;
      let showReplyButton;
      let displayName;
      let initials;
      let timeAgo;
      let linkifiedContent;
      let { comment } = $$props;
      let { currentUserId } = $$props;
      let { mentionableUsers } = $$props;
      let { maxDepth = 5 } = $$props;
      let isEditing = false;
      let showReplies = true;
      if ($$props.comment === void 0 && $$bindings.comment && comment !== void 0)
        $$bindings.comment(comment);
      if ($$props.currentUserId === void 0 && $$bindings.currentUserId && currentUserId !== void 0)
        $$bindings.currentUserId(currentUserId);
      if ($$props.mentionableUsers === void 0 && $$bindings.mentionableUsers && mentionableUsers !== void 0)
        $$bindings.mentionableUsers(mentionableUsers);
      if ($$props.maxDepth === void 0 && $$bindings.maxDepth && maxDepth !== void 0)
        $$bindings.maxDepth(maxDepth);
      canReply = comment.depth < MAX_DEPTH2;
      canEdit = comment.user.id === currentUserId;
      isOwnComment = comment.user.id === currentUserId;
      showReplyButton = canReply && !isEditing;
      displayName = comment.user.displayName;
      initials = displayName.split(" ").map((n2) => n2[0]).join("").toUpperCase().slice(0, 2);
      timeAgo = formatTimeAgo(new Date(comment.createdAt));
      linkifiedContent = linkifyMentions(comment.content, comment.mentions);
      return `<div class="${"comment " + escape(
        comment.depth > 0 ? "ml-4 sm:ml-8 pl-4 sm:pl-6 border-l-2 border-spore-cream" : "",
        true
      )}"><div class="${"bg-spore-white rounded-lg p-4 " + escape(comment.depth > 0 ? "bg-spore-cream/30" : "", true)}">${` <div class="flex gap-3"> <div class="flex-shrink-0 w-8 h-8 rounded-full bg-spore-steel/20 flex items-center justify-center text-spore-steel font-bold text-xs">${escape(initials)}</div>  <div class="flex-1 min-w-0"><div class="flex items-center gap-2 flex-wrap"><span class="font-semibold text-spore-dark text-sm">${escape(displayName)}</span> <span class="text-spore-steel text-xs">${escape(timeAgo)}</span> ${comment.isEdited ? `<span class="text-spore-steel text-xs italic" title="${"Edited " + escape(
        comment.editedAt ? new Date(comment.editedAt).toLocaleString() : "",
        true
      )}">(edited)</span>` : ``}</div>  <div class="mt-1 text-sm text-spore-dark whitespace-pre-wrap break-words"><!-- HTML_TAG_START -->${linkifiedContent}<!-- HTML_TAG_END --></div>  <div class="mt-2 flex gap-3">${showReplyButton ? `<button class="text-xs font-semibold text-spore-steel hover:text-spore-orange transition-colors" data-svelte-h="svelte-11aykou">Reply</button>` : ``} ${canEdit && !comment.isDeleted ? `<button class="text-xs font-semibold text-spore-steel hover:text-spore-orange transition-colors" data-svelte-h="svelte-10p750a">Edit</button>` : ``} ${isOwnComment && !comment.isDeleted ? `<form method="POST" action="?/deleteComment"><input type="hidden" name="commentId"${add_attribute("value", comment.id, 0)}> <button type="submit" class="text-xs font-semibold text-red-500 hover:text-red-600 transition-colors" data-svelte-h="svelte-x952ej">Delete</button></form>` : ``}</div>  ${``}</div></div>`}</div>  ${comment.replies && comment.replies.length > 0 ? `<div class="mt-2 space-y-2">${comment.replies.length > 2 && !showReplies ? `<button class="text-xs font-semibold text-spore-steel hover:text-spore-orange transition-colors ml-1">View ${escape(comment.replies.length)} ${escape(comment.replies.length === 1 ? "reply" : "replies")}</button>` : ``} ${`${each(comment.replies, (reply) => {
        return `${validate_component(Comment, "svelte:self").$$render(
          $$result,
          {
            comment: reply,
            currentUserId,
            mentionableUsers,
            maxDepth
          },
          {},
          {}
        )}`;
      })} ${comment.replies.length > 2 ? `<button class="text-xs font-semibold text-spore-steel hover:text-spore-orange transition-colors ml-1 mt-2" data-svelte-h="svelte-cghqzl">Hide replies</button>` : ``}`}</div>` : ``} </div>`;
    });
    CommentThread = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let sortedComments;
      let commentCount;
      let totalReplies;
      let { comments } = $$props;
      let { currentUserId } = $$props;
      let { mentionableUsers } = $$props;
      let { workOrderId } = $$props;
      if ($$props.comments === void 0 && $$bindings.comments && comments !== void 0)
        $$bindings.comments(comments);
      if ($$props.currentUserId === void 0 && $$bindings.currentUserId && currentUserId !== void 0)
        $$bindings.currentUserId(currentUserId);
      if ($$props.mentionableUsers === void 0 && $$bindings.mentionableUsers && mentionableUsers !== void 0)
        $$bindings.mentionableUsers(mentionableUsers);
      if ($$props.workOrderId === void 0 && $$bindings.workOrderId && workOrderId !== void 0)
        $$bindings.workOrderId(workOrderId);
      sortedComments = [...comments].reverse();
      commentCount = comments.length;
      totalReplies = comments.reduce((acc, comment) => acc + getReplyCount(comment), 0);
      return `<div class="bg-spore-white rounded-xl p-6"><h2 class="text-lg font-extrabold text-spore-dark mb-4 flex items-center gap-2"><span data-svelte-h="svelte-1rhak6r">\u{1F4AC}</span> <span data-svelte-h="svelte-ki1h94">Comments</span> <span class="text-spore-steel font-normal text-sm">(${escape(commentCount)} ${escape(commentCount === 1 ? "comment" : "comments")} ${escape(totalReplies > 0 ? `, ${totalReplies} ${totalReplies === 1 ? "reply" : "replies"}` : "")})</span></h2>  <div class="mb-6 pb-6 border-b border-spore-cream">${validate_component(CommentForm, "CommentForm").$$render(
        $$result,
        {
          mentionableUsers,
          placeholder: "Add a comment... Use @ to mention someone",
          submitLabel: "Post Comment"
        },
        {},
        {}
      )}</div>  ${comments.length > 1 ? `<div class="flex items-center gap-2 mb-4"><span class="text-sm text-spore-steel" data-svelte-h="svelte-4r7bgb">Sort by:</span> <button class="${"text-sm font-semibold " + escape(
        "text-spore-orange",
        true
      ) + " transition-colors"}">Newest</button> <span class="text-spore-cream" data-svelte-h="svelte-12yd3tl">|</span> <button class="${"text-sm font-semibold " + escape(
        "text-spore-steel hover:text-spore-orange",
        true
      ) + " transition-colors"}">Oldest</button></div>` : ``}  ${sortedComments.length === 0 ? `<div class="text-center py-8"><p class="text-spore-steel italic" data-svelte-h="svelte-11odky4">No comments yet. Be the first to comment!</p></div>` : `<div class="space-y-4">${each(sortedComments, (comment) => {
        return `${validate_component(Comment, "Comment").$$render(
          $$result,
          {
            comment,
            currentUserId,
            mentionableUsers,
            maxDepth: 5
          },
          {},
          {}
        )}`;
      })}</div>`}</div>`;
    });
    Page21 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
      let workOrder;
      let comments;
      let statusHistory;
      let checklistItems;
      let mentionableUsers;
      let currentUser;
      let { data } = $$props;
      let selectedStatus = null;
      const statuses = WORK_ORDER_STATUSES;
      if ($$props.data === void 0 && $$bindings.data && data !== void 0)
        $$bindings.data(data);
      workOrder = data.workOrder;
      data.assets || [];
      comments = data.comments || [];
      statusHistory = data.statusHistory || [];
      checklistItems = data.checklistItems || [];
      mentionableUsers = data.mentionableUsers || [];
      currentUser = data.user;
      return `<div class="max-w-4xl mx-auto px-4 py-10">${` <div class="bg-spore-white rounded-xl overflow-hidden"> <div class="bg-spore-dark p-6"><div class="flex flex-col sm:flex-row sm:justify-between sm:items-start gap-4"><div><h1 class="text-2xl font-extrabold text-spore-cream">${escape(workOrder.title)}</h1> <p class="text-spore-cream/60 mt-1 text-sm">Created ${escape(new Date(workOrder.createdAt).toLocaleDateString())}</p></div> <span class="${"px-4 py-2 text-sm font-bold uppercase tracking-wide rounded-full " + escape(getStatusColor(workOrder.status), true)}">${escape(formatStatus2(workOrder.status))}</span></div></div>  <div class="p-6 space-y-6"> <div class="grid grid-cols-1 sm:grid-cols-2 gap-6"><div><h3 class="text-xs font-bold text-spore-steel uppercase tracking-wide mb-2" data-svelte-h="svelte-exijn3">Asset</h3> <p class="text-spore-dark font-semibold">${escape(workOrder.asset?.name || "Unassigned")}</p></div> <div><h3 class="text-xs font-bold text-spore-steel uppercase tracking-wide mb-2" data-svelte-h="svelte-2zeft2">Location</h3> <p class="text-spore-dark font-semibold">${workOrder.asset?.room ? `${escape(workOrder.asset.room.site?.name ?? "Unknown Site")} \u2022 Room ${escape(workOrder.asset.room.name ?? "Unknown Room")} ${workOrder.asset.room.building ? `\u2022 ${escape(workOrder.asset.room.building.name ?? "Unknown Building")}` : ``} ${workOrder.asset.room.floor ? `\u2022 Floor ${escape(workOrder.asset.room.floor)}` : ``}` : `No location`}</p></div> <div><h3 class="text-xs font-bold text-spore-steel uppercase tracking-wide mb-2" data-svelte-h="svelte-11fnt6e">Last Updated</h3> <p class="text-spore-dark font-semibold">${escape(new Date(workOrder.updatedAt).toLocaleString())}</p></div></div>  ${workOrder.description ? `<div><h3 class="text-xs font-bold text-spore-steel uppercase tracking-wide mb-2" data-svelte-h="svelte-rq73nx">Description</h3> <p class="text-spore-dark whitespace-pre-wrap">${escape(workOrder.description)}</p></div>` : ``}  <div class="border-t border-spore-cream pt-6"><h3 class="text-xs font-bold text-spore-steel uppercase tracking-wide mb-4" data-svelte-h="svelte-c3uwlf">Change Status</h3>  <div class="space-y-4"><div class="flex flex-wrap gap-2">${each(statuses, (status) => {
        return `${workOrder.status !== status ? `<button class="${"px-4 py-2 rounded-lg text-sm font-bold transition-colors " + escape(
          selectedStatus === status ? "ring-2 ring-offset-2 ring-spore-orange" : "",
          true
        ) + " " + escape(getStatusColor(status), true) + " hover:opacity-80"}">${escape(status.replace("_", " "))} </button>` : ``}`;
      })}</div>  ${``}</div></div>  <div class="border-t border-spore-cream pt-6 flex gap-4"><button class="bg-spore-forest text-white px-6 py-3 rounded-lg font-bold text-sm hover:bg-spore-forest/90 transition-colors" data-svelte-h="svelte-e0q83b">EDIT WORK ORDER</button> <form method="POST" action="?/delete"><button type="submit" class="px-6 py-3 rounded-lg font-bold text-sm text-red-600 border border-red-200 hover:bg-red-50 transition-colors" data-svelte-h="svelte-1jld8fa">DELETE</button></form></div></div></div>`}  <div class="max-w-4xl mx-auto px-4 py-6">${validate_component(StatusHistory, "StatusHistory").$$render($$result, { history: statusHistory }, {}, {})}</div>  <div class="max-w-4xl mx-auto px-4 py-6">${validate_component(Checklist, "Checklist").$$render(
        $$result,
        {
          items: checklistItems,
          workOrderId: workOrder.id
        },
        {},
        {}
      )}</div>  <div class="max-w-4xl mx-auto px-4 py-6">${validate_component(CommentThread, "CommentThread").$$render(
        $$result,
        {
          comments,
          currentUserId: currentUser?.id || "",
          mentionableUsers,
          workOrderId: workOrder.id
        },
        {},
        {}
      )}</div></div>`;
    });
  }
});

// .svelte-kit/output/server/nodes/22.js
var __exports23 = {};
__export(__exports23, {
  component: () => component23,
  fonts: () => fonts23,
  imports: () => imports23,
  index: () => index23,
  server: () => page_server_ts_exports20,
  server_id: () => server_id21,
  stylesheets: () => stylesheets23
});
var index23, component_cache23, component23, server_id21, imports23, stylesheets23, fonts23;
var init__23 = __esm({
  ".svelte-kit/output/server/nodes/22.js"() {
    init_page_server_ts20();
    index23 = 22;
    component23 = async () => component_cache23 ??= (await Promise.resolve().then(() => (init_page_svelte21(), page_svelte_exports21))).default;
    server_id21 = "src/routes/work-orders/[id]/+page.server.ts";
    imports23 = ["_app/immutable/chunks/22.37b2d588.js", "_app/immutable/chunks/_page.a2bc2991.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js", "_app/immutable/chunks/forms.4d10594c.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/constants.cc7bddc0.js"];
    stylesheets23 = [];
    fonts23 = [];
  }
});

// .svelte-kit/output/server/entries/endpoints/api/activity/_server.ts.js
var server_ts_exports = {};
__export(server_ts_exports, {
  GET: () => GET
});
var activityCache, CACHE_TTL, GET;
var init_server_ts = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/activity/_server.ts.js"() {
    init_chunks();
    init_prisma();
    activityCache = /* @__PURE__ */ new Map();
    CACHE_TTL = 5e3;
    GET = async ({ locals, url: url2 }) => {
      try {
        const orgId = locals.user?.organizationId;
        if (!orgId) {
          return json({ error: "Unauthorized" }, { status: 401 });
        }
        const now = Date.now();
        const cacheKey = orgId;
        const cached2 = activityCache.get(cacheKey);
        if (cached2 && now - cached2.timestamp < CACHE_TTL) {
          return json({
            activities: cached2.activities,
            cached: true
          });
        }
        const prisma = await createRequestPrisma({ locals });
        const recentWorkOrders = await prisma.workOrder.findMany({
          where: {
            organizationId: orgId,
            updatedAt: {
              gte: new Date(now - 6e4)
              // Last minute of activity
            }
          },
          include: {
            Asset: true,
            User_WorkOrder_assignedToIdToUser: {
              select: {
                id: true,
                firstName: true,
                email: true
              }
            }
          },
          orderBy: {
            updatedAt: "desc"
          },
          take: 20
        });
        const activities = recentWorkOrders.map((wo) => ({
          type: "WO_UPDATE",
          payload: {
            id: wo.id,
            title: wo.title,
            status: wo.status,
            assetName: wo.Asset?.name || "Unknown Asset",
            assignedTo: wo.User_WorkOrder_assignedToIdToUser?.firstName || wo.User_WorkOrder_assignedToIdToUser?.email || "Unassigned"
          },
          timestamp: wo.updatedAt.getTime()
        }));
        activityCache.set(cacheKey, {
          activities,
          timestamp: now
        });
        return json({
          activities,
          cached: false
        });
      } catch (error47) {
        console.error("[Activity API] Error:", error47);
        return json({ error: "Internal server error" }, { status: 500 });
      }
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/api/security/blocks/_server.ts.js
var server_ts_exports2 = {};
__export(server_ts_exports2, {
  DELETE: () => DELETE,
  GET: () => GET2,
  POST: () => POST
});
var GET2, POST, DELETE;
var init_server_ts2 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/security/blocks/_server.ts.js"() {
    init_chunks();
    init_security();
    GET2 = async ({ locals, url: url2 }) => {
      if (!locals.user || locals.user.role !== "ADMIN") {
        return json({ error: "Unauthorized" }, { status: 403 });
      }
      const security = SecurityManager.getInstance();
      const limit = parseInt(url2.searchParams.get("limit") || "50");
      const offset = parseInt(url2.searchParams.get("offset") || "0");
      try {
        const result = await security.getBlockedIPs(
          limit,
          offset,
          locals.user.organizationId ?? void 0
        );
        return json(result);
      } catch (error47) {
        console.error("Blocked IPs API error:", error47);
        return json({ error: "Failed to fetch blocked IPs" }, { status: 500 });
      }
    };
    POST = async ({ locals, request }) => {
      if (!locals.user || locals.user.role !== "ADMIN") {
        return json({ error: "Unauthorized" }, { status: 403 });
      }
      if (!locals.user.organizationId) {
        return json({ error: "Organization context required" }, { status: 400 });
      }
      const security = SecurityManager.getInstance();
      try {
        const { ipAddress, reason, severity } = await request.json();
        if (!ipAddress || !reason) {
          return json({ error: "IP address and reason are required" }, { status: 400 });
        }
        await security.blockIP(
          ipAddress,
          reason,
          severity || "TEMPORARY",
          locals.user.id,
          locals.user.organizationId
        );
        return json({ success: true, message: "IP blocked successfully" });
      } catch (error47) {
        console.error("Block IP API error:", error47);
        return json({ error: "Failed to block IP" }, { status: 500 });
      }
    };
    DELETE = async ({ locals, request }) => {
      if (!locals.user || locals.user.role !== "ADMIN") {
        return json({ error: "Unauthorized" }, { status: 403 });
      }
      const security = SecurityManager.getInstance();
      try {
        const { ipAddress } = await request.json();
        if (!ipAddress) {
          return json({ error: "IP address is required" }, { status: 400 });
        }
        await security.unblockIP(ipAddress, locals.user.id);
        return json({ success: true, message: "IP unblocked successfully" });
      } catch (error47) {
        console.error("Unblock IP API error:", error47);
        return json({ error: "Failed to unblock IP" }, { status: 500 });
      }
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/api/security/event-logs/_server.ts.js
var server_ts_exports3 = {};
__export(server_ts_exports3, {
  GET: () => GET3
});
var GET3;
var init_server_ts3 = __esm({
  ".svelte-kit/output/server/entries/endpoints/api/security/event-logs/_server.ts.js"() {
    init_chunks();
    init_security();
    GET3 = async ({ locals, url: url2 }) => {
      if (!locals.user || locals.user.role !== "ADMIN") {
        return json({ error: "Unauthorized" }, { status: 403 });
      }
      const security = SecurityManager.getInstance();
      const severity = url2.searchParams.get("severity") || void 0;
      const action = url2.searchParams.get("action") || void 0;
      const ipAddress = url2.searchParams.get("ipAddress") || void 0;
      const limit = parseInt(url2.searchParams.get("limit") || "50");
      const offset = parseInt(url2.searchParams.get("offset") || "0");
      const startDate = url2.searchParams.get("startDate") ? new Date(url2.searchParams.get("startDate")) : void 0;
      const endDate = url2.searchParams.get("endDate") ? new Date(url2.searchParams.get("endDate")) : void 0;
      try {
        const result = await security.getSecurityLogs({
          severity,
          action,
          ipAddress,
          limit,
          offset,
          startDate,
          endDate,
          organizationId: locals.user.organizationId ?? void 0
          // Filter by organization
        });
        return json(result);
      } catch (error47) {
        console.error("Security logs API error:", error47);
        return json({ error: "Failed to fetch security logs" }, { status: 500 });
      }
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/auth/logout/_server.ts.js
var server_ts_exports4 = {};
__export(server_ts_exports4, {
  POST: () => POST2
});
var POST2;
var init_server_ts4 = __esm({
  ".svelte-kit/output/server/entries/endpoints/auth/logout/_server.ts.js"() {
    init_prisma();
    init_environment();
    POST2 = async (event) => {
      initEnvFromEvent(event);
      const sessionId = event.cookies.get("spore_session");
      console.log("[LOGOUT] Session ID:", sessionId || "NOT FOUND");
      if (sessionId) {
        const client = await getPrisma();
        try {
          await client.session.delete({ where: { id: sessionId } });
          console.log("[LOGOUT] Session deleted successfully");
        } catch (error47) {
          console.error("[LOGOUT] Failed to delete session:", error47);
        }
      } else {
        console.log("[LOGOUT] No session ID found, nothing to delete");
      }
      event.cookies.set("spore_session", "", {
        path: "/",
        httpOnly: true,
        sameSite: "strict",
        secure: !dev,
        expires: /* @__PURE__ */ new Date(0),
        maxAge: 0
      });
      console.log("[LOGOUT] Cookie deleted via cookies.set()");
      return new Response(null, {
        status: 303,
        headers: {
          "Location": "/auth/login"
        }
      });
    };
  }
});

// .svelte-kit/output/server/entries/endpoints/favicon.ico/_server.ts.js
var server_ts_exports5 = {};
__export(server_ts_exports5, {
  GET: () => GET4
});
var GET4;
var init_server_ts5 = __esm({
  ".svelte-kit/output/server/entries/endpoints/favicon.ico/_server.ts.js"() {
    init_chunks();
    GET4 = async () => {
      throw redirect(302, "/favicon.png");
    };
  }
});

// .svelte-kit/output/server/index.js
init_true();
init_internal();
init_chunks();
init_devalue();
init_index2();
var import_cookie = __toESM(require_dist2(), 1);
var set_cookie_parser = __toESM(require_set_cookie(), 1);
var SVELTE_KIT_ASSETS = "/_svelte_kit_assets";
var ENDPOINT_METHODS = ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS", "HEAD"];
var PAGE_METHODS = ["GET", "POST", "HEAD"];
function negotiate(accept, types) {
  const parts = [];
  accept.split(",").forEach((str, i) => {
    const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
    if (match) {
      const [, type, subtype, q = "1"] = match;
      parts.push({ type, subtype, q: +q, i });
    }
  });
  parts.sort((a, b) => {
    if (a.q !== b.q) {
      return b.q - a.q;
    }
    if (a.subtype === "*" !== (b.subtype === "*")) {
      return a.subtype === "*" ? 1 : -1;
    }
    if (a.type === "*" !== (b.type === "*")) {
      return a.type === "*" ? 1 : -1;
    }
    return a.i - b.i;
  });
  let accepted;
  let min_priority = Infinity;
  for (const mimetype of types) {
    const [type, subtype] = mimetype.split("/");
    const priority = parts.findIndex(
      (part) => (part.type === type || part.type === "*") && (part.subtype === subtype || part.subtype === "*")
    );
    if (priority !== -1 && priority < min_priority) {
      accepted = mimetype;
      min_priority = priority;
    }
  }
  return accepted;
}
function is_content_type(request, ...types) {
  const type = request.headers.get("content-type")?.split(";", 1)[0].trim() ?? "";
  return types.includes(type.toLowerCase());
}
function is_form_content_type(request) {
  return is_content_type(
    request,
    "application/x-www-form-urlencoded",
    "multipart/form-data",
    "text/plain"
  );
}
function exec(match, params, matchers) {
  const result = {};
  const values = match.slice(1);
  const values_needing_match = values.filter((value) => value !== void 0);
  let buffered = 0;
  for (let i = 0; i < params.length; i += 1) {
    const param = params[i];
    let value = values[i - buffered];
    if (param.chained && param.rest && buffered) {
      value = values.slice(i - buffered, i + 1).filter((s22) => s22).join("/");
      buffered = 0;
    }
    if (value === void 0) {
      if (param.rest)
        result[param.name] = "";
      continue;
    }
    if (!param.matcher || matchers[param.matcher](value)) {
      result[param.name] = value;
      const next_param = params[i + 1];
      const next_value = values[i + 1];
      if (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {
        buffered = 0;
      }
      if (!next_param && !next_value && Object.keys(result).length === values_needing_match.length) {
        buffered = 0;
      }
      continue;
    }
    if (param.optional && param.chained) {
      buffered++;
      continue;
    }
    return;
  }
  if (buffered)
    return;
  return result;
}
function coalesce_to_error(err) {
  return err instanceof Error || err && /** @type {any} */
  err.name && /** @type {any} */
  err.message ? (
    /** @type {Error} */
    err
  ) : new Error(JSON.stringify(err));
}
function normalize_error(error210) {
  return (
    /** @type {import('../runtime/control.js').Redirect | import('../runtime/control.js').HttpError | Error} */
    error210
  );
}
function method_not_allowed(mod, method) {
  return text(`${method} method not allowed`, {
    status: 405,
    headers: {
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: allowed_methods(mod).join(", ")
    }
  });
}
function allowed_methods(mod) {
  const allowed = ENDPOINT_METHODS.filter((method) => method in mod);
  if ("GET" in mod || "HEAD" in mod)
    allowed.push("HEAD");
  return allowed;
}
function static_error_page(options2, status, message) {
  let page2 = options2.templates.error({ status, message });
  {
    page2 = page2.replace("</head>", '<script type="module" src="/@vite/client"><\/script></head>');
  }
  return text(page2, {
    headers: { "content-type": "text/html; charset=utf-8" },
    status
  });
}
async function handle_fatal_error(event, options2, error210) {
  error210 = error210 instanceof HttpError ? error210 : coalesce_to_error(error210);
  const status = error210 instanceof HttpError ? error210.status : 500;
  const body = await handle_error_and_jsonify(event, options2, error210);
  const type = negotiate(event.request.headers.get("accept") || "text/html", [
    "application/json",
    "text/html"
  ]);
  if (event.isDataRequest || type === "application/json") {
    return json(body, {
      status
    });
  }
  return static_error_page(options2, status, body.message);
}
async function handle_error_and_jsonify(event, options2, error210) {
  if (error210 instanceof HttpError) {
    return error210.body;
  }
  return await options2.hooks.handleError({ error: error210, event }) ?? {
    message: event.route.id === null && error210 instanceof NotFound ? "Not Found" : "Internal Error"
  };
}
function redirect_response(status, location) {
  const response = new Response(void 0, {
    status,
    headers: { location }
  });
  return response;
}
function clarify_devalue_error(event, error210) {
  if (error210.path) {
    return `Data returned from \`load\` while rendering ${event.route.id} is not serializable: ${error210.message} (data${error210.path})`;
  }
  if (error210.path === "") {
    return `Data returned from \`load\` while rendering ${event.route.id} is not a plain object`;
  }
  return error210.message;
}
function stringify_uses(node) {
  const uses = [];
  if (node.uses && node.uses.dependencies.size > 0) {
    uses.push(`"dependencies":${JSON.stringify(Array.from(node.uses.dependencies))}`);
  }
  if (node.uses && node.uses.params.size > 0) {
    uses.push(`"params":${JSON.stringify(Array.from(node.uses.params))}`);
  }
  if (node.uses?.parent)
    uses.push('"parent":1');
  if (node.uses?.route)
    uses.push('"route":1');
  if (node.uses?.url)
    uses.push('"url":1');
  return `"uses":{${uses.join(",")}}`;
}
function warn_with_callsite(message, offset = 0) {
  {
    const stack = fix_stack_trace(new Error()).split("\n");
    const line = stack.at(3 + offset);
    message += `
${line}`;
  }
  console.warn(message);
}
async function render_endpoint(event, mod, state) {
  const method = (
    /** @type {import('types').HttpMethod} */
    event.request.method
  );
  let handler = mod[method] || mod.fallback;
  if (method === "HEAD" && mod.GET && !mod.HEAD) {
    handler = mod.GET;
  }
  if (!handler) {
    return method_not_allowed(mod, method);
  }
  const prerender = mod.prerender ?? state.prerender_default;
  if (prerender && (mod.POST || mod.PATCH || mod.PUT || mod.DELETE)) {
    throw new Error("Cannot prerender endpoints that have mutative methods");
  }
  if (state.prerendering && !prerender) {
    if (state.depth > 0) {
      throw new Error(`${event.route.id} is not prerenderable`);
    } else {
      return new Response(void 0, { status: 204 });
    }
  }
  try {
    let response = await handler(
      /** @type {import('@sveltejs/kit').RequestEvent<Record<string, any>>} */
      event
    );
    if (!(response instanceof Response)) {
      throw new Error(
        `Invalid response from route ${event.url.pathname}: handler should return a Response object`
      );
    }
    if (state.prerendering) {
      response = new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers: new Headers(response.headers)
      });
      response.headers.set("x-sveltekit-prerender", String(prerender));
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return new Response(void 0, {
        status: e3.status,
        headers: { location: e3.location }
      });
    }
    throw e3;
  }
}
function is_endpoint_request(event) {
  const { method, headers } = event.request;
  if (ENDPOINT_METHODS.includes(method) && !PAGE_METHODS.includes(method)) {
    return true;
  }
  if (method === "POST" && headers.get("x-sveltekit-action") === "true")
    return false;
  const accept = event.request.headers.get("accept") ?? "*/*";
  return negotiate(accept, ["*", "text/html"]) !== "text/html";
}
function compact(arr) {
  return arr.filter(
    /** @returns {val is NonNullable<T>} */
    (val) => val != null
  );
}
var SCHEME = /^[a-z][a-z\d+\-.]+:/i;
var absolute = /^([a-z]+:)?\/?\//;
function resolve(base2, path) {
  if (SCHEME.test(path))
    return path;
  if (path[0] === "#")
    return base2 + path;
  const base_match = absolute.exec(base2);
  const path_match = absolute.exec(path);
  if (!base_match) {
    throw new Error(`bad base path: "${base2}"`);
  }
  const baseparts = path_match ? [] : base2.slice(base_match[0].length).split("/");
  const pathparts = path_match ? path.slice(path_match[0].length).split("/") : path.split("/");
  baseparts.pop();
  for (let i = 0; i < pathparts.length; i += 1) {
    const part = pathparts[i];
    if (part === ".")
      continue;
    else if (part === "..")
      baseparts.pop();
    else
      baseparts.push(part);
  }
  const prefix = path_match && path_match[0] || base_match && base_match[0] || "";
  return `${prefix}${baseparts.join("/")}`;
}
function normalize_path(path, trailing_slash) {
  if (path === "/" || trailing_slash === "ignore")
    return path;
  if (trailing_slash === "never") {
    return path.endsWith("/") ? path.slice(0, -1) : path;
  } else if (trailing_slash === "always" && !path.endsWith("/")) {
    return path + "/";
  }
  return path;
}
function decode_pathname(pathname) {
  return pathname.split("%25").map(decodeURI).join("%25");
}
function decode_params(params) {
  for (const key2 in params) {
    params[key2] = decodeURIComponent(params[key2]);
  }
  return params;
}
var tracked_url_properties = (
  /** @type {const} */
  [
    "href",
    "pathname",
    "search",
    "searchParams",
    "toString",
    "toJSON"
  ]
);
function make_trackable(url2, callback) {
  const tracked = new URL(url2);
  for (const property of tracked_url_properties) {
    Object.defineProperty(tracked, property, {
      get() {
        callback();
        return url2[property];
      },
      enumerable: true,
      configurable: true
    });
  }
  {
    tracked[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(url2, opts);
    };
  }
  disable_hash(tracked);
  return tracked;
}
function disable_hash(url2) {
  allow_nodejs_console_log(url2);
  Object.defineProperty(url2, "hash", {
    get() {
      throw new Error(
        "Cannot access event.url.hash. Consider using `$page.url.hash` inside a component instead"
      );
    }
  });
}
function disable_search(url2) {
  allow_nodejs_console_log(url2);
  for (const property of ["search", "searchParams"]) {
    Object.defineProperty(url2, property, {
      get() {
        throw new Error(`Cannot access url.${property} on a page with prerendering enabled`);
      }
    });
  }
}
function allow_nodejs_console_log(url2) {
  {
    url2[Symbol.for("nodejs.util.inspect.custom")] = (depth, opts, inspect) => {
      return inspect(new URL(url2), opts);
    };
  }
}
var DATA_SUFFIX = "/__data.json";
function has_data_suffix(pathname) {
  return pathname.endsWith(DATA_SUFFIX);
}
function add_data_suffix(pathname) {
  return pathname.replace(/\/$/, "") + DATA_SUFFIX;
}
function strip_data_suffix(pathname) {
  return pathname.slice(0, -DATA_SUFFIX.length);
}
function is_action_json_request(event) {
  const accept = negotiate(event.request.headers.get("accept") ?? "*/*", [
    "application/json",
    "text/html"
  ]);
  return accept === "application/json" && event.request.method === "POST";
}
async function handle_action_json_request(event, options2, server2) {
  const actions19 = server2?.actions;
  if (!actions19) {
    const no_actions_error = error(405, "POST method not allowed. No actions exist for this page");
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, no_actions_error)
      },
      {
        status: no_actions_error.status,
        headers: {
          // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
          // "The server must generate an Allow header field in a 405 status code response"
          allow: "GET"
        }
      }
    );
  }
  check_named_default_separate(actions19);
  try {
    const data = await call_action(event, actions19);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return action_json({
        type: "failure",
        status: data.status,
        // @ts-expect-error we assign a string to what is supposed to be an object. That's ok
        // because we don't use the object outside, and this way we have better code navigation
        // through knowing where the related interface is used.
        data: stringify_action_response(
          data.data,
          /** @type {string} */
          event.route.id
        )
      });
    } else {
      return action_json({
        type: "success",
        status: data ? 200 : 204,
        // @ts-expect-error see comment above
        data: stringify_action_response(
          data,
          /** @type {string} */
          event.route.id
        )
      });
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return action_json_redirect(err);
    }
    return action_json(
      {
        type: "error",
        error: await handle_error_and_jsonify(event, options2, check_incorrect_fail_use(err))
      },
      {
        status: err instanceof HttpError ? err.status : 500
      }
    );
  }
}
function check_incorrect_fail_use(error210) {
  return error210 instanceof ActionFailure ? new Error('Cannot "throw fail()". Use "return fail()"') : error210;
}
function action_json_redirect(redirect2) {
  return action_json({
    type: "redirect",
    status: redirect2.status,
    location: redirect2.location
  });
}
function action_json(data, init2) {
  return json(data, init2);
}
function is_action_request(event) {
  return event.request.method === "POST";
}
async function handle_action_request(event, server2) {
  const actions19 = server2?.actions;
  if (!actions19) {
    event.setHeaders({
      // https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/405
      // "The server must generate an Allow header field in a 405 status code response"
      allow: "GET"
    });
    return {
      type: "error",
      error: error(405, "POST method not allowed. No actions exist for this page")
    };
  }
  check_named_default_separate(actions19);
  try {
    const data = await call_action(event, actions19);
    if (false)
      ;
    if (data instanceof ActionFailure) {
      return {
        type: "failure",
        status: data.status,
        data: data.data
      };
    } else {
      return {
        type: "success",
        status: 200,
        // @ts-expect-error this will be removed upon serialization, so `undefined` is the same as omission
        data
      };
    }
  } catch (e3) {
    const err = normalize_error(e3);
    if (err instanceof Redirect) {
      return {
        type: "redirect",
        status: err.status,
        location: err.location
      };
    }
    return {
      type: "error",
      error: check_incorrect_fail_use(err)
    };
  }
}
function check_named_default_separate(actions19) {
  if (actions19.default && Object.keys(actions19).length > 1) {
    throw new Error(
      "When using named actions, the default action cannot be used. See the docs for more info: https://kit.svelte.dev/docs/form-actions#named-actions"
    );
  }
}
async function call_action(event, actions19) {
  const url2 = new URL(event.request.url);
  let name = "default";
  for (const param of url2.searchParams) {
    if (param[0].startsWith("/")) {
      name = param[0].slice(1);
      if (name === "default") {
        throw new Error('Cannot use reserved action name "default"');
      }
      break;
    }
  }
  const action = actions19[name];
  if (!action) {
    throw new Error(`No action with name '${name}' found`);
  }
  if (!is_form_content_type(event.request)) {
    throw new Error(
      `Actions expect form-encoded data (received ${event.request.headers.get("content-type")})`
    );
  }
  return action(event);
}
function uneval_action_response(data, route_id) {
  return try_deserialize(data, uneval, route_id);
}
function stringify_action_response(data, route_id) {
  return try_deserialize(data, stringify, route_id);
}
function try_deserialize(data, fn, route_id) {
  try {
    return fn(data);
  } catch (e3) {
    const error210 = (
      /** @type {any} */
      e3
    );
    if ("path" in error210) {
      let message = `Data returned from action inside ${route_id} is not serializable: ${error210.message}`;
      if (error210.path !== "")
        message += ` (data.${error210.path})`;
      throw new Error(message);
    }
    throw error210;
  }
}
var warned = null;
async function unwrap_promises(object2, id) {
  {
    const promises = [];
    for (const key2 in object2) {
      if (typeof object2[key2]?.then === "function") {
        promises.push(key2);
      }
    }
    if (promises.length > 0) {
      if (!warned)
        warned = /* @__PURE__ */ new Set();
      const last = promises.pop();
      const properties = promises.length > 0 ? `${promises.map((p) => `"${p}"`).join(", ")} and "${last}" properties` : `"${last}" property`;
      const location = id ? `the \`load\` function in ${id}` : "a `load` function";
      const description = promises.length > 0 ? "are promises" : "is a promise";
      const message = `The top-level ${properties} returned from ${location} ${description}.`;
      if (!warned.has(message)) {
        console.warn(
          `
${message}

In SvelteKit 2.0, these will no longer be awaited automatically. To get rid of this warning, await all promises included as top-level properties in \`load\` return values.
`
        );
        warned.add(message);
      }
    }
  }
  for (const key2 in object2) {
    if (typeof object2[key2]?.then === "function") {
      return Object.fromEntries(
        await Promise.all(Object.entries(object2).map(async ([key3, value]) => [key3, await value]))
      );
    }
  }
  return object2;
}
function validate_depends(route_id, dep) {
  const match = /^(moz-icon|view-source|jar):/.exec(dep);
  if (match) {
    console.warn(
      `${route_id}: Calling \`depends('${dep}')\` will throw an error in Firefox because \`${match[1]}\` is a special URI scheme`
    );
  }
}
var INVALIDATED_PARAM = "x-sveltekit-invalidated";
var TRAILING_SLASH_PARAM = "x-sveltekit-trailing-slash";
async function load_server_data({
  event,
  state,
  node,
  parent,
  // TODO 2.0: Remove this
  track_server_fetches
}) {
  if (!node?.server)
    return null;
  let done = false;
  const uses = {
    dependencies: /* @__PURE__ */ new Set(),
    params: /* @__PURE__ */ new Set(),
    parent: false,
    route: false,
    url: false
  };
  const url2 = make_trackable(event.url, () => {
    if (done && !uses.url) {
      console.warn(
        `${node.server_id}: Accessing URL properties in a promise handler after \`load(...)\` has returned will not cause the function to re-run when the URL changes`
      );
    }
    uses.url = true;
  });
  if (state.prerendering) {
    disable_search(url2);
  }
  const result = await node.server.load?.call(null, {
    ...event,
    fetch: (info, init2) => {
      const url22 = new URL(info instanceof Request ? info.url : info, event.url);
      if (done && !uses.dependencies.has(url22.href)) {
        console.warn(
          `${node.server_id}: Calling \`event.fetch(...)\` in a promise handler after \`load(...)\` has returned will not cause the function to re-run when the dependency is invalidated`
        );
      }
      if (track_server_fetches) {
        uses.dependencies.add(url22.href);
      }
      return event.fetch(info, init2);
    },
    /** @param {string[]} deps */
    depends: (...deps) => {
      for (const dep of deps) {
        const { href } = new URL(dep, event.url);
        {
          validate_depends(node.server_id, dep);
          if (done && !uses.dependencies.has(href)) {
            console.warn(
              `${node.server_id}: Calling \`depends(...)\` in a promise handler after \`load(...)\` has returned will not cause the function to re-run when the dependency is invalidated`
            );
          }
        }
        uses.dependencies.add(href);
      }
    },
    params: new Proxy(event.params, {
      get: (target, key2) => {
        if (done && typeof key2 === "string" && !uses.params.has(key2)) {
          console.warn(
            `${node.server_id}: Accessing \`params.${String(
              key2
            )}\` in a promise handler after \`load(...)\` has returned will not cause the function to re-run when the param changes`
          );
        }
        uses.params.add(key2);
        return target[
          /** @type {string} */
          key2
        ];
      }
    }),
    parent: async () => {
      if (done && !uses.parent) {
        console.warn(
          `${node.server_id}: Calling \`parent(...)\` in a promise handler after \`load(...)\` has returned will not cause the function to re-run when parent data changes`
        );
      }
      uses.parent = true;
      return parent();
    },
    route: new Proxy(event.route, {
      get: (target, key2) => {
        if (done && typeof key2 === "string" && !uses.route) {
          console.warn(
            `${node.server_id}: Accessing \`route.${String(
              key2
            )}\` in a promise handler after \`load(...)\` has returned will not cause the function to re-run when the route changes`
          );
        }
        uses.route = true;
        return target[
          /** @type {'id'} */
          key2
        ];
      }
    }),
    url: url2
  });
  const data = result ? await unwrap_promises(result, node.server_id) : null;
  done = true;
  return {
    type: "data",
    data,
    uses,
    slash: node.server.trailingSlash
  };
}
async function load_data({
  event,
  fetched,
  node,
  parent,
  server_data_promise,
  state,
  resolve_opts,
  csr
}) {
  const server_data_node = await server_data_promise;
  if (!node?.universal?.load) {
    return server_data_node?.data ?? null;
  }
  const result = await node.universal.load.call(null, {
    url: event.url,
    params: event.params,
    data: server_data_node?.data ?? null,
    route: event.route,
    fetch: create_universal_fetch(event, state, fetched, csr, resolve_opts),
    setHeaders: event.setHeaders,
    depends: () => {
    },
    parent
  });
  const data = result ? await unwrap_promises(result, node.universal_id) : null;
  return data;
}
function b64_encode(buffer) {
  if (globalThis.Buffer) {
    return Buffer.from(buffer).toString("base64");
  }
  const little_endian = new Uint8Array(new Uint16Array([1]).buffer)[0] > 0;
  return btoa(
    new TextDecoder(little_endian ? "utf-16le" : "utf-16be").decode(
      new Uint16Array(new Uint8Array(buffer))
    )
  );
}
function create_universal_fetch(event, state, fetched, csr, resolve_opts) {
  const universal_fetch = async (input, init2) => {
    const cloned_body = input instanceof Request && input.body ? input.clone().body : null;
    const cloned_headers = input instanceof Request && [...input.headers].length ? new Headers(input.headers) : init2?.headers;
    let response = await event.fetch(input, init2);
    const url2 = new URL(input instanceof Request ? input.url : input, event.url);
    const same_origin = url2.origin === event.url.origin;
    let dependency;
    if (same_origin) {
      if (state.prerendering) {
        dependency = { response, body: null };
        state.prerendering.dependencies.set(url2.pathname, dependency);
      }
    } else {
      const mode = input instanceof Request ? input.mode : init2?.mode ?? "cors";
      if (mode === "no-cors") {
        response = new Response("", {
          status: response.status,
          statusText: response.statusText,
          headers: response.headers
        });
      } else {
        const acao = response.headers.get("access-control-allow-origin");
        if (!acao || acao !== event.url.origin && acao !== "*") {
          throw new Error(
            `CORS error: ${acao ? "Incorrect" : "No"} 'Access-Control-Allow-Origin' header is present on the requested resource`
          );
        }
      }
    }
    const proxy = new Proxy(response, {
      get(response2, key2, _receiver) {
        async function push_fetched(body, is_b64) {
          const status_number = Number(response2.status);
          if (isNaN(status_number)) {
            throw new Error(
              `response.status is not a number. value: "${response2.status}" type: ${typeof response2.status}`
            );
          }
          fetched.push({
            url: same_origin ? url2.href.slice(event.url.origin.length) : url2.href,
            method: event.request.method,
            request_body: (
              /** @type {string | ArrayBufferView | undefined} */
              input instanceof Request && cloned_body ? await stream_to_string(cloned_body) : init2?.body
            ),
            request_headers: cloned_headers,
            response_body: body,
            response: response2,
            is_b64
          });
        }
        if (key2 === "arrayBuffer") {
          return async () => {
            const buffer = await response2.arrayBuffer();
            if (dependency) {
              dependency.body = new Uint8Array(buffer);
            }
            if (buffer instanceof ArrayBuffer) {
              await push_fetched(b64_encode(buffer), true);
            }
            return buffer;
          };
        }
        async function text2() {
          const body = await response2.text();
          if (!body || typeof body === "string") {
            await push_fetched(body, false);
          }
          if (dependency) {
            dependency.body = body;
          }
          return body;
        }
        if (key2 === "text") {
          return text2;
        }
        if (key2 === "json") {
          return async () => {
            return JSON.parse(await text2());
          };
        }
        return Reflect.get(response2, key2, response2);
      }
    });
    if (csr) {
      const get = response.headers.get;
      response.headers.get = (key2) => {
        const lower = key2.toLowerCase();
        const value = get.call(response.headers, lower);
        if (value && !lower.startsWith("x-sveltekit-")) {
          const included = resolve_opts.filterSerializedResponseHeaders(lower, value);
          if (!included) {
            throw new Error(
              `Failed to get response header "${lower}" \u2014 it must be included by the \`filterSerializedResponseHeaders\` option: https://kit.svelte.dev/docs/hooks#server-hooks-handle (at ${event.route.id})`
            );
          }
        }
        return value;
      };
    }
    return proxy;
  };
  return (input, init2) => {
    const response = universal_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
async function stream_to_string(stream) {
  let result = "";
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  while (true) {
    const { done, value } = await reader.read();
    if (done) {
      break;
    }
    result += decoder.decode(value);
  }
  return result;
}
function hash2(...values) {
  let hash22 = 5381;
  for (const value of values) {
    if (typeof value === "string") {
      let i = value.length;
      while (i)
        hash22 = hash22 * 33 ^ value.charCodeAt(--i);
    } else if (ArrayBuffer.isView(value)) {
      const buffer = new Uint8Array(value.buffer, value.byteOffset, value.byteLength);
      let i = buffer.length;
      while (i)
        hash22 = hash22 * 33 ^ buffer[--i];
    } else {
      throw new TypeError("value must be a string or TypedArray");
    }
  }
  return (hash22 >>> 0).toString(36);
}
var escape_html_attr_dict = {
  "&": "&amp;",
  '"': "&quot;"
};
var escape_html_attr_regex = new RegExp(
  // special characters
  `[${Object.keys(escape_html_attr_dict).join("")}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`,
  "g"
);
function escape_html_attr(str) {
  const escaped_str = str.replace(escape_html_attr_regex, (match) => {
    if (match.length === 2) {
      return match;
    }
    return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
  });
  return `"${escaped_str}"`;
}
var replacements = {
  "<": "\\u003C",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var pattern = new RegExp(`[${Object.keys(replacements).join("")}]`, "g");
function serialize_data(fetched, filter, prerendering = false) {
  const headers = {};
  let cache_control = null;
  let age = null;
  let varyAny = false;
  for (const [key2, value] of fetched.response.headers) {
    if (filter(key2, value)) {
      headers[key2] = value;
    }
    if (key2 === "cache-control")
      cache_control = value;
    else if (key2 === "age")
      age = value;
    else if (key2 === "vary" && value.trim() === "*")
      varyAny = true;
  }
  const payload = {
    status: fetched.response.status,
    statusText: fetched.response.statusText,
    headers,
    body: fetched.response_body
  };
  const safe_payload = JSON.stringify(payload).replace(pattern, (match) => replacements[match]);
  const attrs = [
    'type="application/json"',
    "data-sveltekit-fetched",
    `data-url=${escape_html_attr(fetched.url)}`
  ];
  if (fetched.is_b64) {
    attrs.push("data-b64");
  }
  if (fetched.request_headers || fetched.request_body) {
    const values = [];
    if (fetched.request_headers) {
      values.push([...new Headers(fetched.request_headers)].join(","));
    }
    if (fetched.request_body) {
      values.push(fetched.request_body);
    }
    attrs.push(`data-hash="${hash2(...values)}"`);
  }
  if (!prerendering && fetched.method === "GET" && cache_control && !varyAny) {
    const match = /s-maxage=(\d+)/g.exec(cache_control) ?? /max-age=(\d+)/g.exec(cache_control);
    if (match) {
      const ttl = +match[1] - +(age ?? "0");
      attrs.push(`data-ttl="${ttl}"`);
    }
  }
  return `<script ${attrs.join(" ")}>${safe_payload}<\/script>`;
}
var s = JSON.stringify;
var encoder$2 = new TextEncoder();
function sha256(data) {
  if (!key[0])
    precompute();
  const out = init.slice(0);
  const array22 = encode(data);
  for (let i = 0; i < array22.length; i += 16) {
    const w = array22.subarray(i, i + 16);
    let tmp;
    let a;
    let b;
    let out0 = out[0];
    let out1 = out[1];
    let out2 = out[2];
    let out3 = out[3];
    let out4 = out[4];
    let out5 = out[5];
    let out6 = out[6];
    let out7 = out[7];
    for (let i2 = 0; i2 < 64; i2++) {
      if (i2 < 16) {
        tmp = w[i2];
      } else {
        a = w[i2 + 1 & 15];
        b = w[i2 + 14 & 15];
        tmp = w[i2 & 15] = (a >>> 7 ^ a >>> 18 ^ a >>> 3 ^ a << 25 ^ a << 14) + (b >>> 17 ^ b >>> 19 ^ b >>> 10 ^ b << 15 ^ b << 13) + w[i2 & 15] + w[i2 + 9 & 15] | 0;
      }
      tmp = tmp + out7 + (out4 >>> 6 ^ out4 >>> 11 ^ out4 >>> 25 ^ out4 << 26 ^ out4 << 21 ^ out4 << 7) + (out6 ^ out4 & (out5 ^ out6)) + key[i2];
      out7 = out6;
      out6 = out5;
      out5 = out4;
      out4 = out3 + tmp | 0;
      out3 = out2;
      out2 = out1;
      out1 = out0;
      out0 = tmp + (out1 & out2 ^ out3 & (out1 ^ out2)) + (out1 >>> 2 ^ out1 >>> 13 ^ out1 >>> 22 ^ out1 << 30 ^ out1 << 19 ^ out1 << 10) | 0;
    }
    out[0] = out[0] + out0 | 0;
    out[1] = out[1] + out1 | 0;
    out[2] = out[2] + out2 | 0;
    out[3] = out[3] + out3 | 0;
    out[4] = out[4] + out4 | 0;
    out[5] = out[5] + out5 | 0;
    out[6] = out[6] + out6 | 0;
    out[7] = out[7] + out7 | 0;
  }
  const bytes = new Uint8Array(out.buffer);
  reverse_endianness(bytes);
  return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
  function frac(x) {
    return (x - Math.floor(x)) * 4294967296;
  }
  let prime = 2;
  for (let i = 0; i < 64; prime++) {
    let is_prime = true;
    for (let factor = 2; factor * factor <= prime; factor++) {
      if (prime % factor === 0) {
        is_prime = false;
        break;
      }
    }
    if (is_prime) {
      if (i < 8) {
        init[i] = frac(prime ** (1 / 2));
      }
      key[i] = frac(prime ** (1 / 3));
      i++;
    }
  }
}
function reverse_endianness(bytes) {
  for (let i = 0; i < bytes.length; i += 4) {
    const a = bytes[i + 0];
    const b = bytes[i + 1];
    const c2 = bytes[i + 2];
    const d = bytes[i + 3];
    bytes[i + 0] = d;
    bytes[i + 1] = c2;
    bytes[i + 2] = b;
    bytes[i + 3] = a;
  }
}
function encode(str) {
  const encoded = encoder$2.encode(str);
  const length = encoded.length * 8;
  const size = 512 * Math.ceil((length + 65) / 512);
  const bytes = new Uint8Array(size / 8);
  bytes.set(encoded);
  bytes[encoded.length] = 128;
  reverse_endianness(bytes);
  const words = new Uint32Array(bytes.buffer);
  words[words.length - 2] = Math.floor(length / 4294967296);
  words[words.length - 1] = length;
  return words;
}
var chars2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
function base64(bytes) {
  const l = bytes.length;
  let result = "";
  let i;
  for (i = 2; i < l; i += 3) {
    result += chars2[bytes[i - 2] >> 2];
    result += chars2[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += chars2[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
    result += chars2[bytes[i] & 63];
  }
  if (i === l + 1) {
    result += chars2[bytes[i - 2] >> 2];
    result += chars2[(bytes[i - 2] & 3) << 4];
    result += "==";
  }
  if (i === l) {
    result += chars2[bytes[i - 2] >> 2];
    result += chars2[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
    result += chars2[(bytes[i - 1] & 15) << 2];
    result += "=";
  }
  return result;
}
var array = new Uint8Array(16);
function generate_nonce() {
  crypto.getRandomValues(array);
  return base64(array);
}
var quoted = /* @__PURE__ */ new Set([
  "self",
  "unsafe-eval",
  "unsafe-hashes",
  "unsafe-inline",
  "none",
  "strict-dynamic",
  "report-sample",
  "wasm-unsafe-eval",
  "script"
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var BaseProvider = class {
  /** @type {boolean} */
  #use_hashes;
  /** @type {boolean} */
  #script_needs_csp;
  /** @type {boolean} */
  #style_needs_csp;
  /** @type {import('types').CspDirectives} */
  #directives;
  /** @type {import('types').Csp.Source[]} */
  #script_src;
  /** @type {import('types').Csp.Source[]} */
  #style_src;
  /** @type {string} */
  #nonce;
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    this.#use_hashes = use_hashes;
    this.#directives = directives;
    const d = this.#directives;
    this.#script_src = [];
    this.#style_src = [];
    const effective_script_src = d["script-src"] || d["default-src"];
    const effective_style_src = d["style-src"] || d["default-src"];
    this.#script_needs_csp = !!effective_script_src && effective_script_src.filter((value) => value !== "unsafe-inline").length > 0;
    this.#style_needs_csp = !!effective_style_src && effective_style_src.filter((value) => value !== "unsafe-inline").length > 0;
    this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
    this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
    this.#nonce = nonce;
  }
  /** @param {string} content */
  add_script(content) {
    if (this.#script_needs_csp) {
      if (this.#use_hashes) {
        this.#script_src.push(`sha256-${sha256(content)}`);
      } else if (this.#script_src.length === 0) {
        this.#script_src.push(`nonce-${this.#nonce}`);
      }
    }
  }
  /** @param {string} content */
  add_style(content) {
    if (this.#style_needs_csp) {
      if (this.#use_hashes) {
        this.#style_src.push(`sha256-${sha256(content)}`);
      } else if (this.#style_src.length === 0) {
        this.#style_src.push(`nonce-${this.#nonce}`);
      }
    }
  }
  /**
   * @param {boolean} [is_meta]
   */
  get_header(is_meta = false) {
    const header = [];
    const directives = { ...this.#directives };
    if (this.#style_src.length > 0) {
      directives["style-src"] = [
        ...directives["style-src"] || directives["default-src"] || [],
        ...this.#style_src
      ];
    }
    if (this.#script_src.length > 0) {
      directives["script-src"] = [
        ...directives["script-src"] || directives["default-src"] || [],
        ...this.#script_src
      ];
    }
    for (const key2 in directives) {
      if (is_meta && (key2 === "frame-ancestors" || key2 === "report-uri" || key2 === "sandbox")) {
        continue;
      }
      const value = (
        /** @type {string[] | true} */
        directives[key2]
      );
      if (!value)
        continue;
      const directive = [key2];
      if (Array.isArray(value)) {
        value.forEach((value2) => {
          if (quoted.has(value2) || crypto_pattern.test(value2)) {
            directive.push(`'${value2}'`);
          } else {
            directive.push(value2);
          }
        });
      }
      header.push(directive.join(" "));
    }
    return header.join("; ");
  }
};
var CspProvider = class extends BaseProvider {
  get_meta() {
    const content = this.get_header(true);
    if (!content) {
      return;
    }
    return `<meta http-equiv="content-security-policy" content=${escape_html_attr(content)}>`;
  }
};
var CspReportOnlyProvider = class extends BaseProvider {
  /**
   * @param {boolean} use_hashes
   * @param {import('types').CspDirectives} directives
   * @param {string} nonce
   */
  constructor(use_hashes, directives, nonce) {
    super(use_hashes, directives, nonce);
    if (Object.values(directives).filter((v) => !!v).length > 0) {
      const has_report_to = directives["report-to"]?.length ?? 0 > 0;
      const has_report_uri = directives["report-uri"]?.length ?? 0 > 0;
      if (!has_report_to && !has_report_uri) {
        throw Error(
          "`content-security-policy-report-only` must be specified with either the `report-to` or `report-uri` directives, or both"
        );
      }
    }
  }
};
var Csp = class {
  /** @readonly */
  nonce = generate_nonce();
  /** @type {CspProvider} */
  csp_provider;
  /** @type {CspReportOnlyProvider} */
  report_only_provider;
  /**
   * @param {import('./types.js').CspConfig} config
   * @param {import('./types.js').CspOpts} opts
   */
  constructor({ mode, directives, reportOnly }, { prerender }) {
    const use_hashes = mode === "hash" || mode === "auto" && prerender;
    this.csp_provider = new CspProvider(use_hashes, directives, this.nonce);
    this.report_only_provider = new CspReportOnlyProvider(use_hashes, reportOnly, this.nonce);
  }
  get script_needs_nonce() {
    return this.csp_provider.script_needs_nonce || this.report_only_provider.script_needs_nonce;
  }
  get style_needs_nonce() {
    return this.csp_provider.style_needs_nonce || this.report_only_provider.style_needs_nonce;
  }
  /** @param {string} content */
  add_script(content) {
    this.csp_provider.add_script(content);
    this.report_only_provider.add_script(content);
  }
  /** @param {string} content */
  add_style(content) {
    this.csp_provider.add_style(content);
    this.report_only_provider.add_style(content);
  }
};
function defer() {
  let fulfil;
  let reject;
  const promise2 = new Promise((f, r3) => {
    fulfil = f;
    reject = r3;
  });
  return { promise: promise2, fulfil, reject };
}
function create_async_iterator() {
  const deferred = [defer()];
  return {
    iterator: {
      [Symbol.asyncIterator]() {
        return {
          next: async () => {
            const next = await deferred[0].promise;
            if (!next.done)
              deferred.shift();
            return next;
          }
        };
      }
    },
    push: (value) => {
      deferred[deferred.length - 1].fulfil({
        value,
        done: false
      });
      deferred.push(defer());
    },
    done: () => {
      deferred[deferred.length - 1].fulfil({ done: true });
    }
  };
}
var updated = {
  ...readable(false),
  check: () => false
};
var encoder$1 = new TextEncoder();
async function render_response({
  branch,
  fetched,
  options: options2,
  manifest: manifest2,
  state,
  page_config,
  status,
  error: error210 = null,
  event,
  resolve_opts,
  action_result
}) {
  if (state.prerendering) {
    if (options2.csp.mode === "nonce") {
      throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
    }
    if (options2.app_template_contains_nonce) {
      throw new Error("Cannot use prerendering if page template contains %sveltekit.nonce%");
    }
  }
  const { client } = manifest2._;
  const modulepreloads = new Set(client.imports);
  const stylesheets24 = new Set(client.stylesheets);
  const fonts24 = new Set(client.fonts);
  const link_header_preloads = /* @__PURE__ */ new Set();
  const inline_styles = /* @__PURE__ */ new Map();
  let rendered;
  const form_value = action_result?.type === "success" || action_result?.type === "failure" ? action_result.data ?? null : null;
  let base$1 = base;
  let assets$1 = assets;
  let base_expression = s(base);
  if (!state.prerendering?.fallback) {
    const segments = event.url.pathname.slice(base.length).split("/").slice(2);
    base$1 = segments.map(() => "..").join("/") || ".";
    base_expression = `new URL(${s(base$1)}, location).pathname.slice(0, -1)`;
    if (!assets || assets[0] === "/" && assets !== SVELTE_KIT_ASSETS) {
      assets$1 = base$1;
    }
  }
  if (page_config.ssr) {
    const props = {
      stores: {
        page: writable(null),
        navigating: writable(null),
        updated
      },
      constructors: await Promise.all(branch.map(({ node }) => node.component())),
      form: form_value
    };
    let data2 = {};
    for (let i = 0; i < branch.length; i += 1) {
      data2 = { ...data2, ...branch[i].data };
      props[`data_${i}`] = data2;
    }
    props.page = {
      error: error210,
      params: (
        /** @type {Record<string, any>} */
        event.params
      ),
      route: event.route,
      status,
      url: event.url,
      data: data2,
      form: form_value
    };
    {
      try {
        rendered = options2.root.render(props);
      } finally {
        reset();
      }
    }
    for (const { node } of branch) {
      for (const url2 of node.imports)
        modulepreloads.add(url2);
      for (const url2 of node.stylesheets)
        stylesheets24.add(url2);
      for (const url2 of node.fonts)
        fonts24.add(url2);
      if (node.inline_styles) {
        Object.entries(await node.inline_styles()).forEach(([k, v]) => inline_styles.set(k, v));
      }
    }
  } else {
    rendered = { head: "", html: "", css: { code: "", map: null } };
  }
  let head = "";
  let body = rendered.html;
  const csp = new Csp(options2.csp, {
    prerender: !!state.prerendering
  });
  const prefixed = (path) => {
    if (path.startsWith("/")) {
      return base + path;
    }
    return `${assets$1}/${path}`;
  };
  if (inline_styles.size > 0) {
    const content = Array.from(inline_styles.values()).join("\n");
    const attributes = [];
    if (csp.style_needs_nonce)
      attributes.push(` nonce="${csp.nonce}"`);
    csp.add_style(content);
    head += `
	<style${attributes.join("")}>${content}</style>`;
  }
  for (const dep of stylesheets24) {
    const path = prefixed(dep);
    const attributes = ['rel="stylesheet"'];
    if (inline_styles.has(dep)) {
      attributes.push("disabled", 'media="(max-width: 0)"');
    } else {
      if (resolve_opts.preload({ type: "css", path })) {
        const preload_atts = ['rel="preload"', 'as="style"'];
        link_header_preloads.add(`<${encodeURI(path)}>; ${preload_atts.join(";")}; nopush`);
      }
    }
    head += `
		<link href="${path}" ${attributes.join(" ")}>`;
  }
  for (const dep of fonts24) {
    const path = prefixed(dep);
    if (resolve_opts.preload({ type: "font", path })) {
      const ext = dep.slice(dep.lastIndexOf(".") + 1);
      const attributes = [
        'rel="preload"',
        'as="font"',
        `type="font/${ext}"`,
        `href="${path}"`,
        "crossorigin"
      ];
      head += `
		<link ${attributes.join(" ")}>`;
    }
  }
  const global2 = `__sveltekit_${options2.version_hash}`;
  const { data, chunks } = get_data(
    event,
    options2,
    branch.map((b) => b.server_data),
    global2
  );
  if (page_config.ssr && page_config.csr) {
    body += `
			${fetched.map(
      (item) => serialize_data(item, resolve_opts.filterSerializedResponseHeaders, !!state.prerendering)
    ).join("\n			")}`;
  }
  if (page_config.csr) {
    const included_modulepreloads = Array.from(modulepreloads, (dep) => prefixed(dep)).filter(
      (path) => resolve_opts.preload({ type: "js", path })
    );
    for (const path of included_modulepreloads) {
      link_header_preloads.add(`<${encodeURI(path)}>; rel="modulepreload"; nopush`);
      if (options2.preload_strategy !== "modulepreload") {
        head += `
		<link rel="preload" as="script" crossorigin="anonymous" href="${path}">`;
      } else if (state.prerendering) {
        head += `
		<link rel="modulepreload" href="${path}">`;
      }
    }
    const blocks = [];
    const properties = [
      assets && `assets: ${s(assets)}`,
      `base: ${base_expression}`,
      `env: ${s(public_env)}`
    ].filter(Boolean);
    if (chunks) {
      blocks.push("const deferred = new Map();");
      properties.push(`defer: (id) => new Promise((fulfil, reject) => {
							deferred.set(id, { fulfil, reject });
						})`);
      properties.push(`resolve: ({ id, data, error }) => {
							const { fulfil, reject } = deferred.get(id);
							deferred.delete(id);

							if (error) reject(error);
							else fulfil(data);
						}`);
    }
    blocks.push(`${global2} = {
						${properties.join(",\n						")}
					};`);
    const args = ["app", "element"];
    blocks.push("const element = document.currentScript.parentElement;");
    if (page_config.ssr) {
      const serialized = { form: "null", error: "null" };
      blocks.push(`const data = ${data};`);
      if (form_value) {
        serialized.form = uneval_action_response(
          form_value,
          /** @type {string} */
          event.route.id
        );
      }
      if (error210) {
        serialized.error = uneval(error210);
      }
      const hydrate = [
        `node_ids: [${branch.map(({ node }) => node.index).join(", ")}]`,
        "data",
        `form: ${serialized.form}`,
        `error: ${serialized.error}`
      ];
      if (status !== 200) {
        hydrate.push(`status: ${status}`);
      }
      if (options2.embedded) {
        hydrate.push(`params: ${uneval(event.params)}`, `route: ${s(event.route)}`);
      }
      args.push(`{
							${hydrate.join(",\n							")}
						}`);
    }
    blocks.push(`Promise.all([
						import(${s(prefixed(client.start))}),
						import(${s(prefixed(client.app))})
					]).then(([kit, app]) => {
						kit.start(${args.join(", ")});
					});`);
    if (options2.service_worker) {
      const opts = "";
      blocks.push(`if ('serviceWorker' in navigator) {
						addEventListener('load', function () {
							navigator.serviceWorker.register('${prefixed("service-worker.js")}'${opts});
						});
					}`);
    }
    const init_app = `
				{
					${blocks.join("\n\n					")}
				}
			`;
    csp.add_script(init_app);
    body += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ""}>${init_app}<\/script>
		`;
  }
  const headers = new Headers({
    "x-sveltekit-page": "true",
    "content-type": "text/html"
  });
  if (state.prerendering) {
    const http_equiv = [];
    const csp_headers = csp.csp_provider.get_meta();
    if (csp_headers) {
      http_equiv.push(csp_headers);
    }
    if (state.prerendering.cache) {
      http_equiv.push(`<meta http-equiv="cache-control" content="${state.prerendering.cache}">`);
    }
    if (http_equiv.length > 0) {
      head = http_equiv.join("\n") + head;
    }
  } else {
    const csp_header = csp.csp_provider.get_header();
    if (csp_header) {
      headers.set("content-security-policy", csp_header);
    }
    const report_only_header = csp.report_only_provider.get_header();
    if (report_only_header) {
      headers.set("content-security-policy-report-only", report_only_header);
    }
    if (link_header_preloads.size) {
      headers.set("link", Array.from(link_header_preloads).join(", "));
    }
  }
  head += rendered.head;
  const html = options2.templates.app({
    head,
    body,
    assets: assets$1,
    nonce: (
      /** @type {string} */
      csp.nonce
    ),
    env: public_env
  });
  const transformed = await resolve_opts.transformPageChunk({
    html,
    done: true
  }) || "";
  if (!chunks) {
    headers.set("etag", `"${hash2(transformed)}"`);
  }
  {
    if (page_config.csr) {
      if (transformed.split("<!--").length < html.split("<!--").length) {
        console.warn(
          "\x1B[1m\x1B[31mRemoving comments in transformPageChunk can break Svelte's hydration\x1B[39m\x1B[22m"
        );
      }
    } else {
      if (chunks) {
        console.warn(
          "\x1B[1m\x1B[31mReturning promises from server `load` functions will only work if `csr === true`\x1B[39m\x1B[22m"
        );
      }
    }
  }
  return !chunks ? text(transformed, {
    status,
    headers
  }) : new Response(
    new ReadableStream({
      async start(controller) {
        controller.enqueue(encoder$1.encode(transformed + "\n"));
        for await (const chunk of chunks) {
          controller.enqueue(encoder$1.encode(chunk));
        }
        controller.close();
      },
      type: "bytes"
    }),
    {
      headers: {
        "content-type": "text/html"
      }
    }
  );
}
function get_data(event, options2, nodes, global2) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push, done } = create_async_iterator();
  function replacer(thing) {
    if (typeof thing?.then === "function") {
      const id = promise_id++;
      count += 1;
      thing.then(
        /** @param {any} data */
        (data) => ({ data })
      ).catch(
        /** @param {any} error */
        async (error210) => ({
          error: await handle_error_and_jsonify(event, options2, error210)
        })
      ).then(
        /**
         * @param {{data: any; error: any}} result
         */
        async ({ data, error: error210 }) => {
          count -= 1;
          let str;
          try {
            str = uneval({ id, data, error: error210 }, replacer);
          } catch (e3) {
            error210 = await handle_error_and_jsonify(
              event,
              options2,
              new Error(`Failed to serialize promise while rendering ${event.route.id}`)
            );
            data = void 0;
            str = uneval({ id, data, error: error210 }, replacer);
          }
          push(`<script>${global2}.resolve(${str})<\/script>
`);
          if (count === 0)
            done();
        }
      );
      return `${global2}.defer(${id})`;
    }
  }
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      return `{"type":"data","data":${uneval(node.data, replacer)},${stringify_uses(node)}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `[${strings.join(",")}]`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
function get_option(nodes, option) {
  return nodes.reduce(
    (value, node) => {
      return (
        /** @type {Value} TypeScript's too dumb to understand this */
        node?.universal?.[option] ?? node?.server?.[option] ?? value
      );
    },
    /** @type {Value | undefined} */
    void 0
  );
}
async function respond_with_error({
  event,
  options: options2,
  manifest: manifest2,
  state,
  status,
  error: error210,
  resolve_opts
}) {
  if (event.request.headers.get("x-sveltekit-error")) {
    return static_error_page(
      options2,
      status,
      /** @type {Error} */
      error210.message
    );
  }
  const fetched = [];
  try {
    const branch = [];
    const default_layout = await manifest2._.nodes[0]();
    const ssr = get_option([default_layout], "ssr") ?? true;
    const csr = get_option([default_layout], "csr") ?? true;
    if (ssr) {
      state.error = true;
      const server_data_promise = load_server_data({
        event,
        state,
        node: default_layout,
        parent: async () => ({}),
        track_server_fetches: options2.track_server_fetches
      });
      const server_data = await server_data_promise;
      const data = await load_data({
        event,
        fetched,
        node: default_layout,
        parent: async () => ({}),
        resolve_opts,
        server_data_promise,
        state,
        csr
      });
      branch.push(
        {
          node: default_layout,
          server_data,
          data
        },
        {
          node: await manifest2._.nodes[1](),
          // 1 is always the root error
          data: null,
          server_data: null
        }
      );
    }
    return await render_response({
      options: options2,
      manifest: manifest2,
      state,
      page_config: {
        ssr,
        csr: get_option([default_layout], "csr") ?? true
      },
      status,
      error: await handle_error_and_jsonify(event, options2, error210),
      branch,
      fetched,
      event,
      resolve_opts
    });
  } catch (e3) {
    if (e3 instanceof Redirect) {
      return redirect_response(e3.status, e3.location);
    }
    return static_error_page(
      options2,
      e3 instanceof HttpError ? e3.status : 500,
      (await handle_error_and_jsonify(event, options2, e3)).message
    );
  }
}
function once(fn) {
  let done = false;
  let result;
  return () => {
    if (done)
      return result;
    done = true;
    return result = fn();
  };
}
var encoder2 = new TextEncoder();
async function render_data(event, route, options2, manifest2, state, invalidated_data_nodes, trailing_slash) {
  if (!route.page) {
    return new Response(void 0, {
      status: 404
    });
  }
  try {
    const node_ids = [...route.page.layouts, route.page.leaf];
    const invalidated = invalidated_data_nodes ?? node_ids.map(() => true);
    let aborted2 = false;
    const url2 = new URL(event.url);
    url2.pathname = normalize_path(url2.pathname, trailing_slash);
    const new_event = { ...event, url: url2 };
    const functions = node_ids.map((n2, i) => {
      return once(async () => {
        try {
          if (aborted2) {
            return (
              /** @type {import('types').ServerDataSkippedNode} */
              {
                type: "skip"
              }
            );
          }
          const node = n2 == void 0 ? n2 : await manifest2._.nodes[n2]();
          return load_server_data({
            event: new_event,
            state,
            node,
            parent: async () => {
              const data2 = {};
              for (let j = 0; j < i; j += 1) {
                const parent = (
                  /** @type {import('types').ServerDataNode | null} */
                  await functions[j]()
                );
                if (parent) {
                  Object.assign(data2, parent.data);
                }
              }
              return data2;
            },
            track_server_fetches: options2.track_server_fetches
          });
        } catch (e3) {
          aborted2 = true;
          throw e3;
        }
      });
    });
    const promises = functions.map(async (fn, i) => {
      if (!invalidated[i]) {
        return (
          /** @type {import('types').ServerDataSkippedNode} */
          {
            type: "skip"
          }
        );
      }
      return fn();
    });
    let length = promises.length;
    const nodes = await Promise.all(
      promises.map(
        (p, i) => p.catch(async (error210) => {
          if (error210 instanceof Redirect) {
            throw error210;
          }
          length = Math.min(length, i + 1);
          return (
            /** @type {import('types').ServerErrorNode} */
            {
              type: "error",
              error: await handle_error_and_jsonify(event, options2, error210),
              status: error210 instanceof HttpError ? error210.status : void 0
            }
          );
        })
      )
    );
    const { data, chunks } = get_data_json(event, options2, nodes);
    if (!chunks) {
      return json_response(data);
    }
    return new Response(
      new ReadableStream({
        async start(controller) {
          controller.enqueue(encoder2.encode(data));
          for await (const chunk of chunks) {
            controller.enqueue(encoder2.encode(chunk));
          }
          controller.close();
        },
        type: "bytes"
      }),
      {
        headers: {
          // we use a proprietary content type to prevent buffering.
          // the `text` prefix makes it inspectable
          "content-type": "text/sveltekit-data",
          "cache-control": "private, no-store"
        }
      }
    );
  } catch (e3) {
    const error210 = normalize_error(e3);
    if (error210 instanceof Redirect) {
      return redirect_json_response(error210);
    } else {
      return json_response(await handle_error_and_jsonify(event, options2, error210), 500);
    }
  }
}
function json_response(json22, status = 200) {
  return text(typeof json22 === "string" ? json22 : JSON.stringify(json22), {
    status,
    headers: {
      "content-type": "application/json",
      "cache-control": "private, no-store"
    }
  });
}
function redirect_json_response(redirect2) {
  return json_response({
    type: "redirect",
    location: redirect2.location
  });
}
function get_data_json(event, options2, nodes) {
  let promise_id = 1;
  let count = 0;
  const { iterator, push, done } = create_async_iterator();
  const reducers = {
    /** @param {any} thing */
    Promise: (thing) => {
      if (typeof thing?.then === "function") {
        const id = promise_id++;
        count += 1;
        let key2 = "data";
        thing.catch(
          /** @param {any} e */
          async (e3) => {
            key2 = "error";
            return handle_error_and_jsonify(
              event,
              options2,
              /** @type {any} */
              e3
            );
          }
        ).then(
          /** @param {any} value */
          async (value) => {
            let str;
            try {
              str = stringify(value, reducers);
            } catch (e3) {
              const error210 = await handle_error_and_jsonify(
                event,
                options2,
                new Error(`Failed to serialize promise while rendering ${event.route.id}`)
              );
              key2 = "error";
              str = stringify(error210, reducers);
            }
            count -= 1;
            push(`{"type":"chunk","id":${id},"${key2}":${str}}
`);
            if (count === 0)
              done();
          }
        );
        return id;
      }
    }
  };
  try {
    const strings = nodes.map((node) => {
      if (!node)
        return "null";
      if (node.type === "error" || node.type === "skip") {
        return JSON.stringify(node);
      }
      return `{"type":"data","data":${stringify(node.data, reducers)},${stringify_uses(
        node
      )}${node.slash ? `,"slash":${JSON.stringify(node.slash)}` : ""}}`;
    });
    return {
      data: `{"type":"data","nodes":[${strings.join(",")}]}
`,
      chunks: count > 0 ? iterator : null
    };
  } catch (e3) {
    throw new Error(clarify_devalue_error(
      event,
      /** @type {any} */
      e3
    ));
  }
}
var MAX_DEPTH = 10;
async function render_page(event, page2, options2, manifest2, state, resolve_opts) {
  if (state.depth > MAX_DEPTH) {
    return text(`Not found: ${event.url.pathname}`, {
      status: 404
      // TODO in some cases this should be 500. not sure how to differentiate
    });
  }
  if (is_action_json_request(event)) {
    const node = await manifest2._.nodes[page2.leaf]();
    return handle_action_json_request(event, options2, node?.server);
  }
  try {
    const nodes = await Promise.all([
      // we use == here rather than === because [undefined] serializes as "[null]"
      ...page2.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
      manifest2._.nodes[page2.leaf]()
    ]);
    const leaf_node = (
      /** @type {import('types').SSRNode} */
      nodes.at(-1)
    );
    let status = 200;
    let action_result = void 0;
    if (is_action_request(event)) {
      action_result = await handle_action_request(event, leaf_node.server);
      if (action_result?.type === "redirect") {
        return redirect_response(action_result.status, action_result.location);
      }
      if (action_result?.type === "error") {
        const error210 = action_result.error;
        status = error210 instanceof HttpError ? error210.status : 500;
      }
      if (action_result?.type === "failure") {
        status = action_result.status;
      }
    }
    const should_prerender_data = nodes.some((node) => node?.server);
    const data_pathname = add_data_suffix(event.url.pathname);
    const should_prerender = get_option(nodes, "prerender") ?? false;
    if (should_prerender) {
      const mod = leaf_node.server;
      if (mod?.actions) {
        throw new Error("Cannot prerender pages with actions");
      }
    } else if (state.prerendering) {
      return new Response(void 0, {
        status: 204
      });
    }
    state.prerender_default = should_prerender;
    const fetched = [];
    if (get_option(nodes, "ssr") === false && !state.prerendering) {
      return await render_response({
        branch: [],
        fetched,
        page_config: {
          ssr: false,
          csr: get_option(nodes, "csr") ?? true
        },
        status,
        error: null,
        event,
        options: options2,
        manifest: manifest2,
        state,
        resolve_opts
      });
    }
    const branch = [];
    let load_error = null;
    const server_promises = nodes.map((node, i) => {
      if (load_error) {
        throw load_error;
      }
      return Promise.resolve().then(async () => {
        try {
          if (node === leaf_node && action_result?.type === "error") {
            throw action_result.error;
          }
          return await load_server_data({
            event,
            state,
            node,
            parent: async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                const parent = await server_promises[j];
                if (parent)
                  Object.assign(data, await parent.data);
              }
              return data;
            },
            track_server_fetches: options2.track_server_fetches
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    const csr = get_option(nodes, "csr") ?? true;
    const load_promises = nodes.map((node, i) => {
      if (load_error)
        throw load_error;
      return Promise.resolve().then(async () => {
        try {
          return await load_data({
            event,
            fetched,
            node,
            parent: async () => {
              const data = {};
              for (let j = 0; j < i; j += 1) {
                Object.assign(data, await load_promises[j]);
              }
              return data;
            },
            resolve_opts,
            server_data_promise: server_promises[i],
            state,
            csr
          });
        } catch (e3) {
          load_error = /** @type {Error} */
          e3;
          throw load_error;
        }
      });
    });
    for (const p of server_promises)
      p.catch(() => {
      });
    for (const p of load_promises)
      p.catch(() => {
      });
    for (let i = 0; i < nodes.length; i += 1) {
      const node = nodes[i];
      if (node) {
        try {
          const server_data = await server_promises[i];
          const data = await load_promises[i];
          branch.push({ node, server_data, data });
        } catch (e3) {
          const err = normalize_error(e3);
          if (err instanceof Redirect) {
            if (state.prerendering && should_prerender_data) {
              const body = JSON.stringify({
                type: "redirect",
                location: err.location
              });
              state.prerendering.dependencies.set(data_pathname, {
                response: text(body),
                body
              });
            }
            return redirect_response(err.status, err.location);
          }
          const status2 = err instanceof HttpError ? err.status : 500;
          const error210 = await handle_error_and_jsonify(event, options2, err);
          while (i--) {
            if (page2.errors[i]) {
              const index24 = (
                /** @type {number} */
                page2.errors[i]
              );
              const node2 = await manifest2._.nodes[index24]();
              let j = i;
              while (!branch[j])
                j -= 1;
              return await render_response({
                event,
                options: options2,
                manifest: manifest2,
                state,
                resolve_opts,
                page_config: { ssr: true, csr: true },
                status: status2,
                error: error210,
                branch: compact(branch.slice(0, j + 1)).concat({
                  node: node2,
                  data: null,
                  server_data: null
                }),
                fetched
              });
            }
          }
          return static_error_page(options2, status2, error210.message);
        }
      } else {
        branch.push(null);
      }
    }
    if (state.prerendering && should_prerender_data) {
      let { data, chunks } = get_data_json(
        event,
        options2,
        branch.map((node) => node?.server_data)
      );
      if (chunks) {
        for await (const chunk of chunks) {
          data += chunk;
        }
      }
      state.prerendering.dependencies.set(data_pathname, {
        response: text(data),
        body: data
      });
    }
    return await render_response({
      event,
      options: options2,
      manifest: manifest2,
      state,
      resolve_opts,
      page_config: {
        csr: get_option(nodes, "csr") ?? true,
        ssr: get_option(nodes, "ssr") ?? true
      },
      status,
      error: null,
      branch: compact(branch),
      action_result,
      fetched
    });
  } catch (e3) {
    return await respond_with_error({
      event,
      options: options2,
      manifest: manifest2,
      state,
      status: 500,
      error: e3,
      resolve_opts
    });
  }
}
function deprecate_missing_path(opts, method) {
  if (opts.path === void 0) {
    warn_with_callsite(
      `Calling \`cookies.${method}(...)\` without specifying a \`path\` is deprecated, and will be disallowed in SvelteKit 2.0. Relative paths can be used`,
      1
    );
  }
  if (opts.path === "") {
    warn_with_callsite(
      `Calling \`cookies.${method}(...)\` with \`path: ''\` will behave differently in SvelteKit 2.0. Instead of using the browser default behaviour, it will set the cookie path to the current pathname`,
      1
    );
  }
}
function get_cookies(request, url2, trailing_slash) {
  const header = request.headers.get("cookie") ?? "";
  const initial_cookies = (0, import_cookie.parse)(header, { decode: (value) => value });
  const normalized_url = normalize_path(url2.pathname, trailing_slash);
  const default_path = normalized_url.split("/").slice(0, -1).join("/") || "/";
  const new_cookies = {};
  const defaults = {
    httpOnly: true,
    sameSite: "lax",
    secure: url2.hostname === "localhost" && url2.protocol === "http:" ? false : true
  };
  const cookies = {
    // The JSDoc param annotations appearing below for get, set and delete
    // are necessary to expose the `cookie` library types to
    // typescript users. `@type {import('@sveltejs/kit').Cookies}` above is not
    // sufficient to do so.
    /**
     * @param {string} name
     * @param {import('cookie').CookieParseOptions} opts
     */
    get(name, opts) {
      const c2 = new_cookies[name];
      if (c2 && domain_matches(url2.hostname, c2.options.domain) && path_matches(url2.pathname, c2.options.path)) {
        return c2.value;
      }
      const decoder = opts?.decode || decodeURIComponent;
      const req_cookies = (0, import_cookie.parse)(header, { decode: decoder });
      const cookie = req_cookies[name];
      return cookie;
    },
    /**
     * @param {import('cookie').CookieParseOptions} opts
     */
    getAll(opts) {
      const decoder = opts?.decode || decodeURIComponent;
      const cookies2 = (0, import_cookie.parse)(header, { decode: decoder });
      for (const c2 of Object.values(new_cookies)) {
        if (domain_matches(url2.hostname, c2.options.domain) && path_matches(url2.pathname, c2.options.path)) {
          cookies2[c2.name] = c2.value;
        }
      }
      return Object.entries(cookies2).map(([name, value]) => ({ name, value }));
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('cookie').CookieSerializeOptions} opts
     */
    set(name, value, opts = {}) {
      deprecate_missing_path(opts, "set");
      set_internal(name, value, { ...defaults, ...opts });
    },
    /**
     * @param {string} name
     * @param {import('cookie').CookieSerializeOptions} opts
     */
    delete(name, opts = {}) {
      deprecate_missing_path(opts, "delete");
      cookies.set(name, "", {
        path: default_path,
        // TODO 2.0 remove this
        ...opts,
        maxAge: 0
      });
    },
    /**
     * @param {string} name
     * @param {string} value
     * @param {import('cookie').CookieSerializeOptions} opts
     */
    serialize(name, value, opts = {}) {
      deprecate_missing_path(opts, "serialize");
      return (0, import_cookie.serialize)(name, value, {
        ...defaults,
        ...opts
      });
    }
  };
  function get_cookie_header(destination, header2) {
    const combined_cookies = {
      // cookies sent by the user agent have lowest precedence
      ...initial_cookies
    };
    for (const key2 in new_cookies) {
      const cookie = new_cookies[key2];
      if (!domain_matches(destination.hostname, cookie.options.domain))
        continue;
      if (!path_matches(destination.pathname, cookie.options.path))
        continue;
      const encoder22 = cookie.options.encode || encodeURIComponent;
      combined_cookies[cookie.name] = encoder22(cookie.value);
    }
    if (header2) {
      const parsed = (0, import_cookie.parse)(header2, { decode: (value) => value });
      for (const name in parsed) {
        combined_cookies[name] = parsed[name];
      }
    }
    return Object.entries(combined_cookies).map(([name, value]) => `${name}=${value}`).join("; ");
  }
  function set_internal(name, value, opts) {
    let path = opts.path;
    if (!opts.domain || opts.domain === url2.hostname) {
      if (path) {
        if (path[0] === ".")
          path = resolve(url2.pathname, path);
      } else {
        path = default_path;
      }
    }
    new_cookies[name] = {
      name,
      value,
      options: {
        ...opts,
        path
      }
    };
  }
  return { cookies, new_cookies, get_cookie_header, set_internal };
}
function domain_matches(hostname3, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint[0] === "." ? constraint.slice(1) : constraint;
  if (hostname3 === normalized)
    return true;
  return hostname3.endsWith("." + normalized);
}
function path_matches(path, constraint) {
  if (!constraint)
    return true;
  const normalized = constraint.endsWith("/") ? constraint.slice(0, -1) : constraint;
  if (path === normalized)
    return true;
  return path.startsWith(normalized + "/");
}
function add_cookies_to_headers(headers, cookies) {
  for (const new_cookie of cookies) {
    const { name, value, options: options2 } = new_cookie;
    headers.append("set-cookie", (0, import_cookie.serialize)(name, value, options2));
  }
}
function create_fetch({ event, options: options2, manifest: manifest2, state, get_cookie_header, set_internal }) {
  const server_fetch = async (info, init2) => {
    const original_request = normalize_fetch_input(info, init2, event.url);
    let mode = (info instanceof Request ? info.mode : init2?.mode) ?? "cors";
    let credentials = (info instanceof Request ? info.credentials : init2?.credentials) ?? "same-origin";
    return options2.hooks.handleFetch({
      event,
      request: original_request,
      fetch: async (info2, init3) => {
        const request = normalize_fetch_input(info2, init3, event.url);
        const url2 = new URL(request.url);
        if (!request.headers.has("origin")) {
          request.headers.set("origin", event.url.origin);
        }
        if (info2 !== original_request) {
          mode = (info2 instanceof Request ? info2.mode : init3?.mode) ?? "cors";
          credentials = (info2 instanceof Request ? info2.credentials : init3?.credentials) ?? "same-origin";
        }
        if ((request.method === "GET" || request.method === "HEAD") && (mode === "no-cors" && url2.origin !== event.url.origin || url2.origin === event.url.origin)) {
          request.headers.delete("origin");
        }
        if (url2.origin !== event.url.origin) {
          if (`.${url2.hostname}`.endsWith(`.${event.url.hostname}`) && credentials !== "omit") {
            const cookie = get_cookie_header(url2, request.headers.get("cookie"));
            if (cookie)
              request.headers.set("cookie", cookie);
          }
          return fetch(request);
        }
        const prefix = assets || base;
        const decoded = decodeURIComponent(url2.pathname);
        const filename = (decoded.startsWith(prefix) ? decoded.slice(prefix.length) : decoded).slice(1);
        const filename_html = `${filename}/index.html`;
        const is_asset = manifest2.assets.has(filename);
        const is_asset_html = manifest2.assets.has(filename_html);
        if (is_asset || is_asset_html) {
          const file2 = is_asset ? filename : filename_html;
          if (state.read) {
            const type = is_asset ? manifest2.mimeTypes[filename.slice(filename.lastIndexOf("."))] : "text/html";
            return new Response(state.read(file2), {
              headers: type ? { "content-type": type } : {}
            });
          }
          return await fetch(request);
        }
        if (credentials !== "omit") {
          const cookie = get_cookie_header(url2, request.headers.get("cookie"));
          if (cookie) {
            request.headers.set("cookie", cookie);
          }
          const authorization = event.request.headers.get("authorization");
          if (authorization && !request.headers.has("authorization")) {
            request.headers.set("authorization", authorization);
          }
        }
        if (!request.headers.has("accept")) {
          request.headers.set("accept", "*/*");
        }
        if (!request.headers.has("accept-language")) {
          request.headers.set(
            "accept-language",
            /** @type {string} */
            event.request.headers.get("accept-language")
          );
        }
        const response = await respond(request, options2, manifest2, {
          ...state,
          depth: state.depth + 1
        });
        const set_cookie = response.headers.get("set-cookie");
        if (set_cookie) {
          for (const str of set_cookie_parser.splitCookiesString(set_cookie)) {
            const { name, value, ...options3 } = set_cookie_parser.parseString(str);
            set_internal(
              name,
              value,
              /** @type {import('cookie').CookieSerializeOptions} */
              options3
            );
          }
        }
        return response;
      }
    });
  };
  return (input, init2) => {
    const response = server_fetch(input, init2);
    response.catch(() => {
    });
    return response;
  };
}
function normalize_fetch_input(info, init2, url2) {
  if (info instanceof Request) {
    return info;
  }
  return new Request(typeof info === "string" ? new URL(info, url2) : info, init2);
}
function validator(expected) {
  function validate(module, file2) {
    if (!module)
      return;
    for (const key2 in module) {
      if (key2[0] === "_" || expected.has(key2))
        continue;
      const values = [...expected.values()];
      const hint = hint_for_supported_files(key2, file2?.slice(file2.lastIndexOf("."))) ?? `valid exports are ${values.join(", ")}, or anything with a '_' prefix`;
      throw new Error(`Invalid export '${key2}'${file2 ? ` in ${file2}` : ""} (${hint})`);
    }
  }
  return validate;
}
function hint_for_supported_files(key2, ext = ".js") {
  const supported_files = [];
  if (valid_layout_exports.has(key2)) {
    supported_files.push(`+layout${ext}`);
  }
  if (valid_page_exports.has(key2)) {
    supported_files.push(`+page${ext}`);
  }
  if (valid_layout_server_exports.has(key2)) {
    supported_files.push(`+layout.server${ext}`);
  }
  if (valid_page_server_exports.has(key2)) {
    supported_files.push(`+page.server${ext}`);
  }
  if (valid_server_exports.has(key2)) {
    supported_files.push(`+server${ext}`);
  }
  if (supported_files.length > 0) {
    return `'${key2}' is a valid export in ${supported_files.slice(0, -1).join(", ")}${supported_files.length > 1 ? " or " : ""}${supported_files.at(-1)}`;
  }
}
var valid_layout_exports = /* @__PURE__ */ new Set([
  "load",
  "prerender",
  "csr",
  "ssr",
  "trailingSlash",
  "config"
]);
var valid_page_exports = /* @__PURE__ */ new Set([...valid_layout_exports, "entries"]);
var valid_layout_server_exports = /* @__PURE__ */ new Set([...valid_layout_exports]);
var valid_page_server_exports = /* @__PURE__ */ new Set([...valid_layout_server_exports, "actions", "entries"]);
var valid_server_exports = /* @__PURE__ */ new Set([
  "GET",
  "POST",
  "PATCH",
  "PUT",
  "DELETE",
  "OPTIONS",
  "HEAD",
  "fallback",
  "prerender",
  "trailingSlash",
  "config",
  "entries"
]);
var validate_layout_exports = validator(valid_layout_exports);
var validate_page_exports = validator(valid_page_exports);
var validate_layout_server_exports = validator(valid_layout_server_exports);
var validate_page_server_exports = validator(valid_page_server_exports);
var validate_server_exports = validator(valid_server_exports);
var default_transform = ({ html }) => html;
var default_filter = () => false;
var default_preload = ({ type }) => type === "js" || type === "css";
var page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "POST"]);
var allowed_page_methods = /* @__PURE__ */ new Set(["GET", "HEAD", "OPTIONS"]);
async function respond(request, options2, manifest2, state) {
  const url2 = new URL(request.url);
  if (options2.csrf_check_origin) {
    const forbidden = is_form_content_type(request) && (request.method === "POST" || request.method === "PUT" || request.method === "PATCH" || request.method === "DELETE") && request.headers.get("origin") !== url2.origin;
    if (forbidden) {
      const csrf_error = error(403, `Cross-site ${request.method} form submissions are forbidden`);
      if (request.headers.get("accept") === "application/json") {
        return json(csrf_error.body, { status: csrf_error.status });
      }
      return text(csrf_error.body.message, { status: csrf_error.status });
    }
  }
  let decoded;
  try {
    decoded = decode_pathname(url2.pathname);
  } catch {
    return text("Malformed URI", { status: 400 });
  }
  let route = null;
  let params = {};
  if (base && !state.prerendering?.fallback) {
    if (!decoded.startsWith(base)) {
      return text("Not found", { status: 404 });
    }
    decoded = decoded.slice(base.length) || "/";
  }
  const is_data_request = has_data_suffix(decoded);
  let invalidated_data_nodes;
  if (is_data_request) {
    decoded = strip_data_suffix(decoded) || "/";
    url2.pathname = strip_data_suffix(url2.pathname) + (url2.searchParams.get(TRAILING_SLASH_PARAM) === "1" ? "/" : "") || "/";
    url2.searchParams.delete(TRAILING_SLASH_PARAM);
    invalidated_data_nodes = url2.searchParams.get(INVALIDATED_PARAM)?.split("").map((node) => node === "1");
    url2.searchParams.delete(INVALIDATED_PARAM);
  }
  if (!state.prerendering?.fallback) {
    const matchers = await manifest2._.matchers();
    for (const candidate of manifest2._.routes) {
      const match = candidate.pattern.exec(decoded);
      if (!match)
        continue;
      const matched = exec(match, candidate.params, matchers);
      if (matched) {
        route = candidate;
        params = decode_params(matched);
        break;
      }
    }
  }
  let trailing_slash = void 0;
  const headers = {};
  let cookies_to_add = {};
  const event = {
    // @ts-expect-error `cookies` and `fetch` need to be created after the `event` itself
    cookies: null,
    // @ts-expect-error
    fetch: null,
    getClientAddress: state.getClientAddress || (() => {
      throw new Error(
        `${"@sveltejs/adapter-cloudflare"} does not specify getClientAddress. Please raise an issue`
      );
    }),
    locals: {},
    params,
    platform: state.platform,
    request,
    route: { id: route?.id ?? null },
    setHeaders: (new_headers) => {
      for (const key2 in new_headers) {
        const lower = key2.toLowerCase();
        const value = new_headers[key2];
        if (lower === "set-cookie") {
          throw new Error(
            "Use `event.cookies.set(name, value, options)` instead of `event.setHeaders` to set cookies"
          );
        } else if (lower in headers) {
          throw new Error(`"${key2}" header is already set`);
        } else {
          headers[lower] = value;
          if (state.prerendering && lower === "cache-control") {
            state.prerendering.cache = /** @type {string} */
            value;
          }
        }
      }
    },
    url: url2,
    isDataRequest: is_data_request,
    isSubRequest: state.depth > 0
  };
  let resolve_opts = {
    transformPageChunk: default_transform,
    filterSerializedResponseHeaders: default_filter,
    preload: default_preload
  };
  try {
    if (route) {
      if (url2.pathname === base || url2.pathname === base + "/") {
        trailing_slash = "always";
      } else if (route.page) {
        const nodes = await Promise.all([
          // we use == here rather than === because [undefined] serializes as "[null]"
          ...route.page.layouts.map((n2) => n2 == void 0 ? n2 : manifest2._.nodes[n2]()),
          manifest2._.nodes[route.page.leaf]()
        ]);
        if (DEV) {
          const layouts = nodes.slice(0, -1);
          const page2 = nodes.at(-1);
          for (const layout of layouts) {
            if (layout) {
              validate_layout_server_exports(
                layout.server,
                /** @type {string} */
                layout.server_id
              );
              validate_layout_exports(
                layout.universal,
                /** @type {string} */
                layout.universal_id
              );
            }
          }
          if (page2) {
            validate_page_server_exports(
              page2.server,
              /** @type {string} */
              page2.server_id
            );
            validate_page_exports(
              page2.universal,
              /** @type {string} */
              page2.universal_id
            );
          }
        }
        trailing_slash = get_option(nodes, "trailingSlash");
      } else if (route.endpoint) {
        const node = await route.endpoint();
        trailing_slash = node.trailingSlash;
        if (DEV) {
          validate_server_exports(
            node,
            /** @type {string} */
            route.endpoint_id
          );
        }
      }
      if (!is_data_request) {
        const normalized = normalize_path(url2.pathname, trailing_slash ?? "never");
        if (normalized !== url2.pathname && !state.prerendering?.fallback) {
          return new Response(void 0, {
            status: 308,
            headers: {
              "x-sveltekit-normalize": "1",
              location: (
                // ensure paths starting with '//' are not treated as protocol-relative
                (normalized.startsWith("//") ? url2.origin + normalized : normalized) + (url2.search === "?" ? "" : url2.search)
              )
            }
          });
        }
      }
    }
    const { cookies, new_cookies, get_cookie_header, set_internal } = get_cookies(
      request,
      url2,
      trailing_slash ?? "never"
    );
    cookies_to_add = new_cookies;
    event.cookies = cookies;
    event.fetch = create_fetch({
      event,
      options: options2,
      manifest: manifest2,
      state,
      get_cookie_header,
      set_internal
    });
    if (state.prerendering && !state.prerendering.fallback)
      disable_search(url2);
    const response = await options2.hooks.handle({
      event,
      resolve: (event2, opts) => resolve2(event2, opts).then((response2) => {
        for (const key2 in headers) {
          const value = headers[key2];
          response2.headers.set(
            key2,
            /** @type {string} */
            value
          );
        }
        add_cookies_to_headers(response2.headers, Object.values(cookies_to_add));
        if (state.prerendering && event2.route.id !== null) {
          response2.headers.set("x-sveltekit-routeid", encodeURI(event2.route.id));
        }
        return response2;
      })
    });
    if (response.status === 200 && response.headers.has("etag")) {
      let if_none_match_value = request.headers.get("if-none-match");
      if (if_none_match_value?.startsWith('W/"')) {
        if_none_match_value = if_none_match_value.substring(2);
      }
      const etag = (
        /** @type {string} */
        response.headers.get("etag")
      );
      if (if_none_match_value === etag) {
        const headers2 = new Headers({ etag });
        for (const key2 of [
          "cache-control",
          "content-location",
          "date",
          "expires",
          "vary",
          "set-cookie"
        ]) {
          const value = response.headers.get(key2);
          if (value)
            headers2.set(key2, value);
        }
        return new Response(void 0, {
          status: 304,
          headers: headers2
        });
      }
    }
    if (is_data_request && response.status >= 300 && response.status <= 308) {
      const location = response.headers.get("location");
      if (location) {
        return redirect_json_response(new Redirect(
          /** @type {any} */
          response.status,
          location
        ));
      }
    }
    return response;
  } catch (e3) {
    if (e3 instanceof Redirect) {
      const response = is_data_request ? redirect_json_response(e3) : route?.page && is_action_json_request(event) ? action_json_redirect(e3) : redirect_response(e3.status, e3.location);
      add_cookies_to_headers(response.headers, Object.values(cookies_to_add));
      return response;
    }
    return await handle_fatal_error(event, options2, e3);
  }
  async function resolve2(event2, opts) {
    try {
      if (opts) {
        if ("ssr" in opts) {
          throw new Error(
            "ssr has been removed, set it in the appropriate +layout.js instead. See the PR for more information: https://github.com/sveltejs/kit/pull/6197"
          );
        }
        resolve_opts = {
          transformPageChunk: opts.transformPageChunk || default_transform,
          filterSerializedResponseHeaders: opts.filterSerializedResponseHeaders || default_filter,
          preload: opts.preload || default_preload
        };
      }
      if (state.prerendering?.fallback) {
        return await render_response({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          page_config: { ssr: false, csr: true },
          status: 200,
          error: null,
          branch: [],
          fetched: [],
          resolve_opts
        });
      }
      if (route) {
        const method = (
          /** @type {import('types').HttpMethod} */
          event2.request.method
        );
        let response;
        if (is_data_request) {
          response = await render_data(
            event2,
            route,
            options2,
            manifest2,
            state,
            invalidated_data_nodes,
            trailing_slash ?? "never"
          );
        } else if (route.endpoint && (!route.page || is_endpoint_request(event2))) {
          response = await render_endpoint(event2, await route.endpoint(), state);
        } else if (route.page) {
          if (page_methods.has(method)) {
            response = await render_page(event2, route.page, options2, manifest2, state, resolve_opts);
          } else {
            const allowed_methods2 = new Set(allowed_page_methods);
            const node = await manifest2._.nodes[route.page.leaf]();
            if (node?.server?.actions) {
              allowed_methods2.add("POST");
            }
            if (method === "OPTIONS") {
              response = new Response(null, {
                status: 204,
                headers: {
                  allow: Array.from(allowed_methods2.values()).join(", ")
                }
              });
            } else {
              const mod = [...allowed_methods2].reduce(
                (acc, curr) => {
                  acc[curr] = true;
                  return acc;
                },
                /** @type {Record<string, any>} */
                {}
              );
              response = method_not_allowed(mod, method);
            }
          }
        } else {
          throw new Error("This should never happen");
        }
        if (request.method === "GET" && route.page && route.endpoint) {
          const vary = response.headers.get("vary")?.split(",")?.map((v) => v.trim().toLowerCase());
          if (!(vary?.includes("accept") || vary?.includes("*"))) {
            response = new Response(response.body, {
              status: response.status,
              statusText: response.statusText,
              headers: new Headers(response.headers)
            });
            response.headers.append("Vary", "Accept");
          }
        }
        return response;
      }
      if (state.error && event2.isSubRequest) {
        return await fetch(request, {
          headers: {
            "x-sveltekit-error": "true"
          }
        });
      }
      if (state.error) {
        return text("Internal Server Error", {
          status: 500
        });
      }
      if (state.depth === 0) {
        return await respond_with_error({
          event: event2,
          options: options2,
          manifest: manifest2,
          state,
          status: 404,
          error: new NotFound(event2.url.pathname),
          resolve_opts
        });
      }
      if (state.prerendering) {
        return text("not found", { status: 404 });
      }
      return await fetch(request);
    } catch (e3) {
      return await handle_fatal_error(event2, options2, e3);
    } finally {
      event2.cookies.set = () => {
        throw new Error("Cannot use `cookies.set(...)` after the response has been generated");
      };
      event2.setHeaders = () => {
        throw new Error("Cannot use `setHeaders(...)` after the response has been generated");
      };
    }
  }
}
function filter_private_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(private_prefix) && (public_prefix === "" || !k.startsWith(public_prefix))
    )
  );
}
function filter_public_env(env, { public_prefix, private_prefix }) {
  return Object.fromEntries(
    Object.entries(env).filter(
      ([k]) => k.startsWith(public_prefix) && (private_prefix === "" || !k.startsWith(private_prefix))
    )
  );
}
var Server = class {
  /** @type {import('types').SSROptions} */
  #options;
  /** @type {import('@sveltejs/kit').SSRManifest} */
  #manifest;
  /** @param {import('@sveltejs/kit').SSRManifest} manifest */
  constructor(manifest2) {
    this.#options = options;
    this.#manifest = manifest2;
  }
  /**
   * @param {{
   *   env: Record<string, string>
   * }} opts
   */
  async init({ env }) {
    set_private_env(
      filter_private_env(env, {
        public_prefix: this.#options.env_public_prefix,
        private_prefix: this.#options.env_private_prefix
      })
    );
    set_public_env(
      filter_public_env(env, {
        public_prefix: this.#options.env_public_prefix,
        private_prefix: this.#options.env_private_prefix
      })
    );
    if (!this.#options.hooks) {
      try {
        const module = await get_hooks();
        this.#options.hooks = {
          handle: module.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
          handleError: module.handleError || (({ error: error210 }) => console.error(error210)),
          handleFetch: module.handleFetch || (({ request, fetch: fetch2 }) => fetch2(request))
        };
      } catch (error210) {
        {
          this.#options.hooks = {
            handle: () => {
              throw error210;
            },
            handleError: ({ error: error310 }) => console.error(error310),
            handleFetch: ({ request, fetch: fetch2 }) => fetch2(request)
          };
        }
      }
    }
  }
  /**
   * @param {Request} request
   * @param {import('types').RequestOptions} options
   */
  async respond(request, options2) {
    if (!(request instanceof Request)) {
      throw new Error(
        "The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details"
      );
    }
    return respond(request, this.#options, this.#manifest, {
      ...options2,
      error: false,
      depth: 0
    });
  }
};

// .svelte-kit/cloudflare-tmp/manifest.js
var manifest = (() => {
  function __memo(fn) {
    let value;
    return () => value ??= value = fn();
  }
  return {
    appDir: "_app",
    appPath: "_app",
    assets: /* @__PURE__ */ new Set(["favicon.png", "favicon.svg", "_headers"]),
    mimeTypes: { ".png": "image/png", ".svg": "image/svg+xml" },
    _: {
      client: { "start": "_app/immutable/entry/start.c1485827.js", "app": "_app/immutable/entry/app.64e68449.js", "imports": ["_app/immutable/entry/start.c1485827.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/singletons.b8573d35.js", "_app/immutable/chunks/index.9628e424.js", "_app/immutable/chunks/parse.bee59afc.js", "_app/immutable/entry/app.64e68449.js", "_app/immutable/chunks/scheduler.1a6e5117.js", "_app/immutable/chunks/index.db98bb86.js"], "stylesheets": [], "fonts": [] },
      nodes: [
        __memo(() => Promise.resolve().then(() => (init__(), __exports))),
        __memo(() => Promise.resolve().then(() => (init__2(), __exports2))),
        __memo(() => Promise.resolve().then(() => (init__3(), __exports3))),
        __memo(() => Promise.resolve().then(() => (init__4(), __exports4))),
        __memo(() => Promise.resolve().then(() => (init__5(), __exports5))),
        __memo(() => Promise.resolve().then(() => (init__6(), __exports6))),
        __memo(() => Promise.resolve().then(() => (init__7(), __exports7))),
        __memo(() => Promise.resolve().then(() => (init__8(), __exports8))),
        __memo(() => Promise.resolve().then(() => (init__9(), __exports9))),
        __memo(() => Promise.resolve().then(() => (init__10(), __exports10))),
        __memo(() => Promise.resolve().then(() => (init__11(), __exports11))),
        __memo(() => Promise.resolve().then(() => (init__12(), __exports12))),
        __memo(() => Promise.resolve().then(() => (init__13(), __exports13))),
        __memo(() => Promise.resolve().then(() => (init__14(), __exports14))),
        __memo(() => Promise.resolve().then(() => (init__15(), __exports15))),
        __memo(() => Promise.resolve().then(() => (init__16(), __exports16))),
        __memo(() => Promise.resolve().then(() => (init__17(), __exports17))),
        __memo(() => Promise.resolve().then(() => (init__18(), __exports18))),
        __memo(() => Promise.resolve().then(() => (init__19(), __exports19))),
        __memo(() => Promise.resolve().then(() => (init__20(), __exports20))),
        __memo(() => Promise.resolve().then(() => (init__21(), __exports21))),
        __memo(() => Promise.resolve().then(() => (init__22(), __exports22))),
        __memo(() => Promise.resolve().then(() => (init__23(), __exports23)))
      ],
      routes: [
        {
          id: "/",
          pattern: /^\/$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 2 },
          endpoint: null
        },
        {
          id: "/api/activity",
          pattern: /^\/api\/activity\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts(), server_ts_exports)))
        },
        {
          id: "/api/security/blocks",
          pattern: /^\/api\/security\/blocks\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts2(), server_ts_exports2)))
        },
        {
          id: "/api/security/event-logs",
          pattern: /^\/api\/security\/event-logs\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts3(), server_ts_exports3)))
        },
        {
          id: "/assets",
          pattern: /^\/assets\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 3 },
          endpoint: null
        },
        {
          id: "/assets/[id]",
          pattern: /^\/assets\/([^/]+?)\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0], errors: [1], leaf: 4 },
          endpoint: null
        },
        {
          id: "/audit-log",
          pattern: /^\/audit-log\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 5 },
          endpoint: null
        },
        {
          id: "/auth/emergency-reset",
          pattern: /^\/auth\/emergency-reset\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 6 },
          endpoint: null
        },
        {
          id: "/auth/login",
          pattern: /^\/auth\/login\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 7 },
          endpoint: null
        },
        {
          id: "/auth/logout",
          pattern: /^\/auth\/logout\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts4(), server_ts_exports4)))
        },
        {
          id: "/auth/register",
          pattern: /^\/auth\/register\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 8 },
          endpoint: null
        },
        {
          id: "/auth/reset-password/[token]",
          pattern: /^\/auth\/reset-password\/([^/]+?)\/?$/,
          params: [{ "name": "token", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0], errors: [1], leaf: 9 },
          endpoint: null
        },
        {
          id: "/dashboard",
          pattern: /^\/dashboard\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 10 },
          endpoint: null
        },
        {
          id: "/favicon.ico",
          pattern: /^\/favicon\.ico\/?$/,
          params: [],
          page: null,
          endpoint: __memo(() => Promise.resolve().then(() => (init_server_ts5(), server_ts_exports5)))
        },
        {
          id: "/join-organization",
          pattern: /^\/join-organization\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 11 },
          endpoint: null
        },
        {
          id: "/onboarding",
          pattern: /^\/onboarding\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 12 },
          endpoint: null
        },
        {
          id: "/profile",
          pattern: /^\/profile\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 13 },
          endpoint: null
        },
        {
          id: "/select-organization",
          pattern: /^\/select-organization\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 14 },
          endpoint: null
        },
        {
          id: "/sites",
          pattern: /^\/sites\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 15 },
          endpoint: null
        },
        {
          id: "/sites/[id]",
          pattern: /^\/sites\/([^/]+?)\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0], errors: [1], leaf: 16 },
          endpoint: null
        },
        {
          id: "/templates",
          pattern: /^\/templates\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 17 },
          endpoint: null
        },
        {
          id: "/templates/[id]",
          pattern: /^\/templates\/([^/]+?)\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0], errors: [1], leaf: 18 },
          endpoint: null
        },
        {
          id: "/users",
          pattern: /^\/users\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 19 },
          endpoint: null
        },
        {
          id: "/users/security",
          pattern: /^\/users\/security\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 20 },
          endpoint: null
        },
        {
          id: "/work-orders",
          pattern: /^\/work-orders\/?$/,
          params: [],
          page: { layouts: [0], errors: [1], leaf: 21 },
          endpoint: null
        },
        {
          id: "/work-orders/[id]",
          pattern: /^\/work-orders\/([^/]+?)\/?$/,
          params: [{ "name": "id", "optional": false, "rest": false, "chained": false }],
          page: { layouts: [0], errors: [1], leaf: 22 },
          endpoint: null
        }
      ],
      matchers: async () => {
        return {};
      }
    }
  };
})();
var prerendered = /* @__PURE__ */ new Set([]);

// .svelte-kit/cloudflare-tmp/_worker.js
async function e(e3, t2) {
  let n2 = "string" != typeof t2 && "HEAD" === t2.method;
  n2 && (t2 = new Request(t2, { method: "GET" }));
  let r3 = await e3.match(t2);
  return n2 && r3 && (r3 = new Response(null, r3)), r3;
}
function t(e3, t2, n2, o2) {
  return ("string" == typeof t2 || "GET" === t2.method) && r(n2) && (n2.headers.has("Set-Cookie") && (n2 = new Response(n2.body, n2)).headers.append("Cache-Control", "private=Set-Cookie"), o2.waitUntil(e3.put(t2, n2.clone()))), n2;
}
var n = /* @__PURE__ */ new Set([200, 203, 204, 300, 301, 404, 405, 410, 414, 501]);
function r(e3) {
  if (!n.has(e3.status))
    return false;
  if (~(e3.headers.get("Vary") || "").indexOf("*"))
    return false;
  let t2 = e3.headers.get("Cache-Control") || "";
  return !/(private|no-cache|no-store)/i.test(t2);
}
function o(n2) {
  return async function(r3, o2) {
    let a = await e(n2, r3);
    if (a)
      return a;
    o2.defer((e3) => {
      t(n2, r3, e3, o2);
    });
  };
}
var s2 = caches.default;
var c = t.bind(0, s2);
var r2 = e.bind(0, s2);
var e2 = o.bind(0, s2);
var server = new Server(manifest);
var worker = {
  async fetch(req, env, context) {
    await server.init({ env });
    let pragma = req.headers.get("cache-control") || "";
    let res = !pragma.includes("no-cache") && await r2(req);
    if (res)
      return res;
    let { pathname, search } = new URL(req.url);
    try {
      pathname = decodeURIComponent(pathname);
    } catch {
    }
    const stripped_pathname = pathname.replace(/\/$/, "");
    let is_static_asset = false;
    const filename = stripped_pathname.substring(1);
    if (filename) {
      is_static_asset = manifest.assets.has(filename) || manifest.assets.has(filename + "/index.html");
    }
    let location = pathname.at(-1) === "/" ? stripped_pathname : pathname + "/";
    if (is_static_asset || prerendered.has(pathname)) {
      res = await env.ASSETS.fetch(req);
    } else if (location && prerendered.has(location)) {
      if (search)
        location += search;
      res = new Response("", {
        status: 308,
        headers: {
          location
        }
      });
    } else {
      res = await server.respond(req, {
        // @ts-ignore
        platform: { env, context, caches, cf: req.cf },
        getClientAddress() {
          return req.headers.get("cf-connecting-ip");
        }
      });
    }
    pragma = res.headers.get("cache-control") || "";
    return pragma && res.status < 400 ? c(req, res, context) : res;
  }
};
var worker_default = worker;
export {
  worker_default as default
};
/*! Bundled license information:

@prisma/client-runtime-utils/dist/index.js:
  (*! Bundled license information:
  
  decimal.js/decimal.mjs:
    (*!
     *  decimal.js v10.5.0
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     *)
  *)
*/
//# sourceMappingURL=_worker.js.map
